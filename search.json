[{"title":"Closure的基本概念","url":"/2016/11/08/Closure%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"<p>談到closure，首先要先瞭解First-cass Function，所謂的first-class function是指函式可以被assign給變數或儲存於資料結構中，並且可以作為其他函數的參數，或是作為其他的函數的回傳值。而python裡的每個function都是first-class function，所以在python中可以作到以下的操作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max</span>(<span class=\"params\">m, n</span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> m <span class=\"keyword\">if</span> m &gt; n <span class=\"keyword\">else</span> n</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">max</span>(<span class=\"number\">5</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func = <span class=\"built_in\">max</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(<span class=\"number\">7</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<p>我們可以把max這個函式assign給func，再使用func來實際使用max這個函式。</p>\n<p>要建立一個closure，在python中可以透過建立巢狀函式(nested function)來實作，其中內部函式會依據<a href=\"/2016/11/02/namespace%E8%88%87LEGB-scope%E8%A6%8F%E5%89%87/\">LEGB規則</a>參照Enclosed scope的外部函式變數，此變數又稱為自由變數(free variable)。自由變數將會和此函式同時存在，即使離開了創造此變數的環境/區域也可以被此函式使用不會消失。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">target_value</span>(<span class=\"params\">x</span>):</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compare</span>(<span class=\"params\">y</span>):</span>        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&gt; target&#x27;</span> <span class=\"keyword\">if</span> y &gt; x <span class=\"keyword\">else</span> <span class=\"string\">&#x27;&lt; target&#x27;</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> compare</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func = target_value(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(<span class=\"number\">5</span>)</span><br><span class=\"line\">&lt; target</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func2 = target_value(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func2(<span class=\"number\">5</span>)</span><br><span class=\"line\">&gt; target</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func.__closure__[<span class=\"number\">0</span>].cell_contents</span><br><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>上面是一個closure的例子，首先呼叫外部函式target_value將參數傳入，並回傳內部函式compare且assign給func，這是一個first-class function的實作。而每一次呼叫target_value後就會產生一個closure實例，每一個實例會binding到不同的自由變數x，它並不會因為離開了創造它的target_value函式而消失，反而在透過func呼叫compare時被closure補捉使用。python還有個__colsure__可以看到在enclosed scop所補捉到的自由變數</p>\n<p>總結來說，並不是每個巢狀函式都是closure，巢狀函式需要補捉到enclosed scope的自由變數，使得此變數在脫離原本的環境仍可被內部函式使用，這樣才為closure。</p>\n<p>在使用上closure並不是一定要有的設計方式，但是有時使用closure可以幫助有效的組織程式碼，並提升程式碼的可讀性。像是當我們有資料需要重複使用，但是又不想都塞在global，這時可以透過自由變數來存放再用closure捕捉來降低global變數的數量；另外也可以透過closure來隱藏變數，作出private的效果。</p>\n<p>2016/11/14</p>\n<p>捕捉到自由變數並不能作修改，如果需要修改自由變數，可透過<a href=\"/2016/11/14/nonlocal%E8%88%87global%E9%97%9C%E9%8D%B5%E5%AD%97/\">nonlocal</a>來宣告變數，並作進一步的操作</p>\n<p>參考資料:<br/><a href=\"https://en.wikipedia.org/wiki/First-class_function\">Wiki-First-Class Function</a><br/><a href=\"https://en.wikipedia.org/wiki/Closure_(computer_programming)\">Wiki-Closure</a><br/><a href=\"http://www.codedata.com.tw/java/understanding-lambda-closure-3-python-support/\">認識 Lambda/Closure（3）Python 對 Lambda/Closure 的支援</a></p>\n","categories":["Python"],"tags":["Python"]},{"title":"Generator的概念與如何使用","url":"/2017/03/14/Generator%E7%9A%84%E6%A6%82%E5%BF%B5%E8%88%87%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/","content":"<p>generator本身也是iterator，和iterator不同的地方在於generator會透過function宣告的方式，但有別於一般的function直接return回傳值，generator的function會在”有需要”的時候，使用yield來回傳值。為什麼稱為”有需要”的時候呢？因為generator在每次呼叫next()回傳值後，會記下所有的資料並保留最後一次執行狀態，直到下一次呼叫next()才會再繼續執行未結束的狀態。我們可以看一下下面這個範例:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">transform</span>(<span class=\"params\">data</span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> data:        </span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"built_in\">chr</span>(<span class=\"built_in\">ord</span>(char) + <span class=\"number\">1</span>)  <span class=\"comment\"># 透過yield回傳值後留存狀態</span></span><br></pre></td></tr></table></figure>\n<p>在每一次呼叫next()時，generator才會開始執行，並且每次執行到yield回傳值後停止，並保留執行狀態直到下一次呼叫next()才繼續執行。當generator終止後呼叫next()則會發生StopIteration。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>char = transform(<span class=\"string\">&#x27;python&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(char)</span><br><span class=\"line\">q</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(char)</span><br><span class=\"line\">z</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(char)</span><br><span class=\"line\">i</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(char)</span><br><span class=\"line\">p</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(char)</span><br><span class=\"line\">p</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(char)</span><br><span class=\"line\">o</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(char)</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">File &lt;stdin&gt;, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span>     </span><br><span class=\"line\">    <span class=\"built_in\">next</span>(char)StopIteration</span><br></pre></td></tr></table></figure>\n<p>也可以使用for loop來呼叫generator</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> transform(<span class=\"string\">&#x27;python&#x27;</span>):     </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(char)</span><br><span class=\"line\"></span><br><span class=\"line\">q</span><br><span class=\"line\">z</span><br><span class=\"line\">u</span><br><span class=\"line\">i</span><br><span class=\"line\">p</span><br><span class=\"line\">o</span><br></pre></td></tr></table></figure>\n<p>使用generator最大的好處在於可以有效的處理一次性使用大量使用Memory的情況，將要一次性處理的過程拆成generator分次執行。例如當需要讀取很大的檔案處理時(甚至是多個很大的檔案)。而且使用generator可以降低iterator在loop的維度，讓程式碼可以更加的乾淨。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_line_title</span>(<span class=\"params\">file_name</span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> file_name:        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> <span class=\"built_in\">open</span>(file, mode=<span class=\"string\">&#x27;r&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>):            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> line.istitle():                </span><br><span class=\"line\">                <span class=\"keyword\">yield</span> line</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lines = get_line_title(file_name)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> lines:</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>    <span class=\"built_in\">print</span>(line)</span><br></pre></td></tr></table></figure>\n<p>上面的範例會產生generator並逐次判斷每一行內容，並回傳所有的標題。其中會用到兩個for loop和一個邏輯判斷，我們可以改寫成下面這樣，把讀取的部份和邏輯判斷的部份拆開來。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_line</span>(<span class=\"params\">files</span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> files:        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> <span class=\"built_in\">open</span>(file, mode=<span class=\"string\">&#x27;r&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>):            <span class=\"keyword\">yield</span> line</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_title</span>(<span class=\"params\">lines</span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (line <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> lines <span class=\"keyword\">if</span> line.istitle())</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>all_line = get_line(file_name)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> title <span class=\"keyword\">in</span> get_title(all_line):</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>    <span class=\"built_in\">print</span>(title)</span><br></pre></td></tr></table></figure>\n<p>如果善用generator可以有效的管理Memory的使用，也可以讓程式碼更加的有可讀性!</p>\n<p>參考資料:<br/><a href=\"https://docs.python.org/3/tutorial/classes.html#generators\">Python Docs - Generators</a><br/><a href=\"http://anandology.com/python-practice-book/iterators.html\">Iterators &amp; Generators</a><br/><a href=\"https://realpython.com/blog/python/introduction-to-python-generators/\">Introduction to Python Generators</a></p>\n","categories":["Python"],"tags":["Python"]},{"title":"Iterators的概念與如何使用","url":"/2017/03/07/Iterators%E7%9A%84%E6%A6%82%E5%BF%B5%E8%88%87%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/","content":"<p>python中有些資料結構是可以透過for來loop裡面所有的item的，像是list, tuple, dict, str還有file都可以。在使用上其實for迴圈會呼叫物件中的iter()，此函式會回傳一個Iterator(迭代器)，Iterator會透過<strong>next</strong>函式來一次一次的取得下一個item，並在沒有下一個item的時候拋出StopIteration來告訴for迴圈迭代結束。</p>\n<p>像這種有按照Iteration Protocol定義<strong>iter</strong>和<strong>next</strong>的物件又被稱為Iterable</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> &#123;<span class=\"string\">&#x27;one&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;two&#x27;</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> <span class=\"string\">&#x27;python&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;file&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>如果希望自己定義的物件是Iterable，只要透過在class內實作<strong>iter</strong>和<strong>next</strong>(讓python的build-in函式iter()和next()可以呼叫)就可以達成。</p>\n<p>假設我們建立了一個物件可以設定一個字串，並在每次iteration的時候透過ascii回傳每個字元的下一個字元</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transform</span>:</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init</span>(<span class=\"params\">self, data</span>):</span>        </span><br><span class=\"line\">        self.data = data        </span><br><span class=\"line\">        self.i = <span class=\"number\">0</span>        </span><br><span class=\"line\">        self.n = <span class=\"built_in\">len</span>(data)    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">iter</span>(<span class=\"params\">self</span>):</span>        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self    </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">next</span>(<span class=\"params\">self</span>):</span>        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.i == self.n:            </span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StopIteration        </span><br><span class=\"line\">        item = <span class=\"built_in\">chr</span>(<span class=\"built_in\">ord</span>(self.data[self.i]) + <span class=\"number\">1</span>)        </span><br><span class=\"line\">        self.i = self.i + <span class=\"number\">1</span>        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> item</span><br></pre></td></tr></table></figure>\n<p>宣告一個Transform物件，並用for來讀取每一個值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>t = Transform(<span class=\"string\">&#x27;python&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> t:  <span class=\"comment\"># for迴圈自動叫iter()，並用next()來作iteration</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>    <span class=\"built_in\">print</span>(item)</span><br><span class=\"line\">q</span><br><span class=\"line\">z</span><br><span class=\"line\">u</span><br><span class=\"line\">i</span><br><span class=\"line\">p</span><br><span class=\"line\">o</span><br></pre></td></tr></table></figure>\n<p>宣告一個Transform物件，並呼叫iter並用next來讀取每一個值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>t = Transform(<span class=\"string\">&#x27;python&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>t2 = <span class=\"built_in\">iter</span>(t)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(t2)</span><br><span class=\"line\">q</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(t2)</span><br><span class=\"line\">z</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(t2)</span><br><span class=\"line\">u</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(t2)</span><br><span class=\"line\">i</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(t2)</span><br><span class=\"line\">p</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(t2)</span><br><span class=\"line\">o</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(t2)  <span class=\"comment\"># 當沒有下一個item之前，會產生StopIteration</span></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">File &lt;stdin&gt;, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span>     </span><br><span class=\"line\">    <span class=\"built_in\">next</span>(t2)</span><br><span class=\"line\">StopIteration</span><br></pre></td></tr></table></figure>\n<p>除了透過定義<strong>iter</strong>和<strong>next</strong>讓自己的物件為iterable，也可以透過在class中定義<strong>getitem</strong>來達成。兩者只要有定義其中一種，都可以讓for loop來依序讀取物件中的item</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transform</span>:</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init</span>(<span class=\"params\">self, data</span>):</span>        </span><br><span class=\"line\">        self.data = data        </span><br><span class=\"line\">        self.i = <span class=\"number\">0</span>        </span><br><span class=\"line\">        self.n = <span class=\"built_in\">len</span>(data)    </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getitem</span>(<span class=\"params\">self, i</span>):</span>        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">chr</span>(<span class=\"built_in\">ord</span>(self.data[i]) + <span class=\"number\">1</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>t = Transform(<span class=\"string\">&#x27;python&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> t:  <span class=\"comment\"># 透過定義__getitem__也可以讓物件為iterable，並可以使用在for loop</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>    <span class=\"built_in\">print</span>(item)</span><br><span class=\"line\">q</span><br><span class=\"line\">z</span><br><span class=\"line\">u</span><br><span class=\"line\">i</span><br><span class=\"line\">p</span><br><span class=\"line\">o</span><br></pre></td></tr></table></figure>\n<p>參考資料:<br/><a href=\"https://docs.python.org/3/tutorial/classes.html#iterators\">Python docs - Iterators</a><br/><a href=\"https://docs.python.org/dev/library/stdtypes.html#iterator-types\">Python docs - Iterator types</a><br/><a href=\"https://docs.python.org/dev/glossary.html#term-iterable\">Python docs - Iterable</a></p>\n","categories":["Python"],"tags":["Python"]},{"title":"隱馬可夫模型 - Hidden Markov Model(HMM)","url":"/2017/05/31/Hidden_Markov_Model_HMM/","content":"<p>隱馬可夫模型(Hidden Markov Model, HMM)是一種具有隱含未知參數的馬可夫鏈(Markov Chain)，隱馬可夫模型常被使用在許多AI與Machine Learning的應用。既然隱馬可夫模型是一種馬可夫鏈，一開始先來簡單介紹一下什麼是馬可夫鏈</p>\n<p>馬可夫鏈是指從一個狀態轉移到另一個狀態的隨機過程，且下一個狀態只能由當前狀態決定，根據機率分布從一個狀態轉移到另一個狀態，或是保持目前狀態，不同狀態間改變的機率稱為轉移機率(Transition Probability)。</p>\n<img src=\"/2017/05/31/Hidden_Markov_Model_HMM/MarkovChain.jpg\" class=\"\" width=\"500\">\n\n<p>以上面的例子來說明，這是一個具有兩個狀態的馬可夫鏈，S1是雨天(Rainy)，S2是晴天(Sunny)。其中S1可以轉移到S2也可以保持在S1，S2可以轉移到S1，也可以保持在S2。使用天氣變化這個例子來說明的話，可以表示成如果今天是雨天，明天可能是晴天也可能維持雨天。</p>\n<img src=\"/2017/05/31/Hidden_Markov_Model_HMM/MarkovChainExample.jpg\" class=\"\" width=\"500\">\n\n<p>如果我們有一個地區的天氣變化歷史紀錄，就可以統計出此地區晴天和雨天的轉移機率，並算出未來是晴天或是雨天的機率。假設已經知道今天是雨天，我們就可以從上面的樹狀範例可以輕易的計算出後天是雨天的機率是0.61，也可以使用矩算運算來算出後天是雨天和晴天的機率。</p>\n<p>再來開始談談什麼是隱馬可夫模型，在隱馬可夫模型被隱藏起來不可見的就是狀態本身，雖然狀態被隱藏起來看不到了，但是卻可以透過「觀察序列」來間接的透露出狀態的訊息。</p>\n<p>以wiki上面的天氣例子來說明，假設我本來每天都可以直接看到我居住地區的天氣狀態，有一天我搬家了沒辦法直接觀察原本地區的天氣狀態。雖然我無法直接看到原本地區的天氣狀態，但是我知道住在原本那個地區的朋友，在雨天的時候會有10%機率出門散布、40%機率出門購物，和50%在家打掃；在雨天的時候會有60%機率出門散布、30%機率出門購物，和10%在家打掃。</p>\n<img src=\"/2017/05/31/Hidden_Markov_Model_HMM/HMM.jpg\" class=\"\" width=\"500\">\n\n<p>隱馬可夫模型讓我們可以透過觀察「看得到的」現象去推測另一個「看不到的」現象。以上面舉的例子來說，雖然我無法得知該地區的天氣狀況，但是我就可以透過觀察朋友每天的連續行為，來推測該地區的天氣狀況，並且以上面的方式來呈現一個隱馬可夫模型。</p>\n<p>通常隱馬可夫模型有三大重要的問題:</p>\n<ol>\n<li>已知HMM模型，找出一個特定輸出序列的機率</li>\n<li>已知HMM模型，找出一個特定輸出序列的隱藏狀態序列</li>\n<li>未知HMM模型，找到最可能的狀態轉移和輸出機率</li>\n</ol>\n<p>不同的演算法都有相對應的演算法可以使用，後續有機會再陸續介紹</p>\n<p>參考資料:<br/><a href=\"https://en.wikipedia.org/wiki/Hidden_Markov_model\">Wiki - Hidden_Markov_model</a><br/><a href=\"http://www.csie.ntnu.edu.tw/~u91029/HiddenMarkovModel.html\">演算法筆記 - HiddenMarkovModel</a><br/><a href=\"http://pansci.asia/archives/43586\">隱馬可夫模型：探索看不到的世界的數學工具</a><br/><a href=\"http://ccckmit.wikidot.com/st:markovchain\">馬可夫鏈</a></p>\n","categories":["Machine Learning"],"tags":["Machine Learning","HMM","Hideen Markov Model"]},{"title":"機器學習基石(Machine Learning Foundation)第十講筆記","url":"/2017/09/20/Machine-Learning-Foundation-10/","content":"<p>上次介紹了linear regression，這一堂課會說到logistic regression，主要會將linear regression使用sigmoid轉換來算出不同類別的機率。</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/HeartAttackPredictionProblem.JPG\" class=\"\" width=\"500\">\n\n<p>之前有學過在二元分類中會判斷病人「有」或是「沒有」心臟疾病，並可以使用0/1的分類錯誤來判斷分類的結果好壞</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/HeartAttackPredictionProblem2.JPG\" class=\"\" width=\"500\">\n\n<p>但如果今天並非想要知道病人「有」或是「沒有」心臟疾病，而是想知道未來一段時間後，心臟疾病發生的機率是多少。和二元分類有點不同，我們想要知道的是發生某個狀況的機率，這會是一個介於0到1的數值。當然後續可以對這個數值定義出一個臨界值來達成二元分類，所以又可以稱為soft binary classification。</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/SoftBinaryClassification.JPG\" class=\"\" width=\"500\">\n\n<p>如果我們可以知道在給定一組x，他的結果y是一個機率值的話那就可以很容易的找到這樣的結果，但是實務上我們只會拿到有抽樣誤差雜訊的結果，只能知道0/1的結果(即有沒有心臟病發)。再來會學到的是，如果只能知道0/1的情況下，要如何求出想要的機率值。</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/LogisticHypothesis.JPG\" class=\"\" width=\"500\">\n\n<p>要如何找到這個機率值呢？一樣可以像之前的線性問題，將每個特徵乘上特徵權重，就會找到分數，但是這次想要的不是這個分數，而且要把分數轉換為0到1的機率值，分數越大機率越大，反之分數越小機率就越對，這裡會透過logistic function會把這個分數值轉換成0到1的機率值。</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/LogisticFunction.JPG\" class=\"\" width=\"500\">\n\n<p>一般會使用sigmoid來把分數轉換成0到1的機率值，當分數越大會越接近1，分數越小會越接近0。再來就可以使用這個logistic hypothesis來達到我們的目標函式f(x)</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/ThreeLinearModels.JPG\" class=\"\" width=\"500\">\n\n<p>究竟logistic和之前學到的有什麼差別呢？<br/>在linear classification算完分數會以0為臨界點來區分0/1類別，並使用0/1 err來判斷結果，在linear regression則會直接輸出分數，再使用squared err來評估結果；logistic regression會將算完的分數透過logistic function轉換，但該用什麼err來衡量呢？</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/Likelihood.JPG\" class=\"\" width=\"500\">\n\n<p>首先可以先算出f(x)是怎麼產生一組資料D的，再來因為要使用hypothesis H來逼近f(x)，所以可以把f取代成h，因為最好的狀況下，我們學習到的h和原本的f是會非常接近。而且如果資料D是由f產生的，那麼f算出來的機率值應該是很大的，所以若是可以在多個h裡面找到一個最大機率的h，就能找到一個最適合的hypothesis</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/LikelihoodLogisticHypothesis.JPG\" class=\"\" width=\"500\">\n\n<p>在計算likeliood時，重點會放在hypothesis上，因為hypothesis決定了最後的機率，再來因為logistic function具有對稱性，所以最後可以整理成h(YnXn)的連乘</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/CrossEntropyError.JPG\" class=\"\" width=\"500\">\n\n<p>因為這個hypothesis是線性的，在線性裡面我們關注的是其中的權重w，所以再重新整理將h取代成w，把y取代成線性組合yn*w</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/CrossEntropyError2.JPG\" class=\"\" width=\"500\">\n\n<p>之前最常處理的就是連加的問題，所以我們取log將連乘取代成連加，再來為了轉成求Ein，所以加上負號來取最小值。最後再將logistic function代進去，就可以得到最後要求的Ein，這裡的Ein又可以稱為cross-entropy error。</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/MinimizingEin.JPG\" class=\"\" width=\"500\">\n\n<p>在推導出Ein後，再來就要找到一個權重w可以讓Ein最小，因為Ein最小就可以知道Eout也很小。前面的linear regression因為是convex所以可以透過梯度找到最小低，而logistic regression這個函式也是convex，所以也可以透過梯度來找到梯度為0的地方算出最好的權重w。</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/MinimizingEin2.JPG\" class=\"\" width=\"500\">\n\n<p>我們可以使用微分和鏈鎖率來找到梯度，如果今天要讓梯度等於0可以有一個假設，就是假設θ出來的值是0，但要讓θ出來的值是負無限大，就要讓y乘上w乘上x這一項是正的。其中w^T．x這個分數在以前可以被拿來作兩元分類，而乘上y如果大於0的話，代表是同號，即所有資料都可以分對，意義就是線性可分。之前在linear regression可以直接算出一個close-form的答案，但是現在logistic regression並非線性的，困難在於沒辦法直接算出close-form的解，那該怎麼辦呢？</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/IterativeOptimization.JPG\" class=\"\" width=\"500\">\n\n<p>這個時候就可以應用到之前的PLA方法，PLA在每次拜訪到的點如果分錯的話，就會逐步作調整來更新權重。</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/IterativeOptimization2.JPG\" class=\"\" width=\"500\">\n\n<p>在整理後可以歸納出兩個部分，如果需要更新權重的話，第一個η是指走多大一步，之前在PLA可以視為1，後面第二部份則是算出要走的方向。像這種逐步循序的調整學習又稱為iterative optimization approach逐步最佳化方法。</p>\n<p>那麼再來要如何找到logistic regression的最好權重值w呢？其實就是隨便找一個方向v，然後慢慢透過往下走到谷底就可以了，其中要走的步伐η會決定往下走的速度。</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/GradientDescent.JPG\" class=\"\" width=\"500\">\n\n<p>但是要怎麼找這個方向v呢？因為這個問題還是非線性，但是如果我們每次都看一小小段，就是一次只看一個線性問題，就可以比較容易而且轉成接近線性問題。其實這就是常使用的梯度下降法(Gradient Descent)，即每一次走梯度逐步找到最佳，或是近似最佳解。</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/StepChoice.JPG\" class=\"\" width=\"500\">\n\n<p>那麼η該怎麼決定呢？如果η太小的話，雖然遲早可以找到最佳值，但是速度會很慢；如果η太大的話，反而可以會跳過最小值，搞不好會跳來跳去找不到最佳值。有一個最好的方法，就是隨著坡度的大小來決定η要走的大小。</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/SimpleHeuristicEta.JPG\" class=\"\" width=\"500\">\n\n<p>因為η會改變，所以可以採用一個不一樣的η來代表這個會變動的η，即他每一次的學習都是會變化的η乘上梯度，這就稱為fixed learning rate gradient descent。</p>\n<img src=\"/2017/09/20/Machine-Learning-Foundation-10/PuttingEverythingTogether.JPG\" class=\"\" width=\"500\">\n\n<p>最後我們可以逐步的作梯度下降，一直到找到最好的谷點，但是實際上可以找到接近谷底的值就可以了，所以最常用的就是設定一個iteration的次數，到達就停止。這個方法其實就很像之前學到的pocket方法，pocket方法是每次抓一個最好的值，得到更好的值就會更新。</p>\n<p>因為之前有上過Andrew的Machine Learning課程，其實Andrew在教linear regression找最佳權重w時，就是直接教fixed learning rate的梯度下降法，我覺得在學習線性時用梯度下降還滿好理解的，對於後面到logistic regression很有幫助，建議沒有上過Andrew的Machine Learning課程可以考慮上看看！</p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/10_handout.pdf\">Machine Learning Foundation 10</a><br/><a href=\"https://www.coursera.org/learn/machine-learning\">Andrew Ng - Machine Learning</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習基石(Machine Learning Foundation)第十一講筆記","url":"/2017/09/28/Machine-Learning-Foundation-11/","content":"<p>上一講談到logistic regression，這一講會講到到底該如何使用線性的模型來作二元或是多元分類。</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/LinearModelsRevisited.JPG\" class=\"\" width=\"500\">\n\n<p>複習一下三種線性模型，共同點就是三種都會透過計算分數來作分類，差別在於PLA的線性分類會將分數取正負號來達到0/1分類，線性迴歸則是直接輸出分數，並使用squared error評估找到最佳解；logistic regression則是會透過logistic function將分數轉換成0到1的機率值。</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/ErrorFunctionsRevisited.JPG\" class=\"\" width=\"500\">\n\n<p>為了將線性模型作二元分類(y=-1/+1)，可以把error function稍微整理算出yx項，這個yx項的實際意義為分類的正確性，也就是yx項得到的分數要是正的(即兩者同號)，而且越大越好。</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/VisualizingErrorFunctions.JPG\" class=\"\" width=\"500\">\n\n<p>再來將三種模型的error畫出來，可以發現三種error的特性都不同，唯一相同地方在於如果squared和scaled cross-entropy很低時，通常0/1也會很低。</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/TheoreticalImplicationUpperBound.JPG\" class=\"\" width=\"500\">\n\n<p>究竟linear regression和logistic regression是否是好的分類方法呢？先從VC的角度來看scaled cross-entropy他會是0/1 error的upper bound，所以如果把logistic regression的cross-entropy error作到最小的話，也就可以說我們能把0/1 error也作的好。當然sqr err也是一樣，所以linear regression和logistic regression確實是可以作到二元分類的。</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/RegressionClassification.JPG\" class=\"\" width=\"500\">\n\n<p>在logistic/linear regression分類問題上，linear regression的好處是他最容易作到最佳化，但是其error衡量比較寬鬆；logistic regression因為他也是convex所以最佳化也是容易的，而error衡量在ys負向很小時會很寬鬆，但也比linear regression還好；PLA則是如果在線性可分的問題上可以作到很好，不過缺點就是如果在非性線可分的問題上，雖然可以使用pocket演算法，但是效果就沒那麼好。</p>\n<p>以前有有學過，雖然linear regression太過寬鬆，但是卻可以很快的先拿在找到一個初始的權重值，後續再交給PLA或是logistic regression作後續的最佳化。在實務上大部份的人會較常使用logistic regression來作二元分類，因為可以兼顧效果還有最佳化的容易程度。</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/IterativeOptimization.JPG\" class=\"\" width=\"500\">\n\n<p>雖然PLA和logistic regression都是iterative optimization方法，但是PLA是每看一點就作調整，而logistic regression卻要看完所有的資料點才會一次調整權重，他的速度和pocket一樣，每作一輪都要花比較長的時間，到底能不能讓logistic regression和PLA一樣快呢？</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/StochasticGradientDescent.JPG\" class=\"\" width=\"500\">\n\n<p>那不就學PLA每看一個點就調整一次權重就好了啊，這種每看一點作偏微分求梯度來調整權重的方法就稱為Stochastic Gradient Desent(SGD)，即用隨機的梯度作梯度下降來接近真實梯度的期望值。好處就是每次算一個點比較簡單而且容易計算，由其是在大量資料的情況下原本的批次梯度下降法速度會很慢，但是壞就就是一次看一個點所以每次調整的結果可能很不穩定，但是最終應該都會很接近要求的目標值。這種隨機梯度下降也適合online learning，即每次接到一筆新資料後即作學習調整權重。其實還有另外折衷的方法稱為mini-batch gradient desent，當我們沒辦法看完所有資料再調整權重時，那就一次看N筆資料作調整就好囉！</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/PLARevisited.JPG\" class=\"\" width=\"500\">\n\n<p>那PLA和logistic regression到底相差在哪裡呢？PLA是一次調整到位，而logistic是看差多少就調多少，所以SGD的logistic可以說他像soft的PLA，而PLA又很像η設成1的logistic。在執行logistic時有兩個可以調整討論的地方，第一個是停止條件，通常我們會執行夠多的次數，因為我們相信執行夠多次就會逐步接近目標執；另外是η的設定上，老師個人習慣會使用0.1126，也許之後需要調整學習速度時可以參考一下。</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/MulticlassClassification.JPG\" class=\"\" width=\"500\">\n\n<p>再來談到多類別分類的問題，實務上常會有很多多類別的問題，像是要辨識圖像上不同的東西就是多類別的問題，再來會介紹該怎麼使用二元分類來達成多類別分類。</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/MulticlassPrediction.JPG\" class=\"\" width=\"500\">\n\n<p>當我們想分類其中一種類別時，可以把其他三種當成同一種類別，這樣就可以建立四種二元分類器，把多類別問題轉成二元分類問題。但是這樣的方法會有某些地方有分類重疊的問題，像是四個角落都有兩種分類器範圍重疊，甚至也會有某些地方所有分類器都分不出來，像是中間區塊所有分類器都會認為不是自己要分類出來的區域。那該怎麼辦呢？</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/OneClassSoftly.JPG\" class=\"\" width=\"500\">\n\n<p>我們可以應用logistic regression來達成softly classfication，用顏色深淺來代表機率的大小，顏色越藍分到O機率越大，反之顏色越紅分到X的機率大。</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/SoftClassifiers.JPG\" class=\"\" width=\"500\">\n\n<p>再來組合出四個分類器，就可以知道在給定一組資料X，他究竟有分到不同類別的的機率有多少，所以可以透過選出機率最大的類別來判斷要分成哪個類別。</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/OVA.JPG\" class=\"\" width=\"500\">\n\n<p>當我們有K種類別要作分類時，透過logistic regression建立K個分類器，接著選出機率最高的類別，這種方法來作多類別分類稱為One-Versus-All(OVA)。好處是方法很有效率，而且只要和logistic regression能算出機率值的方法，都可以應用OVA作多類別分類，壞處是如果成兩元分類的資料不平衡的話，可能造成每個分類器都叫你猜大宗類別，造成最終分類效果不好。</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/Unbalance.JPG\" class=\"\" width=\"500\">\n\n<p>前面有講到OVA會遇到Unbalance問題，可能造成分類表現不好，那該怎麼解決這個問題呢？</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/OneVersusOne.JPG\" class=\"\" width=\"500\">\n\n<p>前面是一對其他所有類別作兩元分類，我們其實可以直接使用其中兩種類別的資料作二元分類就好了，如果兩種類別的資料接近的話，那麼資料量就會比較平均避免Unbalance問題。</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/PairwiseClassifiers.JPG\" class=\"\" width=\"500\">\n\n<p>那有這麼多的分類器，到底該如何判斷是哪個類別呢？以方塊類別為例，其中可以發現共6個分類器，其中前三個都說分出來的結果是方塊，後面三個則分類分到一個菱形和兩個星型，透過投票可以知道最可能的類別應該會是方塊，因為分出方塊佔大多數。</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/OVO.JPG\" class=\"\" width=\"500\">\n\n<p>這樣的方法稱為One-versus-one(OVO)，因為他是一對一類別的分類，而非一對其他所有類別的分類方法，透過一對一類別的分類別，再找出最有可能的的類別。這個方法的優點是在訓練資料時很有效果，因為只使用比較少的資料量來作訓練，而且可以應用在所有的二元分類問題；壞處則是要訓練更多的分類器，所以在預測的時間、訓練的次數還有儲存的空間都會花比較多。</p>\n<img src=\"/2017/09/28/Machine-Learning-Foundation-11/Summary.JPG\" class=\"\" width=\"500\">\n\n<p>這一講首先學到了前面講的三種線種模型方法其實都是可以用來作二元分類的，而且針對logistic regression可以使用SGD來作隨機梯度下降找最佳解，這樣的方法很像最早學到的PLA。再來針對多類別的問題教了兩種方法，都是應用二元分類來達成多類別分類，第一種OVA是把所有資料分成兩個類別，一個是要分出來的類別，另一個是把其他資料視為同一類別；第二種OAO是單純就看兩種不同類別來作兩兩比較，而這兩種多類別方法都是簡單而且常被拿來使用的分類手法！</p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/11_handout.pdf\">Machine Learning Foundation 11</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習基石(Machine Learning Foundation)第十二講筆記","url":"/2017/10/02/Machine-Learning-Foundation-12/","content":"<p>上一堂講到三種不同的線性模型都可以用在二元分類，並且還可以透過二元分類來達成多類別分類，這一堂課會教到該如何將線性模型延伸轉換成非線性模型。</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/LinearHypotheses.JPG\" class=\"\" width=\"500\">\n\n<p>前面都講到線性模型，線性模型可以很容易的計算出線性分數，再結合不同的轉換作輸出，線性模型好處在於VC維度是可以很容易的受到控制的，所以確保作好Ein，Eout就可以表現的好。但是如果遇到像右邊比較複雜的資料，可能就沒辦法使用線性模型達成，勢必需要結合其它手法來突破限制。</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/CircularSeparable.JPG\" class=\"\" width=\"500\">\n\n<p>再重新看一次這組比較複雜的資料，可以發現他雖然沒辦法線性分割，但似乎是「圓圈」可分的問題，也就是在圓圈內和圓圈外是不同的類別。那該如何把本來線性可分的問題轉成圓圈可分，再透過前面教到的演算法來解決呢？</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/CircularSeparable2.JPG\" class=\"\" width=\"500\">\n\n<p>接著我們先把原本的圓圈作符號的替換，可以整理成像之前一樣的向量內積式。他的意義在於，如果本來可以這個問題在X維度上用圓圈分出兩種類別，那麼在Z維度上將可以用直接用直線來分出兩種類別，即線性可分問題，這樣的轉換又稱為特徵轉換。所以我們知道問題在X維是圓圈可分，轉成在Z維是線性可分，但是相反來說的是不是在Z維是線性可分，在X維就是圓圈可分呢？</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/LinearHypothesesZSpace.JPG\" class=\"\" width=\"500\">\n\n<p>在Z維是線性可分，但是在X維其實不一定會是圓圈。因為在二次曲線可能性不止是圓圈，還有可能是橢圓或是雙曲線，甚至就算是圓圈還可能分成圓內和圓外，那該如何找到所有二次曲線的可能性呢？</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/GeneralQuadraticHypothesisSet.JPG\" class=\"\" width=\"500\">\n\n<p>我們可以列出所有能表式二次曲線的項都列出來(包含常數、一次項和二次項)，所以在Z維的perceptron就會對應到在X維的某個二次曲線可能的分類方式，當然也有可能會退化成一次方程式。</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/GoodQuadraticHypothesis.JPG\" class=\"\" width=\"500\">\n\n<p>所以到現在可以發現，如果能夠在Z維找到一個好的perceptron，就可以在X維找到一個可分割類別的二次曲線。之前學習的內容都是在X維裡面使用x和y來找到好的perceptron，現在要在Z維找到好的perceptron，自然就需要使用在Z維上的資料，再使用學習到的二元分類方法來處理。</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/NonlinearModel.JPG\" class=\"\" width=\"500\">\n\n<p>首先可以透過一個函式Φ來將X維資料轉成Z維，再使用演算法來找出一個線性分割的perceptron。於是我們就可以把X維的資料，把它丟到Z維看看轉換到Z維的這筆資料究竟是什麼類別，就可以知道這筆資料該分成什麼類別。所以當我們把原本學到的方法透過特徵轉換到二次式甚至是多項式，可大大延伸演算法的應用範圍！</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/FeatureTransform.JPG\" class=\"\" width=\"500\">\n\n<p>比如說本來維度很高的手寫辨識資料，可以應用特徵轉換建立intensity和symmetry組成的兩維問題。</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/ComputationStoragePrice.JPG\" class=\"\" width=\"500\">\n\n<p>這樣的特徵轉換好看起很多好處，但是究竟會有什麼壞處呢？前面只講到兩次項而已，如果今天要把特徵轉成Q次項的話，他的複雜度將會是O(Q^d)，其中d是除常數項以外的項次，Q是要作的Q次項轉換。所以可以發現，透過這個轉換會讓計算還有儲存都多花費額外的力氣，可能是很困難的。</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/ModelComplexityPrice.JPG\" class=\"\" width=\"500\">\n\n<p>除了計算和儲存的困難，在VC維也會因為Q變大而變大，造成模型的複雜度變高。</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/GeneralizationIssue.JPG\" class=\"\" width=\"500\">\n\n<p>上面給出了一組資料且有兩種分類結果，雖然右邊的Ein為0(即所有資料都可以分對)，但是相比起左邊的分類結果反而讓人比較喜歡。雖然左邊的分類結果有些點是分錯的Ein不是0，但是線性的模型的泛化能力會比較好，雖然特徵轉換的維度比較低，Ein比較大，但是確有可能得到一個比較好的Eout；右邊的模型其特徵轉換的維度比較高，雖然讓Ein可以作的很好，但有可能得到較差的Eout，這就是機器學習上特徵還有模型選擇的trade-off！</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/VisualChoices.JPG\" class=\"\" width=\"500\">\n\n<p>那到底該選擇哪個維度的轉換才是最好的呢？也許就先把資料作視覺化看看資料長什麼樣子就能決定了，像是正圓圈只要作二次曲線轉換就可以了。看似好像一下子就可以找到特徵轉換的維度來達到好的學習效果，但是這樣的過程其實包含了過多的人為介入，而這樣的介入也許可以得到不錯的學習結果與好的Ein，但是背後隱含了機器會受到你的主觀想法和偏見影響，也容易讓你對學習的結果有過度的樂觀。所以在機器學習中要非常的小心，也許我們可以先偷看資料，然後用腦袋解析一次來找到最好的維度轉換與好的Ein，但是這個學習的結果在拿來應用時卻可能會得到不好的效果。</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/PolynomialTransformRevisited.JPG\" class=\"\" width=\"500\">\n\n<p>在多維度的轉換過程中，當轉換成Q維時，其中也包含了Q-1維的項次，Q-1維能作到的事Q維也能作到，Q-1維就等同於在Q維中某些項次為0，這其實是一個巢狀的涵蓋蓋念。</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/StructuredHypothesisSets.JPG\" class=\"\" width=\"500\">\n\n<p>維度越高，可調整的自由變數就越多，所以VC維也就越多；又因為可調整的自由變數越多，所以也就越有可能找到更好的結果來產生更好的Ein。再來就可以畫出之前也看過的圖，Ein會隨著VC維而下降，而模型複雜度則會隨著VC維而上升，其中我們最在乎的Eout會先下降再上升。所以如果一開始就使用很高維度的特徵轉換是會得到好的Ein，但也會付出模型複雜度的代價，造成Eout效果不好。</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/LinearModelFirs.JPG\" class=\"\" width=\"500\">\n\n<p>安全的作法是先從低維轉換開始，再持續往右邊移動，直接找到好的Ein與好的Eout。雖然線性分類也許可以作到的是有限的，但是線性的泛化能力比較好，反而最後可以作到的事情是比較多的。</p>\n<img src=\"/2017/10/02/Machine-Learning-Foundation-12/Summary.JPG\" class=\"\" width=\"500\">\n\n<p>這一堂課教的是把原本線性的模型作特徵轉換變成非線性，並說明其中轉換的流程該如何作，但要特別注意的是維度的轉換是會付出計算、儲存和模型複雜度代價的，在選擇維度轉換記得要從簡單的開始，慢慢的往高維度找到最好的模型。</p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/12_handout.pdf\">Machine Learning Foundation 12</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習基石(Machine Learning Foundation)第十四講筆記","url":"/2017/10/18/Machine-Learning-Foundation-14/","content":"<p>上一堂課講到overfitting現象，他會在使用過高的模型複雜度、雜訊過多或是資料太少時發生。上次有提到可以使用Data Clean/Purning和Data Hinting從資料面下手解決，這堂課會提到regularized手法來避免overfitting。</p>\n<img src=\"/2017/10/18/Machine-Learning-Foundation-14/Regularization.JPG\" class=\"\" width=\"500\">\n\n<p>Overfit現象就是Target和Fit兩者相差太多，雖然可以將樣本學習的很好使Ein很小，但是卻造成泛化能力很差Eout過高，就如同右邊這張圖。regularized目標則是希望可以把Fit曲線能夠更接近Target，所以regularized可以視成一個從高次方項走向底次方項的手法，有很多的解都可以通過樣本點，但是究竟哪一組是最好的，就是regularized要作的。那該怎麼從高次多項走回低次多項式呢？</p>\n<img src=\"/2017/10/18/Machine-Learning-Foundation-14/RegressionWithConstraint.JPG\" class=\"\" width=\"500\">\n\n<p>要從高次多項式走回低次多項式，其實就可以視成低次多項式是高次多項式加上constrain，即如果把十次多項式中超過三次的項權重都設成0，那麼就可以降回二次多項式了。在求最佳化的過程也是，如果今天要求二次多項式的最小值Ein，就可以使用加上constrain的十次多項式來求最小值。</p>\n<img src=\"/2017/10/18/Machine-Learning-Foundation-14/RegressionWithLooserConstraint.JPG\" class=\"\" width=\"500\">\n\n<p>進一步的可以再延伸出，如果我並不是把超過三次項的權重設成0，而是只要其中有8項設權重設成0，就可以放寬這個constrain，讓regression可以更加的有彈性。這個放寬限制條件的二項式會比本來的二項式可以變化的項次更多，但也不像十次多項式這麼複雜。所以成求Ein時，只要確保權重為0的項次小於3個就可以了，但是這種離散的限制就像PLA一樣不容易求解，是NP-hard問題。</p>\n<img src=\"/2017/10/18/Machine-Learning-Foundation-14/RegressionWithSofterConstraint.JPG\" class=\"\" width=\"500\">\n\n<p>原本的條件是算權重不是0的項次要小於3，我們可以把他轉換成將每個項次權重平均相加要小於上限制C，這樣就可以轉成比較好解的問題，而且權重越接近0的取平均會越小。C如果設定的越大，就會越接近十次多項式結果，且所有比較小的C的項次組合都會被比較大的C的項次組合包含。這個H(C)又可以被稱為regularized hypothesis，即加上限制條件的hypothesis，而透過規則化的hypothesis set裡所找到的最佳hypothesis又稱為W(REG)</p>\n<img src=\"/2017/10/18/Machine-Learning-Foundation-14/TheLagrangeMultiplier.JPG\" class=\"\" width=\"500\">\n\n<p>再來可以和之前一樣把式子轉換成矩陣的表示方法來解最佳化問題。原本我們可以透過走梯度反方向到W(lin)這個最佳解，但是現在加上了限制式，這個限制在幾何上是一個圓圈，找到前面所提到的規則化hpothesis最佳解W(REG)的話，就得同時往梯度反方向走而且不離開圓邊。又因為往圓的法向量(紅色向量)走就會離開圓邊，所以只能往垂直於法向量的分量走(綠色向量)，當持續走到梯度反方向要是和圓的法向量平行的話，就代表不能走了，即為找到最佳解。我們可以把兩個平行向量的比值設成2λ/N。</p>\n<img src=\"/2017/10/18/Machine-Learning-Foundation-14/AugmentedErr.JPG\" class=\"\" width=\"500\">\n\n<p>再來可以把求梯度等於0轉換回求最小值的式子，即為Ein加上一組regularizer又可稱為augmented error Eaug(w)，如果預先先指定λ值就可以很容易的解這個式子。</p>\n<img src=\"/2017/10/18/Machine-Learning-Foundation-14/Result.JPG\" class=\"\" width=\"500\">\n\n<p>所以只要加上一點regularizer就可以對模型結果作出適當調整，今天如果λ設成0的話就等同沒有regularized即為overfitting，λ設的太大則會造成underfitting，加上regularizer就會有類似懲罰的效果。這種的規則化方法又稱為weight-decay regularization，即把權重最小的規則化方法。而且這個規則化方法可以應用到linear regresion、logistic regression甚至是其他不同的transform。</p>\n<img src=\"/2017/10/18/Machine-Learning-Foundation-14/RegularizationAndVC.JPG\" class=\"\" width=\"500\">\n\n<p>但究竟這個augmented error和之前學到的VC有什麼相關性呢？用求augmented error的方法來解本來不好解的constrain Ein，這裡對應到的VC保證為Eout會小於En加上一個constrain H(C)，所以作好Eaug就能把Eout間接的也作好。</p>\n<img src=\"/2017/10/18/Machine-Learning-Foundation-14/AnotherView.JPG\" class=\"\" width=\"500\">\n\n<p>Augmented error和VC bound其實相同的地方在於都是在求複雜度，augmented error求的是單一個hypothesis的複雜度，而VC則是在求整個hypothesis集合的複雜度。這個augmented error如果可以表現更好，那麼Eaug可能是一個比Ein更好的代理人可以幫我們作到好的Eout。</p>\n<img src=\"/2017/10/18/Machine-Learning-Foundation-14/EffectiveVCDimension.JPG\" class=\"\" width=\"500\">\n\n<p>其實使用regulization付出的VC dimension會比原本還要小，因為在實際上有N個特徵維度下，最終透過regulization將不會使用到那麼多的維度。這裡相比原本的d(VC)，可以稱為d(EFF)，其付出的維度會比本來的d(VC)還小。</p>\n<img src=\"/2017/10/18/Machine-Learning-Foundation-14/GeneralRegularizers.JPG\" class=\"\" width=\"500\">\n\n<p>那到底該使用什麼樣的regularizer呢？今天如果在知道target特性的情況下，可以針對target特性來設計regularizer，比如說如果想要一個比較接近偶函數的函數話，就針對奇數次方讓他變小。又或者在選出一個比較能夠說服我們的regularizer，像是比較平滑或是簡單的regularizer，因為overfitting是noise造成的，noise就會造成不平滑，像是使用L1 regularizer。或者也可以找一個好使用好最佳化的regularizer，像是前面說到的weight-decay regularizer，又被稱為L2 regularizer。如果找到不好的regularizer，那就把λ設定成0就等同於拿掉regularizer的效果。</p>\n<img src=\"/2017/10/18/Machine-Learning-Foundation-14/L2AndL1.JPG\" class=\"\" width=\"500\">\n\n<p>L2 Regularizer最大的好處就是他很好微分求最佳值，而L1在微分求最佳值的部份比較困難，且L1在求最佳值時很常發生在頂點上，意義就是某一些的權重w會是0，所以L1 Regularizer又被稱為sparse regularizer。透過L1就可以在高維度空間下(例如1000維)，找到一些w非0的項次(可能只有5維)，所以在最後的預測只要算非0項速度會比較快。</p>\n<img src=\"/2017/10/18/Machine-Learning-Foundation-14/OptimalLambda.JPG\" class=\"\" width=\"500\">\n\n<p>那λ該怎麼選擇呢？很明顯的可以看到不管是stochastic noise或是deterministic noise，只要noise越大λ就要越大。下一講將會開始說明在使用規則化手法時，該如何有效的使用最佳的λ。</p>\n<img src=\"/2017/10/18/Machine-Learning-Foundation-14/Summary.JPG\" class=\"\" width=\"500\">\n\n<p>總結來看，這堂課說明規則化就是在原本的hypothesis加上一個條件，並轉成一個Augmented Error，因為作了規則化所以有些維度就不會被使用到，因此VC維度就會下降成d(EFF)，而使用regularizer的使用方法可以針對target特性，或是使用容易說服自己的regularizer，還有也可以使用好最佳化的regularizer。</p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/14_handout.pdf\">Machine Learning Foundation 14</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習基石(Machine Learning Foundation)第十三講筆記","url":"/2017/10/13/Machine-Learning-Foundation-13/","content":"<p>上一講提到可以使用非線性轉換的方法，將線性的模型轉換成非線性，雖然可以解決更複雜的問題，但也伴隨著模型複雜度提高的代價。這一講將提到過度適合(Overfitting)現象所造成的泛化能力缺陷。</p>\n<img src=\"/2017/10/13/Machine-Learning-Foundation-13/BadGeneralization.JPG\" class=\"\" width=\"500\">\n\n<p>假設今天有一個目標的函式是二次函式，但我們使用的四次函式來找到通過所有點的答案使得Ein為0，但這個四次函式卻和目標的二次函式差距很大造成Eout很大。這樣就會讓這個四次函式只認得樣本資料，而這種VC維度很高所付出的代價就是模型會失去舉一反三的能力，也就是泛化能力很差。</p>\n<img src=\"/2017/10/13/Machine-Learning-Foundation-13/Overfitting.JPG\" class=\"\" width=\"500\">\n\n<p>這裡帶出學習會出現的兩個問題，一個是過度適合(Overfitting)，即Ein的fitting作的很好，但是作過度了造成Eout效果不好；一個是低度適合(Underfitting)，即Ein的fitting作的不夠好。Underfitting可以透過增加樣本資料或是使用較複雜的模型就可以解決，但是Overfitting反而是一個比較難解決的問題。</p>\n<img src=\"/2017/10/13/Machine-Learning-Foundation-13/CauseofOverfitting.JPG\" class=\"\" width=\"500\">\n\n<p>發生Overfitting會有幾種原因，第一種是使用了過多的VC維，也就是使用了過於複雜的機器學習模型，像是對二次函式問題使用了四次函式來解；第二種可能性是雜訊太多，造成錯誤的學習；第三種是資料量不足，如果資料量不足可能沒有辦法學習出接近目標函式的結果。尤其當資料量不夠且雜訊又多，就很容易造成Overfitting讓模型最終失去泛化能力</p>\n<img src=\"/2017/10/13/Machine-Learning-Foundation-13/CaseStudy.JPG\" class=\"\" width=\"500\">\n\n<p>假設現在有兩個目標函式，一個是十次多項式加上雜訊，一個是五十次多項式但是沒有雜訊。今天分別使用二次多項式和十次多項式來比較兩個問題的學習結果，會發現十次多項式都發生Overfitting，在Ein都作的比較好，但是Eout都作不好。甚至是當我們已經知道目標函式是十次多項式的情況，使用十次多項式的結果也不一定會贏過二次多項式。</p>\n<img src=\"/2017/10/13/Machine-Learning-Foundation-13/LearningCurve.JPG\" class=\"\" width=\"500\">\n\n<p>用學習曲線來看會發現，當樣本數量不夠的時候，十次多項式Ein和Eout差距會非常大，所以如果資料量不足就不應該免強使用較複雜的方法，反而使用二次多項式還能夠學習出比較好的結果。</p>\n<img src=\"/2017/10/13/Machine-Learning-Foundation-13/NoNoise.JPG\" class=\"\" width=\"500\">\n\n<p>那如果都沒有雜訊的情況下也會是二次多項式的效果比較好，因為當目標函式很複雜時，也會造成類似雜訊的效果，如果二次多項式和十次多項式都作不好，使用二次多項式的泛化效果可能會比較好。</p>\n<img src=\"/2017/10/13/Machine-Learning-Foundation-13/DetailExperiment.JPG\" class=\"\" width=\"500\">\n\n<p>什麼時候要注意overfitting會發生呢？可以分成模型複雜程度Qf和雜訊程度\u000f\u000fσ^2來探討，再來會討論兩者和資料量N之間的關係。<img src=\"/2017/10/13/Machine-Learning-Foundation-13/TheOverfitMeasure.JPG\" class=\"\" width=\"500\">延續之前的二次和十次多項式的例子，再來會使用Eout(g10) - Eout(g2)來衡量overfit的程度，即使用十次和二次多項式的Eout差來衡量。</p>\n<img src=\"/2017/10/13/Machine-Learning-Foundation-13/Result.JPG\" class=\"\" width=\"500\">\n\n<p>在固定模型複雜度之下，只要資料量不夠而且雜訊程度越高，就越容易造成overfit；但在固定雜訊程度看模型複雜度的影響，大部份也是發生在資料量少且目標複雜度高會造成overfit。</p>\n<img src=\"/2017/10/13/Machine-Learning-Foundation-13/NoiseAndSize.JPG\" class=\"\" width=\"500\">\n\n<p>兩者最主要的差異在於，雜訊是stochastic noise，即隨機產生的，但是目標函式的複雜度是deterministic noice，是固定可以計算出來的。總結來說在四種情況下會發生overfit，第一個是資料的量過小，第二個是stochastic noise太高的時候，第三個是deterministic noise太高的時候，第四個則是VC維度太高的時候。所以overfit是很容易發生的。</p>\n<img src=\"/2017/10/13/Machine-Learning-Foundation-13/DeterministicNoise.JPG\" class=\"\" width=\"500\">\n\n<p>所以到底為什麼今天的目標函式太過複雜的情況下和隨機雜訊是類似的呢？假設今天目標函式太過複雜，以至於無法使用任何的hypothesis描述，這中間的差距就是我們說的deterministic noise，這並不是一個隨機發生的雜訊。所以deterministic noise會取決於hypothesis，而且在給定相同x之下會有相同的deterministic noise。</p>\n<img src=\"/2017/10/13/Machine-Learning-Foundation-13/HandleOverfit.JPG\" class=\"\" width=\"500\">\n\n<p>如果有這麼多的原因會造成overfit，那該怎麼解決呢？在模型部份，可以先使用比較簡單的模型開始，避免一開始就用過複雜的模型；在資料部份，可以將雜訊資料作data cleaning/pruning處理，或是收集更多的資料與使用data hinting產生虛擬資料來提供更多額外的資料；另外還可以透過regularization對模型產生懲罰效果，或是透過validation來隨時看學習的狀況。</p>\n<img src=\"/2017/10/13/Machine-Learning-Foundation-13/DataClean.JPG\" class=\"\" width=\"500\">\n\n<p>在Data Cleaning/Pruning的部份，Data Clean是指把已經確定是錯誤標記的資料，標記到正確的類別。Data Pruning則是直接將錯誤的雜訊資料直接從資料集去除掉。兩個資料的處理方法都不難，難度反而會在於該如何判斷資料是有問題的雜訊資料。</p>\n<img src=\"/2017/10/13/Machine-Learning-Foundation-13/DataHinting.JPG\" class=\"\" width=\"500\">\n\n<p>在Data Hinging部份，以圖像的數字辨識來說，就是把每個字作簡單的旋轉來當作新的虛擬資料並加進來學習。這個方法很常用在現今在作圖象辨識時，對圖像作扭曲或是轉換來增加學習樣本數量。</p>\n<img src=\"/2017/10/13/Machine-Learning-Foundation-13/Summary.JPG\" class=\"\" width=\"500\">\n\n<p>總結來說，這堂課教到了把Ein作好但是Eout作不好是overfitting現象，而且overfitting是非常容易發生的。不只是雜訊會造成overfitting，當目標函式過於複雜時，也是另一種雜訊。在處理overfitting的部份，這堂課簡單提到了data cleaning/pruning和data hinting，下一堂會再進一步教到如何使用regularization來避免overfitting現象。</p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/13_handout.pdf\">Machine Learning Foundation 13</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習基石(Machine Learning Foundation)第十五講筆記","url":"/2017/10/25/Machine-Learning-Foundation-15/","content":"<p>上一堂課講到為了避免overfitting，可以使用regularization的技巧，把一個regularizer加在Ein上面，轉而求Augmented Error反而可以有效的解決模型複雜度太高的問題。這一堂課會講到該如何使用Validation的手法幫助選擇機器學習裡面不同的參數。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/ManyModel.JPG\" class=\"\" width=\"500\">\n\n<p>在訓練一個機器學習模型，其中會遇到很多的選擇，包含使用哪些演算法、使用多少資料、要使用什麼非線性轉換方法，甚至是要使用哪一種regularizer。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/ModelSelection.JPG\" class=\"\" width=\"500\">\n\n<p>Machine Learning裡面最實務的問題，就是如何作出好的選擇讓最後Eout可以作到最好，如果用視覺化的方法來作選擇，反而會受到自己的主觀影響，那到底該怎麼作選擇呢？</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/ModelSelectionByEin.JPG\" class=\"\" width=\"500\">\n\n<p>如果使用Ein來作模型選擇的話，就會受到overfitting的影響，越複雜的模型就越容易作好更好的Ein，但是會付出模型複雜度的代價，因為overfitting造成泛化能力變差，Eout反而也作不好。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/ModelSelectionByEtest.JPG\" class=\"\" width=\"500\">\n\n<p>那如果我們可以拿到實際的測試資料，就拿實際的測試資料衡量模型表現就好了，但是實務上可能不會有這樣的實際測試資料。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/EinAndEtest.JPG\" class=\"\" width=\"500\">\n\n<p>如果使用Ein來選模型不可行，而實務上又拿不到實際的資料該怎麼取平衡呢？我們可以使用手上的樣本資料，把一部份切出來當作看不到的測試資料，再拿剩下的資料作學習，並使用切出來的資料衡量模型的效果。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/ValidationSet.JPG\" class=\"\" width=\"500\">\n\n<p>原本的樣本資料D要負擔兩種角色，一個是透過D來求出最好的Ein，然後再把D丟進演算法得到一個Hypothesis G，前面有講到如果這樣的話很可能會造成overfitting問題，所以我們把資料分成train和validation，先使用train總共N-K筆資料練習出好的Ein，並得到Hypothesis G，最後再透過K筆validation資料來驗證G到底好還不好。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/ModelSelectionByEval.JPG\" class=\"\" width=\"500\">\n\n<p>從前面講到的learning curve可以知道，如果使用較多的資料來訓練會得到比較好的結果，所以實務上雖然會使用D(train)來訓練出不同的Hypothesis，然後使用D(val)作評估並選出最好的模型，但是最後在選好模型之後，會再把全部的資料D丟進模型裡作訓練，因為使用全部的資料會比較用部份訓練資料所訓練出來的模型還要好。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/ValidaionPractice.JPG\" class=\"\" width=\"500\">\n\n<p>從驗證資料量和Eout來分析可以看到黑線的Eout會很大，因為在使用複雜的模型之下可能因為overfitting的關係造成Eout作不好；而虛線是用Etest資料，但是這個最佳的測試資料常常是不存在的；紅色是只使用訓練資料建立模型得到的Eout，他會比藍色使用全部資料來訓練所得到的Eout還要來的高。至於為什麼使用訓練資料會比使用Ein還要來的差的原因，是因為當驗證資料量K越大，代表訓練資料就越小，可能產生underfitting使得模型怎麼樣都練習不好。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/Dilemma.JPG\" class=\"\" width=\"500\">\n\n<p>所以我們會遇到不知道該怎麼選擇驗證資料量K的情況，因為如果用了比較大的K，雖然可以確保validation和Eout可以比較接近，但卻會造成訓練資料的Eout和全部資料的Eout差很多；但如果使用小的K雖然可以確保訓練資料的Eout和全部資料的Eout很接近，但是就無法確保validation和Eout到底接不接近。實務上的K常使用N/5。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/K=1.JPG\" class=\"\" width=\"500\">\n\n<p>假設今天設定K=1，並且重複抽出一筆當驗證算出error，再來把error作平均，就可以透過計算這個平均的error來推估Eout。而這種只抽一筆當驗證的方法就稱為leave-one-out的cross validation，因為每次都用N-K筆計算一個g，所以稱為交叉驗證。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/LOO.JPG\" class=\"\" width=\"500\">\n\n<p>在使用leave-one-out cross validation可以有兩種方法，第一種是拿掉一個點，用剩下的點作迴歸，再計算驗證的點到迴歸的距離當作error；第二種是拿掉一個貫，用剩下的點中間取一個常數，再計算驗證的點到常數的距離當作error，透過比較這兩種方法得到的較小的error，就可以選出比較好的模型，也許使用計算迴歸不一定會得到比較小的error，反而使用常數來計算還得到較好的結果。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/GuaranteeOfLOO.JPG\" class=\"\" width=\"500\">\n\n<p>而且leave-one-out cross validation的期望值，確實也可以證明和Eout是相近的，這個部份證明這裡就不多作說明了。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/LOOPractice.JPG\" class=\"\" width=\"500\">\n\n<p>在實務上，如果使用Ein來選擇模型，使用越多的特徵雖然可以得到較小的Ein，但卻也可以造成overfitting，反而和Eout相差很大。但是如果使用leave-one-out cross validation的方法來選模型，確實可以找到一個比較接近Eout的結果，而且絕對對比Ein要來的好很多。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/DisadventageLOO.JPG\" class=\"\" width=\"500\">\n\n<p>使用leave-one-out的最大問題，就是他會花很多的時間在作訓練，如果樣本資料有1000筆，每次都要拿999筆來訓練並重複作一千次才能取到平均的Error，所以在實務上leave-one-out要用來選擇模型可能比較不可行。第二個問題是leave-one-out因為每次只取一個點，所以他的變動程度很高，雖然有取平均，但是他本質上還是一個變動程度比較高的評估方法。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/VFoldCrossValidation.JPG\" class=\"\" width=\"500\">\n\n<p>所以實務上，第一個希望可以降低訓練的次數，比起之前的1000次訓練，可以切成10份的方式，每次取9份作訓練1份作驗證後作平均，這樣就只需要作10次而不需要作到1000次。而且這個方法也可以作到交叉驗證的效果，leave-one-out其實也就是這種方法的極端例子。實務上比較常用的方法是切成十份，又可以稱為10-fold cross validation</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/FinalWord.JPG\" class=\"\" width=\"500\">\n\n<p>使用cross validation在實務上會比只作一次validation當果會比較好也比較穩定，但是前提是在計算上是充許的，因為作k次的交叉驗證作平均需要額外的運算資源；而validation切5份或是10份就可以得到比較好的結果，不需要真的使用到leave-one-out。我們透過validation是可以讓我們選到一個比較好的模型，但是要注意的是，這個validation還是比最終使用測試資料的結果應該還是要樂觀的，只要真正應用在測試資料，你才會知道真的的效果如何。</p>\n<img src=\"/2017/10/25/Machine-Learning-Foundation-15/Summary.JPG\" class=\"\" width=\"500\">\n\n<p>總結來說，這堂課學到使用Ein來選擇模型是很危險的，並談到leave-one-out cross validaion與實務上會使用到的k-fold corss validation可以用來作模型選擇。</p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/15_handout.pdf\">Machine Learning Foundation 15</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習基石(Machine Learning Foundation)第十六講筆記","url":"/2017/11/01/Machine-Learning-Foundation-16/","content":"<p>上一堂提到validation的手法，透過留下用來驗證的資料模擬測試過程，並透過validation結果來選擇該使用什麼樣的模型。這一堂會提到三個在作機器學習時的小技巧。</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/OccamRazor.JPG\" class=\"\" width=\"500\">\n\n<p>Occam’s Razor在機器學習裡面意議是指不要對資料有過多的解釋，就是越簡單的解釋越好。以上面兩張圖的資料來看，左邊的模型符合直覺判斷，是一種比較容易而且 簡單的解釋，那到底什麼樣的模型才叫簡單的模型，而為什麼簡單的模型就比較好呢？</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/SimpleModel.JPG\" class=\"\" width=\"500\">\n\n<p>簡單的hypothesis是指沒有過多的參數就是個簡單的hypothesis，而簡單的模型則是指模型包含了較少的hypothesis就是個簡單的模型，所以簡單在這裡就是指比較小的hypothesis和模型複雜度。而要得到簡單的解釋，除了一開始就使用簡單的模型之外，也可以在之前透過regularization來達成。</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/SimpleIsBetter.JPG\" class=\"\" width=\"500\">\n\n<p>那為什麼簡單的模型就比較好呢？如果今天使用簡單的模型就可以將資料分類正確，那某種程度上也就代表著資料背後的關聯性或是規律性是簡單的；相反的如果使用很複雜的模型，可能就無法知道資料背後的關聯性，因為不管是有關聯性的資料，或是雜訊很多的資料，都可以被複雜的模型分的開。所以如果使用簡單的模型來解釋資料，可以很直覺的看到資料間的顯著性，但是如果使用複雜的模型就辨別不出來，所以建議一開始推薦先使用線性模型。</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/SamlingBias.JPG\" class=\"\" width=\"500\">\n\n<p>第二個技巧會談到樣本的抽樣誤差，這裡用一個美國總統選舉的例子，來說明如果抽樣和要學習的結果不一致，並帶出抽樣誤差問題。如果在抽樣時就發生抽樣誤差，那麼在學習時就會產生偏差的結果，這就是為什麼前面課堂有說到訓練和測試的樣本資料要抽樣自相同的分配，訓練和測試的資料抽自相同的分配，才會得到預期中的學習效果，這就是我們VC中的重要假設。</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/DealingSampleBias.JPG\" class=\"\" width=\"500\">\n\n<p>這裡舉了一個實際上發生過的問題，如果訓練資料和驗證資料有有時間前後依序性(即一個人看過的電影順序)，而非隨機取樣的話，如果透過隨機取樣來建立訓練資料和驗證資料，那麼在學習和驗證中就會有問題。這時候為了讓測試和驗證可以盡可能的接近，例如訓練時可以把時間依序性較後面的權重調高，或是抽比較多時間依序較後面的資料來作驗證。</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/VisualDataSnopping.JPG\" class=\"\" width=\"500\">\n\n<p>再來第三個技巧則是談到之前說到偷看資料的問題，前面有說到如果偷看了資料，可能會把人腦學習到的，或是自己的偏差帶進機器學習裡面。</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/DataSnopping.JPG\" class=\"\" width=\"500\">\n\n<p>偷看資料其實比想像中更容易發生，不是只有用眼睛視覺化的偷看才叫偷看，而是你在處理資料的整個過程中，都算是間接的偷看了資料。如果使用這樣偷看過的資料，都會受到自己的主觀影響。假設今天有一組八年的交易資料，使用前六年當訓練，後兩年當測試。其中在將資料作放縮(Data Scaling)的資料處理過程中，如果不是將前六年作縮放，預測完再還原，而是直接將八年的資料都作放縮的話，就會得到紅色這條上升趨線。這樣將會得到一個太過於樂觀的學習結果，如果將這個結果用來實際投資可能會大大的失準。</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/DataSnopping2.JPG\" class=\"\" width=\"500\">\n\n<p>除了直接的視覺化偷看，或是使用統計分析間接的偷看，其實作在研究上也會發生。例如針對相同問題，不同的論文會都使用更好的模型來作的比以前好，這樣的過程就有點像你的論文間接的偷看了前面論文的結果，這樣就有點像某種程度的overfit了。正是所謂的如果你拷問資料過久了，他就會招拱一個好的hypothesis，但是這個hypothesis應該用測試資料可能效果不保證會好。</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/DealingDataSnopping.JPG\" class=\"\" width=\"500\">\n\n<p>但是完全不偷看其實很不容易，只能盡量的降低這中間的干擾，比如說小心的使用validation，或是把測試資料好好的先收好。所以要時時注意的是，記得要用專業知識來建立模型，而不是先偷看了資料來作決策。另外要時時存著懷疑每次作出來的結果，並懷疑這樣的分析結果是不是有受過汙染。</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/ThreeRelateField.JPG\" class=\"\" width=\"500\">\n\n<p>這堂課教到很多和三有關的東西，第一個是三個和機器學習相關的領域，Data Mining是希望在大量資料中找到找到有用或是重要的關聯，人工智慧是要讓機器作出有智慧的事情(像是自動駕駛)，機器學習可以說是實現人工智慧的方法，統計則是為了去對母體作出推論，所以統計方法也被大量的使用在機器學習上。</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/ThreeTheoreticalBound.JPG\" class=\"\" width=\"500\">\n\n<p>在機器學習背後理論的保證，如果只有一個hypothesis的情況下，Hoeffding可以情供測試驗證的保證，當有多個hypothesis的情況下，Multi-Bin Hoeffding可以提供在有限多個選擇下的保證，如果是無限多個選擇下，VC則是可以提供在無限多個hypothesis是供理論上的保證。</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/ThreeLinearModel.JPG\" class=\"\" width=\"500\">\n\n<p>在機器學習模型部份，PLA/pocket可以提供在線性可分下處理二元分類問題，在衡量上為讓0/1 err最小化，linear regression則是可以處理數值預測問題，在衡量上使用squared err最小化，logistic regression則可以處理軟性二元分類問題，在衡量上使用cross entropy最小化。</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/ThreeKeyTool.JPG\" class=\"\" width=\"500\">\n\n<p>另外還有學到三個重要的技巧，Feature Transform可以將簡單的線性模型轉成高維度的複雜模型，會得到較好的Ein但是也會付出較高的VC代價，Regularization則是相反，透過加上regularizer來讓VC代價變小，但是也會讓Ein變大，Validation則是在沒辦法拿到測試資料的情況下，留下一部份的資料當作驗證資料。</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/ThreeLearningPrinciple.JPG\" class=\"\" width=\"500\">\n\n<p>最後則是這堂課學到的三個注意的地方，要注意簡單模型是好的，而且要注意抽樣的偏差，最後要記得不能提看資料。</p>\n<img src=\"/2017/11/01/Machine-Learning-Foundation-16/ThreeFutureDirection.JPG\" class=\"\" width=\"500\">\n\n<p>再來後面的課程還會上到如何使用不同的轉換方法，以即不同的規則化方法，或是在缺少label的情況下該如何進行訓練。</p>\n<p>總結這堂課程學到了很多機器學習背後的論理依據，而許多不同的機器學習方法將在另一堂機器學習技法課程教授！</p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/16_handout.pdf\">Machine Learning Foundation 16</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習基石(Machine Learning Foundation)第三講筆記","url":"/2017/07/18/Machine-Learning-Foundation-3/","content":"<p>第三講主要在說明機器學習有哪些種類，以及在訓練過程中會用到哪些不同的特徵(Feature)種類。在針對輸出空間y的不同可以有以下幾種不同的學習種類：</p>\n<img src=\"/2017/07/18/Machine-Learning-Foundation-3/Multiclass.JPG\" class=\"\" width=\"500\">\n\n<p>在上一講有看到在平面上透過直線切割出兩種類別，這種二元分類(Binary Classification)是機器學習裡面最常見的問題。但現實上的應用有時並不會侷限在二元分類，常常會遇到多種類別的問題，即多元分類(Multiclass Classification)問題。比如說，可以透過硬幣的大小和重量來區分出美元硬幣，這時候的輸出就是4種類別，如果把類別數量用K來代稱，那麼二元分類可以被視為多元分類的一種特例。這種多元分類問題常用在許多不同的應用，比如說手寫字跡的辨識、圖片中的物件辨識或是email的種類或是重要性辨識。</p>\n<img src=\"/2017/07/18/Machine-Learning-Foundation-3/regression.JPG\" class=\"\" width=\"500\">\n\n<p>如果今天要預測的不是兩元類別或是多元類別，而是一個數字型態的資料，例如透過公司的資料或是新聞的風向來預測股價，或是透過氣候的資料來預測未來的氣溫，這樣的學習也是在統計中常被使用到的迴歸分析。通常透過迴歸分析來預測數值結果也是一種具有label的監督式(Supervised)的學習，因為在學習過程中，會告訴演算法資料x的特徵，和其對應的y數值結果。</p>\n<img src=\"/2017/07/18/Machine-Learning-Foundation-3/structure.JPG\" class=\"\" width=\"500\">\n\n<p>再進一步更複雜的應用中，像是自然語言辨識的領域中，如何對每個字作詞性標注(Part-of-Speech Tag)，他看起似乎像是種多類別的問題(一個詞被分到其中一種詞性)，但是這種詞性標注的問題往往不是把每個詞拆開來輸入，而是會把整個句子輸入來學習分析，因為詞性可能會根據語句而有變化，這個問題尤其是在中文詞性標注更加的明顯。傳統上處理詞性標注可以逶過<a href=\"2017/05/31/Hidden_Markov_Model_HMM/\">隱馬可夫模型(Hidden Markov Model, HMM)</a>)將詞當作觀察現象，詞性當作隱藏狀態，並結合維特比(Viterbi)演算法來作詞性標注。</p>\n<p>在學習的過程中有沒有給予y(輸出標籤)，可以區分成監督式和非監督式學習。</p>\n<p>之前討論到的學習方法是，我們把每個硬幣x的大小和重量，以及這個硬幣的種類y，來學習判斷硬幣的哪個種類，這種有給予y的稱為監督式學習。如果今天不告訴機器每個硬幣的種類y，在只知道硬幣的大小和重量的情況下，把硬幣區分成不同群，稱為非監督式學習。非監督式學習困難的問題常常在於分群的結果不容易被衡量，監督式學習效果的衡量可以簡單的比對機器判斷的g(x)和y是否一致，因此非監督式常習會再透過一些方法像是Elbow Method或是silhouette analysis來判斷分群的品質。非監督式學習除了群聚分析外，像是密度分析(Density Estimation)和臨群偵測(Outlier Detection)也都是非監督式學習的範疇。</p>\n<img src=\"/2017/07/18/Machine-Learning-Foundation-3/semisupervised.JPG\" class=\"\" width=\"500\">\n\n<p>介於監督式和非監督式學習中間稱為半監督式(Semi-supervised)，半監督式會先使用一部份已經有標注好標籤的資料作監督式學習，再使用沒有標注的資料來讓機器可以學的更好。其中常用在大量的資料無法將所有的資料都給予標籤，因為標注資料的成本是很高的，所以像是影像辯識就會透過半監督式方法來完成學習。</p>\n<img src=\"/2017/07/18/Machine-Learning-Foundation-3/reinforcement.JPG\" class=\"\" width=\"500\">\n\n<p>增強學習(Reinforcement Learning)會透過獎勵的方式告訴機器什麼樣的情況是好或是不好，例如在廣告的投放上當使用者點擊某種類的廣告會影響廣告系統推薦給使用者的廣告內容。 </p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/03_handout.pdf\">Machine Learning Foundation 03</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習基石(Machine Learning Foundation)第二講筆記","url":"/2017/07/12/Machine-Learning-Foundation-2/","content":"<p>第二講的內容主要在說明如何透過機器學習來回答兩元問題。上一講有提到機器學習會透過一個演算法A，並透過資料D和假說Hyposis H集合，透過選擇一個假說來學習到函式g。以上一講的案例來說，我們會透過函式g來決定要不要發信用卡。</p>\n<img src=\"/2017/07/12/Machine-Learning-Foundation-2/Perceptron.jpg\" class=\"\" width=\"500\">\n\n<p>我們可以簡單的透過計算分數的方式來建立一個簡單的機器學習方法。首先可以把每位使用者的資料建立一筆特徵向量當作輸入資料，而每個維度還會有重要性的權重(例如年薪的權重可能會比性別的權重還來的高)，最後把每個使用者依據加總的分數，和設定的門檻值(threshold)比較，如果高過門檻值就發卡，沒高過就不發卡，這樣的模型h就是一個簡單的Perceptron(感知器)。</p>\n<p>其實在情感分析(Sentiment Analysis)上，以前也常用這種計算分數的方式來判斷文本屬於正面(Postive)或是(Nagtive)。當我們手上有一個情感詞典(定義哪些字是正面，哪些字是負面)，在拿到一篇文章的時候，就可以加總正面詞(+1)和負面詞(-1)來算出文章的情感分數，再搭配門檻值來判斷文章是屬於正面還是負面，甚至是正負面的程度。(不同字詞可以有不同程度的權重，沒有被情感詞典定義的詞當作0分)</p>\n<img src=\"/2017/07/12/Machine-Learning-Foundation-2/Perceptron2.jpg\" class=\"\" width=\"500\">\n\n<p>這個用來判斷要不要發信用卡的模型h，在二維的平面上會呈現為一條直線(平面上的每一點就是一筆資料x，每一筆資料的形狀則是指的label)，在高維度的空間會是一個平面。這條直接的一邊是其中一種label(O)，跨過線的另一邊則是另一種label(X)，這樣的線性分類器即可以用來分類兩元問題。</p>\n<img src=\"/2017/07/12/Machine-Learning-Foundation-2/PLA.jpg\" class=\"\" width=\"500\">\n\n<p>那究竟平面上面的這條線該怎麼切才是最好的呢？可以透過Perceptron Learning Algorithm(PLA)來學習出最好的線性分類器。當平面上的線如果切的不夠好時，透過會旋轉這條線來讓切線更完美。當正的label被分到負的label時，代表w和x的角度太大，可以透過向量相加來讓角度變小；當負的label被分到正的label時，代表w和x的角度太小，可以透過向量相減來讓角度變大。就這樣一直轉到所有的正的label和負的label都分到正確的類別沒有任何分錯，就可以得到一個最佳的切線，這個演算法稱為PLA。</p>\n<img src=\"/2017/07/12/Machine-Learning-Foundation-2/LinearSeparability.jpg\" class=\"\" width=\"500\">\n\n<p>PLA既然要在平面上找到一條切線，那勢必他就必須要是線性可分的問題，像是上圖最左邊就是一個線性可分的問題，右邊兩張則是線性不可分，即不管怎麼旋轉這條切線都沒辦法把兩種類別各自分到對的地方。如果稍有瞭解支援向量機(Support Vector Machine, SVM)的人大概會想到，如果使用SVM的話就可以解決線性不可分的問題，因為SVM主要是也在空間裡找到線性可分的超平面來切分空間，如果遇到第二種線性不可分的情況，最簡單可以透過調整懲罰參數C來忽略一些無法分到正確類別的資料(也許是雜訊)。至於遇到第三種情況的話，則可以調整核函式Kernel Function來將於N維線性不可分的資料於較高的維度M找到線性可分的超平面。</p>\n<img src=\"/2017/07/12/Machine-Learning-Foundation-2/PocketAlgo.jpg\" class=\"\" width=\"500\">\n\n<p>回到PLA，現實上絕對沒有這麼好的情況可以讓你都有線性可分，也許只有稍微有點雜訊，就會讓問題變成線性不可分。這邊會用到演算法稱為口袋演算法(pocket algorithm)，即是在PLA的修正學習過程中，如果找到一個比較好的線(即分錯最少)，我們就把這條線放到口袋裡面，當遇到下一條比我們口袋裡這條線更好的線，就再換成新的線，一直到執到覺得應該差不多就停下來。所以當我們是線性可分，PLA可以幫助找到好的解答；但如果不是線性可分，透過變形的PLA確實可以找到一個還不錯的解答。</p>\n<p>參考資料: <a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/02_handout.pdf\">Machine Learning Foundation 02</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習基石(Machine Learning Foundation)第四講筆記","url":"/2017/07/27/Machine-Learning-Foundation-4/","content":"<p>這一講的學習重點主要是在如何討論學習到底是不是可行的，並進一步推導證明機器是真的可以「學習」的。</p>\n<img src=\"/2017/07/27/Machine-Learning-Foundation-4/ControversialAnswer.JPG\" class=\"\" width=\"500\">\n\n<p>機器會不會其實是沒辦法學習的？我們可以先看講義上的圖形，上半部的圖形屬於-1，下半部的圖形屬於+1，那麼給了f上方右邊的圖，他究竟是屬於+1還是-1呢？如果我們用黑色區域是不是對稱來判斷，那麼這張圖會是+1；但如果我們用左上角的格子是否為黑色，那邊這張圖會是-1。這裡會發現如果我們用不同的規則就可能得到不同的答案，看起來好像真的沒辦法讓機器真的「學習」一個正確的答案。</p>\n<img src=\"/2017/07/27/Machine-Learning-Foundation-4/NoFreeLunch.JPG\" class=\"\" width=\"500\">\n\n<p>用一個比較數學的例子來看，假設今天有一個函式f，輸入是3個bit，輸出是o或是x。再來我們透過機器學習演算法學到g函式，並確保這個g函式在5筆資料D都能和f得到一樣的答案(即f和g結果相同)。所以我們確保了g和f(甚至是講義上的8個f)在D得到相同答案，但是除了D之外剩下的3種答案，g只會有一種結果。這會有什麼的影響呢？比如說當g在剩下3筆得到XOX，那麼他會和f6相同，可是我們今天是要告訴你正確的f其實是除了f6以外的函式，那麼似乎g和f答案又錯了，看起來機器好像真的沒辦法「學習」到一個正確答案。這又稱為no free lunch，如果沒有對機器學習問題加上一些限制，即我們只是單純給機器資料學習，事實上是沒辦法讓機器學出一個正確的答案的。</p>\n<img src=\"/2017/07/27/Machine-Learning-Foundation-4/InferrProbability.JPG\" class=\"\" width=\"500\">\n\n<p>這裡舉一個推論未知的方法，比如說在一個瓶子中有綠色彈珠和橘色彈珠，如果今天沒有辦法完全數完瓶內所有的彈珠，那麼該如何去推論橘色彈珠的比例呢？我們可以透過統計手法利用取樣(樣本)的比例來推論瓶內橘色彈珠(母體)的比例。假設瓶內橘色彈珠的比例是μ，綠色是1-μ，取樣出橘色彈珠的比例是ν，綠色是1-ν，是否可以用這個ν來推論μ呢？照理說ν可能沒辦法完全的推論μ(明明有橘色彈珠，但是每一次運氣不好都抽到綠色)，但是在一定的機率下，ν應該是有辦法推論μ的，在數學上可用Hoeffding’s Inequality來解釋</p>\n<img src=\"/2017/07/27/Machine-Learning-Foundation-4/HoeffdingInequality.JPG\" class=\"\" width=\"500\">\n\n<p>透過Hoeffding’s Inequality可以解釋，如果今天抽出彈珠(N)的數量越大的話，ν和μ之間差很遠的機率(ε)就會很小，也就是說如果可以取出數量夠大的樣本的話，就可以讓「壞事」(ν和μ差很多)發生的機率變小，我們可以說ν和μ大概差不多會是對的(即probably approximately correct, PAC)</p>\n<img src=\"/2017/07/27/Machine-Learning-Foundation-4/ConnectLearning.JPG\" class=\"\" width=\"500\">\n\n<p>那用這個抽彈珠的例子到底和學習會有什麼關係？當把抽彈珠轉成學習的問題，未知橘色彈珠的機率μ可視為未知的f，所有抽出來的彈珠就是每筆的資料，其中橘色彈珠可視為h(x)≠f(x)，即hypothesis h是錯的，綠色彈珠可視為h(x)=f(x)，即hypothesis h是對的。所以如果我們在獨立的抽出彈珠時，就可知道來誰論h和f不一樣的機率到底是多少。</p>\n<img src=\"/2017/07/27/Machine-Learning-Foundation-4/AddComponent.JPG\" class=\"\" width=\"500\">\n\n<p>所以把前面錯誤推估的部份加入進去機器學習的流程中。首先我有一個機率在瓶子中取樣產生了資料D，在判斷h和f是不是一樣時，其中這個h就是Hypothesis集合中的其中一個</p>\n<img src=\"/2017/07/27/Machine-Learning-Foundation-4/FormalGuarantee.JPG\" class=\"\" width=\"500\">\n\n<p>再來就可以透過手上確實知道的資料D來說h和f是否相同，也就是透過Ein(取樣的資料Error)來推論Eout(實際的瓶子的資料Error)，使用Hoeffding’s Inequality就可以證明當N夠大時，Ein和Eout就會差不多是相同的。</p>\n<img src=\"/2017/07/27/Machine-Learning-Foundation-4/Verification.JPG\" class=\"\" width=\"500\">\n\n<p>但這樣的證明充其量其能說是驗證而已，就是這個h目前還沒有辦法像是PLA一樣丟不同資料產生不同的h，但是我們可以證明這個h是不是使用資料D能夠有有用的推論f，即驗證選出h的表現是好的還是不好的。</p>\n<img src=\"/2017/07/27/Machine-Learning-Foundation-4/CoinGame.JPG\" class=\"\" width=\"500\">\n\n<p>目前已經可以驗證相同h之下的表現好還是不好，但是今天當我們有了選擇時(即在多個h裡面作選擇)，我們可能就會有偏見的選出一個瓶子都是綠色彈珠的結果，但事實上可能只是剛好這個瓶子都「碰巧」的抽出了綠色彈珠，就像擲銅板一樣，不論這枚銅板多麼公正，都會有可能出現每次都正面的情況。前面講到Hoeffding告訴我們的是ν和μ之間差異很大的這種「不好」的事情機率應該是很小的，但是當我們有選擇的時候，這種「不好」的取樣卻會造成Ein和Eout差距變大。</p>\n<img src=\"/2017/07/27/Machine-Learning-Foundation-4/BadData.JPG\" class=\"\" width=\"500\">\n\n<p>如果演算法遇到不好的資料(Ein和Eout差很遠)，就會得到不好的結果。Hoeffding告訴我們的是每一個h不好的情況是很小的，但是在演算法有自由選擇h的情況下，那麼不好資料發生的機率是多少呢？</p>\n<img src=\"/2017/07/27/Machine-Learning-Foundation-4/BADDataBound.JPG\" class=\"\" width=\"500\">\n\n<p>假設有M總不同的h，那麼不好資料發生的機率，就會等於每一個h發生不好機率的總合(Union Bound)。所以如果演算法有辦法選出一個最小的Ein(壞事發生的機率是最小的)，就可以表示選出來的Eout會是最小的</p>\n<img src=\"/2017/07/27/Machine-Learning-Foundation-4/StatisticaLearningFlow.JPG\" class=\"\" width=\"500\">\n\n<p>總結來說機器該如何能夠學習呢？只要滿足Hypothesis集合是有限的集合M，且樣本資料N是夠大的，對於任何被演算法選出來的g(其中一個假設h)，就可以推論Eout和Ein是差不多相同的。就是剛提到的，演算法只要選出一個Ein是最小的，就可以保證Eout也是最小的。</p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/04_handout.pdf\">Machine Learning Foundation 04</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習基石(Machine Learning Foundation)第五講筆記","url":"/2017/08/01/Machine-Learning-Foundation-5/","content":"<p>這一講主要在延續前一講的推導，說明無限多個hypothesis到底發生什麼事情。</p>\n\n\n<p>前面有是到如果要讓訓練是可行的，則必需要加上一些假設，首先原本訓練的資料和測試hypothesis的資料都是來自於相同的分配(Distribution)，那麼當hypothesis集合是有限的，且資料數量N夠大的情況下，不論演算法A挑出哪一個函式g，Ein和Eout都會是接近的。在這個情況下，只要挑出趨近於0的Ein，就可以保證Eout也趨近於0，即代表學習是可能的。</p>\n<img src=\"/2017/08/01/Machine-Learning-Foundation-5/TwoCentralQuestions.JPG\" class=\"\" width=\"500\">\n\n<p>再複習一下到目前的學習內容。證明機器學習的過程中，首先會希望得到一個函式g而且和f會很接近，也就是希望Eout(g)會接近於0。但是我們不知道該怎麼去證明Eout會接近於0，於是我們從取樣下手來證明Ein如果趨近於0的話，且Ein和Eout會很接近，那麼Eout也會趨近於0。那麼要讓機器學習可能，其中一個很大的重點是有限的hypothesis集合M，究竟這個M扮演了什麼角色？</p>\n<img src=\"/2017/08/01/Machine-Learning-Foundation-5/TradeOffonM.JPG\" class=\"\" width=\"500\">\n\n<p>這時我們會談到M的trade-off，所謂選擇M的trade-off就是當我們選了比較小的M才能符合Hoeffiding不等式讓壞事發生的機率降低，但這代表可以選擇的hypothesis比較少，也許這樣可能就無法選到一個好的hypothesis來讓Ein可以趨近於0。相反的，如果M越大，雖然選擇的hypothesis變多，但是壞事發生的機率也會上升。所以選擇一個正確而且適當的M對於學習問題是很重要的。</p>\n<img src=\"/2017/08/01/Machine-Learning-Foundation-5/UnionBoundFail.JPG\" class=\"\" width=\"500\">\n\n<p>前面提到如果M是有限的集合，那麼學習才有可能發生，如果是M是無限大的話，壞事發生的機率也就是無限大，機器就沒辦法學到一個好的結果，因為其中的壞事發生的機率，就是M種發生壞事的機率相加。雖然看起來M會無限大，但事實上發生不同壞事資料D可能是一樣的。以PLA為例說明，假設選了兩條非常接近的線(即兩個hypothesis)，其實這兩條線可能對於同一組資料D分出來的結果是一樣的，所以不同的壞事發生可能會有重疊的情況，所以看起來M應該是有限的。</p>\n<img src=\"/2017/08/01/Machine-Learning-Foundation-5/OneInput.JPG\" class=\"\" width=\"500\">\n\n<p>假設平面上只有一個點，每條線都是一個hypothesis，看起來你確實可以在平面上切出無限多條線，可是事實上不管怎麼切都只會有兩種情況，即這個點不是O就是X，所以只要任何長的像H1的切線都是O，任何長的像H2的切線都是X</p>\n<img src=\"/2017/08/01/Machine-Learning-Foundation-5/TwoInput.JPG\" class=\"\" width=\"500\">\n\n<p>如果是兩個輸入的話，總共會有4種切線，</p>\n<img src=\"/2017/08/01/Machine-Learning-Foundation-5/ThreeInput.JPG\" class=\"\" width=\"500\">\n\n<p>如果是3個輸入呢？看起來總共會有8種總合，但是事實上其中會有2種組合沒辦法使用直線切出來(OXO和XOX)，所以實際上只會有6種切線。</p>\n<img src=\"/2017/08/01/Machine-Learning-Foundation-5/EffectNumberofLine.JPG\" class=\"\" width=\"500\">\n\n<p>這又稱為Effect Number of Lines，從表格可以發現每個輸入最多只會有2^N種組合，但是能夠有效的切出兩種分類會從3個輸入開始變少，所以我們可以把M取代成effect(N)。也就是說無論今天的M再多大，都可以找到一個有限的切線數量effect(N)，而且這個effect(N)可以比2^N小很多，這樣就能夠保證學習能夠發生。</p>\n<img src=\"/2017/08/01/Machine-Learning-Foundation-5/Dichtomies.JPG\" class=\"\" width=\"500\">\n\n<p>這裡講到Dichotomy的概念，所謂Dichotomy就是兩分的意思(分成O和X為一例)，Dichotomy和原本的hypothesis的差別在於Dichotomy是有限的組合，而Hypothesis是平面上無限條線的任一條，接下來會把原本的M取代成有限的Dichotomy數量。</p>\n<img src=\"/2017/08/01/Machine-Learning-Foundation-5/GrothFunction.JPG\" class=\"\" width=\"500\">\n\n<p>接著會透過計算成長函式(Growth Function)來找到有限的Dichotomy上限數量，取代M讓學習可以發生。</p>\n<img src=\"/2017/08/01/Machine-Learning-Foundation-5/PositiveRays.JPG\" class=\"\" width=\"500\">\n\n<p>以一個最簡單的Postive Ray來說明，資料點N分佈在一維線上，當我們取一個threshold可以找到不同的Postive Ray，那麼所有可能的Dichotomy組合總共會是N+1個(就是能在點之間切線的數量)，在這個問題下Dichotomy的組合大大的小於2^N種。</p>\n<img src=\"/2017/08/01/Machine-Learning-Foundation-5/FourGrowthFunction.JPG\" class=\"\" width=\"500\">\n\n<p>課程舉了四種不同的成長函數，其中PLA的Dichotomy數量mH(N)會小於2^N，但是對於Hoeffding不等式中，如果mH(N)是指數型成長，則無法確保不等式成立，所以我們需要證明mH(N)是一個多項式的成長。</p>\n<img src=\"/2017/08/01/Machine-Learning-Foundation-5/BreakPoint.JPG\" class=\"\" width=\"500\">\n\n<p>這個部份提到了Break Point的概念，所謂的Break Point就是當某一個輸入開始，Dichotomy數量不再是指數成長(即2^N)，像是positive ray在2個輸入時發生，postive interval在3個輸入時發生，2D perceptrons在4個輸入時發生。在這裡看到神奇的地方在於本來的沒有break point的情況下mH(N)會是指數成長，但是當有了break point後，mH(N)會是一個多項式，下一講就會開始證明是如何轉變成多項式的。</p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/05_handout.pdf\">Machine Learning Foundation 05</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習基石(Machine Learning Foundation)第六講筆記","url":"/2017/08/09/Machine-Learning-Foundation-6/","content":"<p>前面講到M如果會變成無限大，就無法滿足能夠學習的理論，所以我們希望能透過成長函式mH(N)來取代M，這一講主要在推論mH(N)是不是真的成長的比較慢，且能夠夠取代掉M</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/FourBreakPoint.JPG\" class=\"\" width=\"500\">\n\n<p>複習一下成長函數的定義是指Hyperthesis集合在N個點上最多能夠產生多少個Dichotomies(即O或是X兩分的排列組合)。上一講提到了四種成長函數，且每一種都可能有出現break point現象，就是指當輸入點數大於某個臨界值後，會產生沒有辦法滿足的Dicotomies組合。</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/RestrictionBreakPoint.JPG\" class=\"\" width=\"500\">\n\n<p>假設今天有一個Hyperthesis在N為1時mH(N)為2種，N為2時mH(N)最多只有3種(3 &lt; 2^2)，那麼我們要找在3點輸入時，而且最小的break point K為2(即任2點不能有shatter)，究竟mH(N)為多少呢？可以發現加上第5種組合，無論前面4種用什麼組合，在第5種任2點都會shatter，所以最多只會有4種可能</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/RestrictionBreakPoint2.JPG\" class=\"\" width=\"500\">\n\n<p>到這邊可以發現當N越大時，break point K會對最大可能的mH(N)產生限制(因為K為break point，K+1開始都會shatter)，使得當N越大時，N和mH(N)之間的差距會越來越大。所以如果可以證明mH(N)是一個多項式，就可以在原本的Hoeffiding不等式中，把可能無限大的M取代成有限制且為多項式的mH(N)，使得學習是有可能的。</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/BoundingFunction.JPG\" class=\"\" width=\"500\">\n\n<p>再來先別管成長函式了，我們透過bounding function來表示在break point為K的情況下，mH(N)的最大可能性，就是在K個點不能出現shatter。這樣我們就可以不用管問題是屬於positive intervals或是1D perceptrons要用不同的方法分析，我們可以統一使用B(N, 3)來表代所有不同的問題。</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/BoundingFunctionTable.JPG\" class=\"\" width=\"500\">\n\n<p>N和K建立的bounding function可以用表格來呈現，基本上可以分成4種。第一種是如果K為1，即B(N, 1)代表1個點不能出現shatter，那麼只會有1種情況；第二種是右上斜角部份，今天如果K大於N，那麼K等於沒有限制，所以最多會有2^N種情況；第三種是在斜角上，當N和k的值一樣時，因為不能是2^N種，所以減1最多會有2^N-1種。</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/AchieveDichotomy.JPG\" class=\"\" width=\"500\">\n\n<p>那麼最重要的斜角下方部份該怎麼填了，假設要填的值是B(4, 3)，我們猜測他可能和前一排的B(3, ?)有關係。這裡可以看到所有的組合總共是11種，看起來B(4, 3)好像是B(3, 3)和B(3, 2)相加，但是該怎麼去證明說是有關係的呢？</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/Estimating.JPG\" class=\"\" width=\"500\">\n\n<p>把B(4, 3)的11種解可以分成α和β兩種類型，橘色的類型為X1-X3相同，但是X4會不一樣(即2α)，紫色的類型為皆不相同(即β)。B(4, 3)指其中3個點不能shatter，那X1-X3也是其中的3個點，所以也不能shatter，意思就是說如果今天不看X4的話，因為X1-X3不能shatter，所以α加β會小於等於B(3, 3)。</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/Estimating2.JPG\" class=\"\" width=\"500\">\n\n<p>再繼續往下只看α部份的話，如果X1-X3其中有2個點shatter了，那麼再加上X4的話就會造成3點shatter，這也是B(4, 3)不允許的，所以X1-X3其中2個點也不能shatter。於是α會小於等於B(3, 2)</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/PuttingItAllTogether.JPG\" class=\"\" width=\"500\">\n\n<p>再來就可以把中間證明的過程連結在一起了，B(4, 3) ≤ B(3, 3) + B(3, 2)，又可以轉變成B(N, K) ≤ B(N-1, K) + B(N-1, K-1)，這樣就可以把斜角下方都值都可以填上一個上限值。我們最早從會有無限多組解的大M開始，再到其實大M是有限的，透過成長函數可找到dichotomy數量mH(N)，再推展到上限函式B(K, N)來統一計算N和K的上限值(不用依不同的情況計算mH(N))，最後證明到這裡的值其實就是上限的上限值(很繞口)。</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/BoundingFunctionTheorem.JPG\" class=\"\" width=\"500\">\n\n<p>所以推展到這邊可以得到的重點是，mH(N)會被上限函式bounded住，然後這個上限函式又會被上限的上限bounded住，而且這個上限的上限是一個多項式；因此只要確保有出現break point，就可以說mH(N)是個多項式。</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/BadBound.JPG\" class=\"\" width=\"500\">\n\n<p>再來回到原本的帶有union bound的Hoeffding不等式，我們經過上面的推導後，是不是可以把這個成長函式mH(N)丟進Hoeffding裡面，就可以了呢？再來會開始推導成投影片中的新的式子，是一個長的差不多的式子，他可以證明在N夠大的情況下，就可以根據Hoeffding不等式來說學習是可以達成的。</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/ReplaceEoutbyEin.JPG\" class=\"\" width=\"500\">\n\n<p>第一步遇到的問題是Eout會是無限多的值，所以會先把Eout取代成有限的Ein’，這裡的概念是如果Ein和Eout差距很大時(即壞事發生時)，那麼有很大的機會(&gt;1/2)，Ein和Ein’也隔的很遠。</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/DecomposeH.JPG\" class=\"\" width=\"500\">\n\n<p>接著第一步的結果，因為多了Ein’所以會多了N個樣本，所以成長函式裡面的N會變成2N。第二步會把Union Bounded中發生各種壞事的情況，找到共同發生的部份，所以把前面說到有限組合的mH(N)代進式子中。</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/HoeffdingWOReplacement.JPG\" class=\"\" width=\"500\">\n\n<p>再來因為我們是有限多個值了，所以想像概念就像是現在瓶子裡面有2N個樣本，今天抽出N個樣本，我們就可以把這N個樣本和原本的2N個樣本作比較。這就像是用了一個比較小的瓶子和比較小的\u000f\u000f\u000f\u000f誤差，使用了抽後不放回的Hoeffding，他其實還是Hoeffding。</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/VCBound.JPG\" class=\"\" width=\"500\">\n\n<p>證明到這邊，可以簡單的證明出apnik-Chervonenkis (VC) bound了! 所以在break point為4的2D perceptrons中，如果N夠大的情況下，是真的可以透過PLA達到學習效果的。</p>\n<img src=\"/2017/08/09/Machine-Learning-Foundation-6/Summary.JPG\" class=\"\" width=\"500\">\n\n<p>總結來說，這一課證明了只要存在break point，就會對未來的成長函數加上很大的限制，因為有了break poin也才能證明mH(N)會被一個多項式的上限函式bounded住，並且mH(N)可以取代Hoeffding原本是無限多的大M</p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/06_handout.pdf\">Machine Learning Foundation 06</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習基石(Machine Learning Foundation)第七講筆記","url":"/2017/08/16/Machine-Learning-Foundation-7/","content":"<p>在上一講中證明了如果存在break point，而且輸入點N夠大的情況下，Ein和Eout是會接近的。這一講會延續VC bound帶出VC Dimension。</p>\n<img src=\"/2017/08/16/Machine-Learning-Foundation-7/MoreOnGrowthFunction.JPG\" class=\"\" width=\"500\">\n\n<p>前面有證明到，成長函式mH(N)會被上限函式B(N, k) bound住，然後上限函式又會被一個多項式N^k-1給bound住。所以我們可以直接使用N的k-1次方來表示成長函式。</p>\n<img src=\"/2017/08/16/Machine-Learning-Foundation-7/MoreOnVCBound.JPG\" class=\"\" width=\"500\">\n\n<p>再來把N的k-1次方取代原本的成長函式mH(N)並代回原本的Hoeffding不等式中，他告訴我們1. 只要成長函式存在break point，即表示是個好的hypothesis且2. 輸入的N夠大，即表示是個好的D的情況下，再來配合3. 一個好的演算法，那麼就可以保證機器可以有學習的效果。</p>\n<img src=\"/2017/08/16/Machine-Learning-Foundation-7/VCDimension.JPG\" class=\"\" width=\"500\">\n\n<p>VC dimension被定義為最大的非break point維度，所以當我們說在k點不能被shatter，那麼VC dimension就是k-1。</p>\n<img src=\"/2017/08/16/Machine-Learning-Foundation-7/FourVCDimension.JPG\" class=\"\" width=\"500\">\n\n<p>依據VC dimension的定義，在PLA是在4點不能shatter，所以VC dimension為3。以前我們說成長函式mH(N)是有限的就是好的，現在我們可以說如果VC dimension是有限也就是好的。</p>\n<img src=\"/2017/08/16/Machine-Learning-Foundation-7/2DPLARevisited.JPG\" class=\"\" width=\"500\">\n\n<p>有了VC dimension再回來看2D的PLA該怎麼學習，PLA可以在線性可分的資料D中找到g讓Ein為0，而VC dimension為3且N夠大的情況下，能推論Ein和Eout會很接近，即Ein和Eout差距很大的機率會很小，又因為Ein為0，所以可以知道Eout也會很接近0，就代表機器真的可以學習了。</p>\n<img src=\"/2017/08/16/Machine-Learning-Foundation-7/VCDimensionOfPerceptron.JPG\" class=\"\" width=\"500\">\n\n<p>前面可以看到1維perceptron的VC dimension為2，2維的perceptron的VC dimension為3，這樣看起來似乎可以推論出d維度的VC dimension為d+1。當然這是正確的，因為後續可以證明出dVC &gt;= d+1和dVC &lt;= d+1</p>\n<img src=\"/2017/08/16/Machine-Learning-Foundation-7/DegreeOfFreedom.JPG\" class=\"\" width=\"500\">\n\n<p>VC dimension的物理意義大致上可以說是hypothesis集合在要作二元分類的狀況下，到底有多少的自由度。前面提到的VC dimension的定義是說，VC dimension在k-1的時候可以產生最多的dichotomy，所以這個自由度也就告訴我們hypothesis集合到底可以產生多少的dicotomy組合。以positive ray的例子來看，其有1個可以調整的參數，positive interval的例子則有2個可以調整的參數</p>\n<img src=\"/2017/08/16/Machine-Learning-Foundation-7/PenaltyForModelComplexity.JPG\" class=\"\" width=\"500\">\n\n<p>我們可以將VC bound的式子作一些調整轉換，其中把右邊壞事情發生的機率代換成δ，那麼好事情發生的機率就是1-δ，也就是Ein(g) - Eout(g) &lt;= ε，再用右邊的部份可以導出ε。</p>\n<img src=\"/2017/08/16/Machine-Learning-Foundation-7/PenaltyForModelComplexity2.JPG\" class=\"\" width=\"500\">\n\n<p>好事情發生的機率，即Ein(g)和Eout(g)有多靠近，又可以稱為generalization eror，就是指舉一反三的效果好不好。衡量一個model的複雜度可以用Ω符號來表示，而VC dimension告訴我們的是，當model的複雜度越高的時候，就會產生penalty效應，有很高的機率Eout(g)會小於等於Ein(g)加上model的複雜度。</p>\n<img src=\"/2017/08/16/Machine-Learning-Foundation-7/TheVCMessage.JPG\" class=\"\" width=\"500\">\n\n<p>以圖示來看這個現象，其中model複雜度會隨著VC dimension越大而變大；而VC dimension越大時，排列組合也會比較多，就比較有可能找到一個更小的Ein，所以Ein會降低。但是因為model複雜度的penalty效應，Eout並不會隨著Ein持續下降，而且到達一個臨界點時轉折變成一個山谷型，所以最好的VC dimension就是中間轉折的地方。這在機器學習上的意義就是，當我們使用很強大的hypothesis或是model，也會伴隨著model複雜度提高帶來的壞處，也就是把Ein作到最好，但也可能因為model複雜度的penalty讓Eout沒辦法作到最好，在使用機器學習上都需要進行取捨的地方。</p>\n<img src=\"/2017/08/16/Machine-Learning-Foundation-7/SampleComplexity.JPG\" class=\"\" width=\"500\">\n\n<p>那麼到底需要多少的樣本資料，才能讓Ein和Eout很接近呢？假設今天要讓Ein和Eou相距ε為0.1而且δ壞事發生的機率為10%，如果是2D的perceptron其VC dimension為3，那需要有多少的資料才足夠呢？理論上可以推出29300筆可以滿足，大至上為10000 x dVC，但是實務上只需要10 x dVC的樣本數就足夠了。</p>\n<img src=\"/2017/08/16/Machine-Learning-Foundation-7/Summary.JPG\" class=\"\" width=\"500\">\n\n<p>總結這一講的內容，主要在介紹VC dimension定義為最大的non-break point，且percepron的VC dimension為d+1，VC dimension其實際意義為可自由調整的參數，且VC dimension會影響到模型和樣本的複雜度</p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/07_handout.pdf\">Machine Learning Foundation 07</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習基石(Machine Learning Foundation)第九講筆記","url":"/2017/09/12/Machine-Learning-Foundation-9/","content":"<p>上堂課講到err的衡量方法有兩種，其中一種squared err就是這這堂課Regression就會用到的err衡量方法。</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/CreditLimitProblem.JPG\" class=\"\" width=\"500\">\n\n<p>regression會拿來解連續型資料的問題，以前面提過的信用卡案例來說，regression就不是拿來用在判斷要不要發給信用卡，而且會決定發卡的額度上限是多少，依然是一個機器學習問題。</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/LinearRegressionHypothesis.JPG\" class=\"\" width=\"500\">\n\n<p>前面的例子也有說到，不同的資料特徵值可能會有不同的重要性，所以會有一個權重w來表示每個x的重要性加權。這有點累似之前的perceptron，但差別是perceptron是用來作二元分類，所以會再取sign判斷正負號，而這裡的regression是不用的。</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/IllustrationLinearRegression.JPG\" class=\"\" width=\"500\">\n\n<p>linear regression的hypothesis主要會找到一條線(或超平面)來盡量滿足所有的資料點，而資料點和線或是平面的距離就稱為residuals(餘數)，或是可以稱為誤差，我們會希望這個餘數越小越好，因為越小就代表hypothesis越正確。</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/ErrorMeasure.JPG\" class=\"\" width=\"500\">\n\n<p>一開始有講到，linear regression最常使用的錯誤衡量方法就是sqiared err。</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/MatrixEin.JPG\" class=\"\" width=\"500\">\n\n<p>在regression求Ein時，可以把運算過程轉換成向量矩陣運算</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/MinEin.JPG\" class=\"\" width=\"500\">\n\n<p>在求Ein最小值的過程只有W是未知的，而這個Ein(w)會是一個convex函式，在反覆修正W最終會得到一個最低點，也就可以找到Ein最小值，可以找透過找梯度為0來找到這個最低點。</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/Gradient.JPG\" class=\"\" width=\"500\">\n\n<p>中間會將梯度函式重新整理，在梯度等於0的情況下，最終會找到最好的W。在求W的過程中會帶出pseudo-inverse的概感，使用pseudo-inverse和y就可以求出最好的W。</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/IsRegressionLearning.JPG\" class=\"\" width=\"500\">\n\n<p>這樣看起來直接計算出W好像有一步登天的感覺不像機器學習，但事實上linear regression可以說是機器學習方法，因為確實可以找到Ein，當你認同VC維那麼好的Ein就會有好的Eout，而且在計算過程中，其實背後也有很多的步驟進行並非一步就達成。</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/IsRegressionLearning2.JPG\" class=\"\" width=\"500\">\n\n<p>要怎麼確定linear regression真的可以學的好呢？可以透過對多的Ein的平均來衡量，而這個Ein的平均大概會等於noise level(資料的雜訊)×(1-d+1/N)，所以如果資料量越多得到的結果就會越好。</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/GeometricViewHatMatrix.JPG\" class=\"\" width=\"500\">\n\n<p>以幾何上來說來說明，y是一個N維的向量，X是在N維上的一個小空間，而y(hat)會落在這個小空間裡。linear regression的目的就是讓y和y(hat)可以最小，最小的距離就是y到y(hat)的線性投影，所以linear regression的hypothesis的目的就是把任何一個向量投影到x空間中。因為H作了投影，而I-H等同就是在求餘數，即y-y(hat)。這之中會存在一個特性trace(I-H) = N-(d+1)。</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/AnIllustrativeProof.JPG\" class=\"\" width=\"500\">\n\n<p>y為f(x)加上noise，Ein其實就是把I-H用在noise向量上，最後推導出來Ein平均為noise level×(1-d+1/N)，Eout平均推導出來剛好相反，為noise level×(1-d+1/N)。</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/TheLearningCurve.JPG\" class=\"\" width=\"500\">\n\n<p>從Ein和Eout可以畫出leraning curve，當資料量N越大時可以看到Ein和Eout的變化，Eout會越加越少，Ein會越減越少，兩者都會收斂。VC求的是最壞的情形，而我們現在是求平均的情形，但兩者會得到類似的結果，所以可以說linear regression在N夠大時，並在noise不是太多的情況下，確實是可以學習的。</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/LinearClassification.JPG\" class=\"\" width=\"500\">\n\n<p>和之前的線性分類相比，分類的y是兩元類別，迴歸是一個連續型實數；分類會取sign轉成二元類別而迴歸不用；在錯誤衡量方法，分類是用0/1 error而迴歸是用squared error。因為迴歸的運算可以很有效的得到解答，那麼是不是可以把linear regression拿來解分類問題嗎？</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/RelationOfTwoError.JPG\" class=\"\" width=\"500\">\n\n<p>其實兩者最大的不同就是在錯誤的衡量，可以發現迴歸的平方錯誤會比分類0/1的錯誤還大。</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/RegressionForClassification.JPG\" class=\"\" width=\"500\">\n\n<p>接著把VC放進來分類問題，因為regression的squared錯誤會比0/1錯誤還大，分類會被regression bound住。所以如果可以把regression作的很好，就可以把分類作的很好，甚至可能把Eout也作好。所以確實可以用regression來取代作分類問題，會比較好解，但是效果確不一定比較好，因為其錯誤為分類的上界。</p>\n<p>有個好的辦法是，先透過regression來算出一個W初始值，再將這個W拿去PLA進行學習，可能可以增加PLA學習的效率。</p>\n<img src=\"/2017/09/12/Machine-Learning-Foundation-9/summary.JPG\" class=\"\" width=\"500\">\n\n<p>總結來說，這一堂課介紹了linear regression，其在求解時而要求出pseudo-inverse，而且可以確保Eout和Ein平均的差距為2(d+1)/N，最後linear regression是可以用在分類問題上的。</p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/09_handout.pdf\">Machine Learning Foundation 09</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習基石(Machine Learning Foundation)第八講筆記","url":"/2017/08/24/Machine-Learning-Foundation-8/","content":"<img src=\"/2017/08/24/Machine-Learning-Foundation-8/roadmap.JPG\" class=\"\" width=\"500\">\n\n<p>先來複習一下前面課程，從前面的課程可以得知，在有限的VC維度下，且有大的樣本N並且Ein是夠小的，滿足三個條件我們就可以讓機器可以學習。</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/RecapLearningFlow.JPG\" class=\"\" width=\"500\">\n\n<p>那如果今天在整個學習流程中，未知的目標函式在產生x時有雜訊發生，會發生什麼事呢？這堂課主要就是在說明，如果資料有雜訊，到底會不會對學習造成影響。</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/Noice.JPG\" class=\"\" width=\"500\">\n\n<p>事實上雜訊是有可能發生的，比如說在審核信用卡的例子，可能在y產生雜訊，即發不發信用卡被錯誤標記；也可能在x產生雜訊，這就發生在蒐集資料時產生的錯誤。那麼究竟有雜訊會不會對VC維產生影響呢？</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/ProbabilitiesMarbles.JPG\" class=\"\" width=\"500\">\n\n<p>我們一樣從前面的抽彈珠例子來看，本來如果f(x)和h(x)相等時是綠色，不相等是橘色，今天如果有雜訊發生，代表y和f(x)會不相等(明明要核卡但沒有)。雜訊就可以假設成一種會變顏色的彈珠，有時是綠色有時是橘色，雖然會有這種雜訊的彈珠出現，但是因為雜訊變色彈珠是少數，我們仍然可以透過抽樣的方式來計算橘色和綠色彈珠的比率，所以VC維還是會work的。</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/TargetDistribution.JPG\" class=\"\" width=\"500\">\n\n<p>這邊會帶出目標分配P(y|x)，以二元分類o和x的例子來看，如果我們已知P(o|x)是70%，P(x|x)是30%，在這個情況下我們會選擇o，但是剩下的30%可以看成雜訊。即最好的預測是o，而雜訊發生的機率是30%。所以在這裡機器學習要作到的，就是在點x找到最理想的mini-target。</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/TheNewLearningFlow.JPG\" class=\"\" width=\"500\">\n\n<p>最後再把雜訊加進去後，可以把目標函式f(x)改變成mini-target P(y|x)加上雜訊，而這個y會用來在最後評估g和f是否接近。</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/PointwiseErrMeasure.JPG\" class=\"\" width=\"500\">\n\n<p>之前談到的錯誤衡量方式為分類錯誤(又稱為0/1錯誤)，就是直覺的判斷g(x)和f(x)是否相等，不管是Ein或是Eout都可以對每一個點各自作判斷(稱為pointwise)是否發生錯誤。</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/TwoErrMeasures.JPG\" class=\"\" width=\"500\">\n\n<p>這種0/1錯誤衡量會用在分類問題上，除了分類錯誤外，另外常用的錯誤衡量方式為Squred Err，判斷每一個y到理想的y的距離，這種則常用在數值型的機器學習問題，像是迴歸分析。在不同的機器學習問題，會使用最適合的錯誤衡量方法。</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/LearningFlowWiErrMeasure.JPG\" class=\"\" width=\"500\">\n\n<p>當我們把錯誤衡量加上去，這個選擇的錯誤衡量會用來評估g(x)和f(x)是否相等。</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/ChoiceErrMeasure.JPG\" class=\"\" width=\"500\">\n\n<p>在0/1分類時，可能會有兩種分錯的情況，以指紋判斷正不正確來說明，一種為false reject，就是指原本是正確的，但是被判成錯誤；另一種為false accept，是指原本是錯誤的，但是被判成正確。看起來都是錯誤，但是這兩種錯誤會在不同的應用上有不同的重要性。</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/FingerprintVerificationOfSupermarket.JPG\" class=\"\" width=\"500\">\n\n<p>以超市的應用為例，如果超市透過指紋來判斷是不是要給折扣，今天判斷錯誤造成該給折扣卻沒給(false reject)讓顧客不開心，損失了這個客戶可能造成超市的損失；相比之下，如果是不該給折扣卻給了(false accept)，頂多只是超市有一點損失而已沒什麼大不了。所以以超市來看，false reject的成本會比false accept高。</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/FingerprintVerificationOfCIA.JPG\" class=\"\" width=\"500\">\n\n<p>以CIA應用為例，今天如果有人沒有權限但是卻被判斷有權限可以看資料(false accept)，這將是個很嚴重的錯誤；那如果是有權限但是被判斷成沒有權限(false reject)，其實只的造成員工的不開心而已。和超市相比，他的false accept成本可能就會遠遠大於false reject。</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/LearningFlowWiAlgo.JPG\" class=\"\" width=\"500\">\n\n<p>那麼到底該怎麼樣去衡量雜訊造成的實際應用錯誤呢？我們會透過設計友善的演算法來找到還可以接受的錯誤衡量方法。所以相比於實際的錯誤err，在設計演算法會透過計算一個另一個err hat，來試圖讓錯誤衡量可以更多的方便。</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/MinEinForWeightClassify.JPG\" class=\"\" width=\"500\">\n\n<p>前面講到的又稱為有權重的分類問題(weight classification)，不同的例子會有不同的重要性。因為已經證明在有雜訊的情況下VC維仍然是可行的，所以我們只要確保Ein是最小的，就可以保證Eout是最小的。我們總共學過兩個讓Ein最小化的方法，第一個是PLA，PLA就會等所有的資料都分對就結束，即Ein為0；如果PLA跑不完的話，可以用另外的Pocket演算法，Pocket演算法可以把加權錯誤比較好的放入pocket。</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/WeightedPocketAlgo.JPG\" class=\"\" width=\"500\">\n\n<p>如果我們要把0/1分類問題加上權重，其實可以簡單的把-1的資料複製成1000次，就會很像他有帶權重1000。實際並不的真的複製，原本的pocket會輪流拜訪每一個點，當我們這種-1的點讓他有1000倍的機率更容易被拜訪到，其實就可以達到類似的效果。</p>\n<img src=\"/2017/08/24/Machine-Learning-Foundation-8/summary.JPG\" class=\"\" width=\"500\">\n\n<p>總結來說，這堂課首先說明了有雜訊的情況下，會使用一個機率函式P(y|x)來取代f(x)，再來會使用適合的錯誤衡量方法來作評估，但是錯誤衡量方法有時並不容易給，所以會透過比較友善的演算法設計來達成。最後說到兩種不同的錯誤會有不同的權重，且這個權重可以透過虛擬複製的方法達成。</p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/08_handout.pdf\">Machine Learning Foundation 08</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"機器學習技法(Machine Learning Techniques)第一講筆記","url":"/2020/01/09/Machine-Learning-Techniques-1/","content":"<p>機器學習技法是林軒田老師的開的機器學習後半堂課，主要在延續前面機器學習的基礎理論，並延申出不同的機器學習模型介紹。</p>\n<img src=\"/2020/01/09/Machine-Learning-Techniques-1/CourseOutline.JPG\" class=\"\" width=\"500\">\n\n<p>而這堂課主要圍繞在特徵轉換上並分三個面向探討，分別為(1)如果處理大量且高複雜度的特徵轉換(2)找出具有預測性質的特徵來提升模型表現(3)找出資料中的隱藏特徵讓機器學習表現更好。</p>\n<img src=\"/2020/01/09/Machine-Learning-Techniques-1/NoiseTolerateHyperplane.JPG\" class=\"\" width=\"500\">\n\n<p>在線性可分的問題中，前面的課程有教過可以透過PLA或是POCKET來找到分開的超平面，但PLA在求解的過程中會得到很多種解，究竟怎麼樣的切線才會是比較好的切線呢？如果以雜訊的容忍度來看，當資料產生時可能會存在或多或少的雜訊(例如從實體感測器訊號收資料時，可能會有震盪或是偏移的現象)，而雜訊是模型過擬合的因素之一。因此如果要讓模型對雜訊的容忍度最大，那麼就要讓超平面能夠離點越遠越好。例如最右邊的超平面能離點最遠，雜訊的容忍度(灰色區域)也最大。</p>\n<img src=\"/2020/01/09/Machine-Learning-Techniques-1/LargestMarginHyperplane.JPG\" class=\"\" width=\"500\">\n\n<p>換個方式來，這會是一個最佳化問題，而最好的線須要滿足兩大條件: (1)能作出最大邊界(Margin) (2)可以把不同的類別分對。其中灰色區域的算法，是把每個點和超平面計算距離後取最小距離。</p>\n<img src=\"/2020/01/09/Machine-Learning-Techniques-1/DistanceHyperplane.JPG\" class=\"\" width=\"500\">\n\n<p>距離的計算方法，可以想像在平面上有兩個點構成的向量，而w乘上平面上的向量為0，所以w為垂直於平面上的法向量。當有一個x要計算x和平面的距離，即為x和平面上任一個點構成的向量，並對垂直於平面的向量作投影，即為對w方向的投影。</p>\n<img src=\"/2020/01/09/Machine-Learning-Techniques-1/DistanceSeperateHyperplane.JPG\" class=\"\" width=\"500\">\n\n<p>因為要找的是一個可以區分出正確類別的分割超平面，所以可以拆掉距離的絕對值，變成乘上y大於0(即為分割正確時值皆會大於0，如果類別分錯乘上y會小於0)</p>\n<img src=\"/2020/01/09/Machine-Learning-Techniques-1/SpecialSpearateHyperplanea.JPG\" class=\"\" width=\"500\">\n\n<p>為了簡化式子，假設將式子放縮到最小值會等於1，那margin就會簡化為成1/|w|，並從求margin的最小值，變成分數乘上y的最小值要等於1。而且因為其條件已經滿足大於0，所以可以再拿掉一條分數乘上y要大於0的限制式。</p>\n<img src=\"/2020/01/09/Machine-Learning-Techniques-1/StandardLargeMarginHyperplane.JPG\" class=\"\" width=\"500\">\n\n<p>為了再簡化限制式條件，限制式條件可以再從最小值為1，放寬為分數乘上y大於等於1，而且這個放寬並不會違反原本的限制式。老師這裡舉了一個例子，假設找出來的解為大於等於1.126並且不滿足等於1的條件，這時候如果把b和w除上1.126作放縮讓他滿足原本的條件，會因為w變小而使得目標式變大。這個證明在說如果找出來的解不滿於原本等於1的條件下，就不會是最佳解，因此可以對限制式條件作放寬。最後再將最大化的問題轉為求最小值(倒數)，得到最後的簡化的最佳化問題。</p>\n<img src=\"/2020/01/09/Machine-Learning-Techniques-1/SVM.JPG\" class=\"\" width=\"500\">\n\n<p>如果要找到最佳的平面，只要找到最靠近平面的點就行了，而這些點被稱為支撐向量(support vector)，就像是這個超平面是由最靠近的點所支撐起來般，這也是SVM的概念。</p>\n<img src=\"/2020/01/09/Machine-Learning-Techniques-1/SolveSVM.JPG\" class=\"\" width=\"500\">\n\n<p>因為svm要找到的最佳值是w的兩次函數，且限制式為b和w的一次式，有這樣的限制非常適合使用二次規畫作最佳化。</p>\n<img src=\"/2020/01/09/Machine-Learning-Techniques-1/WhyLargeMarginHyperplane.JPG\" class=\"\" width=\"500\">\n\n<p>但為什麼svm可以作的好呢，老師這邊以兩個面向來說明使用svm會讓Ein和Eout越接近，且不容易overfit泛化性更佳。</p>\n<p>之前在提到regularization的時候講到，為了讓Ein越小但又不希望造成overfit，於是加上w的限制條件限制其範圍。而svm剛好對調，svm是要讓w的長度越小且限制讓所有的類別的資料分對，所以svm和regularization是一體兩面，svm找出來的灰色區域讓為了容忍雜訊對模型的干擾。</p>\n<img src=\"/2020/01/09/Machine-Learning-Techniques-1/LargeMarginRestrictDichotomy.JPG\" class=\"\" width=\"500\">\n\n<p>假設平面上有三個點，如果是原本的pla，在任意切線上可以找到所有的類別組合(共八種)。但使用svm考量到需要維持最大特定margin區域情況，所以沒有辦法作出所有的類別排列組合。在vc維的介紹有講到，如果能作出的dichotomies越少，vc維就越小，Ein和Eout就會越接近，即泛化能力越好。</p>\n<img src=\"/2020/01/09/Machine-Learning-Techniques-1/BenefitSVM.JPG\" class=\"\" width=\"500\">\n\n<p>從上面兩個面向來看，svm可以帶來本質上泛化性更佳的好處，並且在加上特徵轉換的方法後，non-linear的svm可以同時辦到將Ein(即分對不同類別)與Eout(泛化能力)作好。</p>\n<img src=\"/2020/01/09/Machine-Learning-Techniques-1/SummaryLecture1.JPG\" class=\"\" width=\"500\">\n\n<p>這一講主要在說明如何從邊界分類問題延申出最大margin提供更強健的方法來容忍雜訊，並作svm最大margin的最佳化式子推導，最後提到最大margin帶來本值上的好處在於可以提高更佳的泛化能力。</p>\n<p>參考資料:<br/><a href=\"https://www.csie.ntu.edu.tw/~htlin/mooc/doc/201_handout.pdf\">Machine Learning Techniques 1</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Techniques","Support Vector Machine"]},{"title":"機器學習技法(Machine Learning Techniques)第二講筆記","url":"/2020/01/21/Machine-Learning-Techniques-2/","content":"<p>前面第一堂課在介紹線性的SVM，透過二次規畫找到最大margin的支撐向量來建立更強健的模型。這堂課將會延讀svm並加上非線性轉換的方式，讓SVM不止可以控制模型複雜度，也能結合特微轉換來提高模型效果。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/DualSVM.JPG\" class=\"\" width=\"500\">\n\n<p>假設透過特徵轉換的方法將SVM轉為非線性，原本的x會被轉換到z空間，但又希望可以在解SVM最佳化問題時，能夠擺脫轉換到z空間高維度的依賴。即將非線性轉換轉成另一個對等問題，不管轉到幾維的空間，都只會有N個變數，變數數量不會和要轉換的維度的有關，這稱為原本SVM的對偶問題(dual problem)。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/LagrangeMultiplier.JPG\" class=\"\" width=\"500\">\n\n<p>之前篇章在介紹regularization時，引入了Lagrange Multipliers的概念，將原本帶有W長度小於C的限制式，轉成加上Eaug後求最小值，其中λ會被乘上每個系數加進最佳化式子中。因為SVM也是一個有條件的最佳化問題，但是在引入λ時有別於regularization中被當作給定值，在SVM中會被當作未知的值來解最佳化問題。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/UnconstrainedSVM.JPG\" class=\"\" width=\"500\">\n\n<p>為了把原本有限制式的SVM最佳化問題，在引入Lagrange Multiplier後轉成沒有限制式的問題，會將限制式移項乘上α(即λ在SVM文獻為α)後相加。但是將有限制式的最佳化的問題，轉成沒有限制式的最佳化的問題，是否能夠得到一樣的結果？老師在這裡舉了兩種例子來說明其實會得到一樣的結果。假設選到一組會違反原本限制式的B,W(即α乘上的項次會是正值)，這種最終會在解最小值SVM問題時被逃汰；相反的，如果選到一組符合原本限制式的B,W(即α乘上的項次會負值)，這種解反而在最後會被留下來。因此將限制式轉益沒有限制式的最佳化問題，其實只是把限制藏進求最大值的最佳化中。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/LagrangeDualProblem.JPG\" class=\"\" width=\"500\">\n\n<p>在轉成無限制式的最佳化問題後，會發現假設在固定α之下，整個最佳化得出來的值會比任一的Lagrange值還要大，甚至取完最大值右邊的不等式也一樣成立，這個min和max互相交換稱為lagrange dual problem。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/StrongDualityQP.JPG\" class=\"\" width=\"500\">\n\n<p>對於二次規畫，這個duel problem因為滿足強對偶關係，因此求出來的b,w,α值對於左右兩邊的式子都是最佳值，因此可以將原本左邊的最佳化問題，直接轉成解右邊的對偶問題來求最佳值。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/DualSimplification1.JPG\" class=\"\" width=\"500\">\n\n<p>再進一步化解最佳化問題，如果要得到內部式子的最佳值，因為其為無限制的最佳化問題，因此最佳解會產生在梯度為0，即內部式子微分為0。首先對b微分後加進原本的式子，因為加進去的條件值為0時為最佳解，所以不止不會影響原本求出的最佳解，也可以同時去掉b這個項次。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/DualSimplification2.JPG\" class=\"\" width=\"500\">\n\n<p>再來對w微分後加進原本的式子，可以將w轉換成α．y．z相乘，在去掉w項次後，也不需要對原本的w取最小值，並轉成一個只有對α作最佳化的問題，得到簡化版的對偶問題。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/KKTcondition.JPG\" class=\"\" width=\"500\">\n\n<p>前面有提到如果要滿足對偶問題，即b,w,α的解對於左右兩邊的最佳化問題都是最佳值，需要滿足特定條件，這稱為KKT最佳化條件，再會來透過這些條件來解最佳的b,w。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/DualFormulationSVM.JPG\" class=\"\" width=\"500\">\n\n<p>再來先乘上-1先將最大值問題轉成最小值問題，再把平方向解開後，就可以將每個條件丟進QP來解出最佳值。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/Optimal.JPG\" class=\"\" width=\"500\">\n\n<p>如果今天在滿足KKT條件下要找到b,w的最佳值，首先要找到最佳的w，因為只有一條條件和w相關所以很容易找到最佳值。在找最佳的b時，共有2個條件和b相關，在第2個條件可以發現如果在α大於0的情況下，y(W．z + b)即需要等於1才能滿足條件，而這個值就是原本要找的最佳解，因此在解對偶問題時，可以同時找到SVM的支稱向量。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/SupportVectorRevisit.JPG\" class=\"\" width=\"500\">\n\n<p>既然證明在α大於0的情況下，可以找到支撐向量，相反的回到原本的SVM概念，其意義在於如果可以知道有哪些支稱向量，就可以找到最大的margin，其他的點皆可以不管。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/RepresentHyperplane.JPG\" class=\"\" width=\"500\">\n\n<p>SVM和PLA其實很相似都會找出區分不同類別資料的超平面，差別在於兩者著重的點是不同的，SVM是著重在使用支稱向量表現出來，而PLA是使用分類錯誤(犯錯)的點表現出來。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/TwoFormHardMarginSVM.JPG\" class=\"\" width=\"500\">\n\n<p>上一講介紹的原始SVM為Hard-Margin SVM，透過求特定放縮後的b,w最佳值，他和要轉換的空間維度有關，適合維度較小的問題；而這一講的SVM是引入Lagrange的SVM，透過找最佳的支稱向量和α來重構邊界，並且和資料量的大小有關，適合資料量小的問題。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/AreWeDoneYet.JPG\" class=\"\" width=\"500\">\n\n<p>但到目前為止仍然沒辦法完全擺脫處理高度空間維度轉換的問題，因為在QP求Q矩陣時，仍會碰到z向量內積的問題，z向量的維度等同於目前要解的維度。</p>\n<img src=\"/2020/01/21/Machine-Learning-Techniques-2/Summary.JPG\" class=\"\" width=\"500\">\n\n<p>這一講提到透過對偶問題來移除對d維度的依賴，並引入Lagrange與KKT條件，透過QP來解出最佳值，並發現解出的最佳值就是支稱向量，並可以用來建立最大margin。下一講將會說明如何真正擺脫和d維度相關的計算。</p>\n<p>參考資料:<br/><a href=\"https://www.csie.ntu.edu.tw/~htlin/mooc/doc/202_handout.pdf\">Machine Learning Techniques 2</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Techniques","Support Vector Machine"]},{"title":"機器學習技法(Machine Learning Techniques)第三講筆記","url":"/2020/01/30/Machine-Learning-Techniques-3/","content":"<img src=\"/2020/01/30/Machine-Learning-Techniques-3/DualSVMRevisit.JPG\" class=\"\" width=\"500\">\n\n<p>上一講說明了dual SVM，好像可以讓SVM與高維度的z空間兩者可以脫鉤，但以計算的角度，仔細看會發現在整個求解過程中的Q矩陣還是會在z空間作內積。而在z空間的內積在運算可以拆成兩個部份，一個是先透過某個函式φ轉換到z空間，第二再進行轉換後的內積。但這樣的運算方法就會變成z空間的維度作內積。</p>\n<img src=\"/2020/01/30/Machine-Learning-Techniques-3/FastInnerProduct.JPG\" class=\"\" width=\"500\">\n\n<p>透過這個polynomial transform可以發現，其實是能先在x維度作完內積，再作函式φ的轉換，這樣就可避免產生在z空間作內積的情況，透過這個簡化的方式計算內積稱為kernel function。</p>\n<img src=\"/2020/01/30/Machine-Learning-Techniques-3/KernelTrick.JPG\" class=\"\" width=\"500\">\n\n<p>回到svm不管是在計算b和最佳的超平面gsvm時，都可以將kernel function應用在計算中。這種合併函式轉換和內積計算，來避免在在高級度空間進行內積計算的方法，又稱為kernel trick。</p>\n<img src=\"/2020/01/30/Machine-Learning-Techniques-3/GemeralPoly2Kernel.JPG\" class=\"\" width=\"500\">\n\n<p>延續前面的Poly-2 kernel例子，在每項前面再加上不同的係數，就能再對計算進一步簡化。雖然不同的函式都是轉換到相同的維度，但是會計算出不一樣的內積得到不同的距離，所以得到的幾合意義和算出來的SVM margin也會不同。其中最常使用的kernel為加上根號2與γ值的General Poly-2 kernel。</p>\n<img src=\"/2020/01/30/Machine-Learning-Techniques-3/Poly2Action.JPG\" class=\"\" width=\"500\">\n\n<p>舉例來說，中間為原本的Poly-2 kernel，而左右兩個為General Poly-2 kernel但代入不同的γ值，左邊帶很小的γ右邊帶很大的γ。可以看到得出的邊界是不同的，所以得出的支撐向量也不同(方框的點)。雖然三個kernel的邊界不同，margin的定義也不同，但這邊沒辦法說哪個邊界會比較好，因為三個kernel都可以把點分開。</p>\n<img src=\"/2020/01/30/Machine-Learning-Techniques-3/GeneralPolyKernel.JPG\" class=\"\" width=\"500\">\n\n<p>前面提到的Poly-2可以再加入ζ參數，就會形成一個包含3個參數的一般型態Polynomial Kernel，包含了(1)γ控制x內積算完後的放縮程度，和(2)ζ控制常數項與乘上轉換係數如何對應(3)Q代表poly作幾次方的轉換。而且不管作了幾次方的轉換，都是透遇kernel而不會在高維空間計算。使用高次方的轉換仍然可能會有overfit的風險，但SVM會透過找到最大margin來避免overfit，所以透過kernel可以讓SVM達到避免ovefit，又可以使用較複雜的模型，同時不需要高度的計算複雜度。SVM結合polynomial kernel又稱為Polynomial kernel。</p>\n<img src=\"/2020/01/30/Machine-Learning-Techniques-3/LinearKernel.JPG\" class=\"\" width=\"500\">\n\n<p>Polynomial kernel如果設定成1次轉換，γ設成1，ζ設成0的話，就等於是原本的linear kernel SVM。老師建議大家在使用SVM時，可以從linear SVM開始，如果linear就可以解決問題，就不需要作高次方的nonlinear轉換。</p>\n<img src=\"/2020/01/30/Machine-Learning-Techniques-3/InfiniteDimensionalTrasform.JPG\" class=\"\" width=\"500\">\n\n<p>既然可以透過kernel trick來達成高維度轉換的運算，那是否有可能作到無限多維轉換呢？老師這裡透過證明可以發現，即使在無限多維的情況，使用高斯函數作轉換是可以辦到的。</p>\n<img src=\"/2020/01/30/Machine-Learning-Techniques-3/GaussianSVM.JPG\" class=\"\" width=\"500\">\n\n<p>所以高斯函數也是一種kernel trick的方法，讓資料映射到無限多維的空間後找到支撐向量和超平面。但其實際上的意義為他會產生以支撐向量為中心的高斯函數的線性組合，也常被稱為RBF(Radial Basis Function) kernel。</p>\n<img src=\"/2020/01/30/Machine-Learning-Techniques-3/GuassianSVMAction.JPG\" class=\"\" width=\"500\">\n\n<p>到目前為止，SVM可以辦到使用kernel trick作無限多維的轉換後，再透過最大margin找到超平面，而SVM裡面的最大margin計算，可以對無限多維的轉換有一定程度的保護。但要注意SVM仍然會有overfit的問題，當γ越調越大時會使原本Gaussan裡面的σ變小Gaussian就會變尖(γ=1/2σ^2)，所以還是要小心γ參數的選用會決定SVM的表現，通常不建議使用太大的γ值。</p>\n<p>前面介紹到許多的kernel，不同的kernel也有其好處和壞處</p>\n<img src=\"/2020/01/30/Machine-Learning-Techniques-3/LinearKernelProCon.JPG\" class=\"\" width=\"500\">\n\n<ol>\n<li>Linear Kernel<br>最簡單的kernel，就是不作任何的維度轉換，其好處就是最簡單安全。除了QP好解之外也具有可解釋性，因為是線性所以可以透過每個特徵的權重來看出特徵的重要性，應該是遇到問題時要先被拿來嘗試使用的kernel。但其壞處在於問題如果是非線性的，那只靠線性沒辦法很好的解決問題。</li>\n</ol>\n<img src=\"/2020/01/30/Machine-Learning-Techniques-3/PolynomialKernelProCon.JPG\" class=\"\" width=\"500\">\n\n<ol start=\"2\">\n<li>Polynomial Kernel<br>Polynomial的好處在經過非線性轉換後，會比linear限制還要少，而且可以透過設定Q來限制模型的維度。缺點在於Polynomial有3個要給定的參數較難選定，而且在計算值時QP不容易解，尤其是γ過大的時候，因此Polynomial比較適合用在心裡有假設而且使用比較小的Q。</li>\n</ol>\n<img src=\"/2020/01/30/Machine-Learning-Techniques-3/GaussianKernelProCon.JPG\" class=\"\" width=\"500\">\n\n<ol start=\"3\">\n<li>Gaussian Kernel<br>Gaussian可以作到無限多維的轉換，所以會比Linear和Polynomial使用限制更少。而且Gaussian的數值會落在0到1之間，所以數值計算難度較低；又因為Gaussian只有一個參數要給定，比起Polynomial要選3個參數，Gaussian可以更容易作參數選擇。Gaussian的壞處在於被轉換到無限多維後，模型沒辦法容易的被解讀；另外他的速度會比單純使用線性還要慢，又因為轉換較複雜，因此使用的不好會造成overfit。</li>\n</ol>\n<img src=\"/2020/01/30/Machine-Learning-Techniques-3/OtherValidKernel.JPG\" class=\"\" width=\"500\">\n\n<p>Kernel表示一種特徵的相似度，但是不是任何相似度都能用來當作Kernel呢？這邊老師給出必須要滿足對稱性還有postive semi-definite兩種條件才能當作Kernel。</p>\n<img src=\"/2020/01/30/Machine-Learning-Techniques-3/Summary.JPG\" class=\"\" width=\"500\">\n\n<p>這一講提到了如何透過kerlnel trick快速計算轉換和內積，避開最複雜的計算，另外也比較了不同的kernel的優點和缺點。</p>\n<p>參考資料:<br><a href=\"https://www.csie.ntu.edu.tw/~htlin/mooc/doc/203_handout.pdf\">Machine Learning Techniques 3</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Techniques","Support Vector Machine","Kernel Trick"]},{"title":"機器學習技法(Machine Learning Techniques)第四講筆記","url":"/2020/02/05/Machine-Learning-Techniques-4/","content":"<img src=\"/2020/02/05/Machine-Learning-Techniques-4/HardMarginCons.JPG\" class=\"\" width=\"500\">\n\n<p>上一講教了透過kernel trick來處理dual SVM中的轉換與內積，並介紹了不同的kernel function，從線性到無限多維轉換的Gaussian，但SVM還是有可能會overfit。overfit有兩種可能的原因，第一種為使用了過度複雜的轉換，第二種則是堅持要把所有資料完全的切分開來。以上面這個例子來說，如果可以容忍有錯誤分類，但可以使用簡單的線性切分也可以得到不錯的邊界；相反的，如果使用比較複雜的轉換確實完美的將資料都區分正確，反而容易造成overfit。</p>\n<img src=\"/2020/02/05/Machine-Learning-Techniques-4/GiveUpExample.JPG\" class=\"\" width=\"500\">\n\n<p>但該如何解決這個問題呢？之前在講pocket演算法時，pocket會找到能分錯資料最少的超平面，但hard-margin SVM除了要求要全部分對之外，還要選w長度最小的超平面。所以如果可以讓SVM也能像pocket一樣容忍一些錯誤，即不管部份分錯的點，就能達到某種程度的條件放寬。這邊引入C參數來代表放寬條件的相對重要性，C較大時代表越重視不要犯錯越好，C越小時代表越重視w長度，即分對的資料的margin越寬越好。</p>\n<img src=\"/2020/02/05/Machine-Learning-Techniques-4/SoftMargin1.JPG\" class=\"\" width=\"500\">\n\n<p>但放寬後的新問題將會違反QP的條件(min為二次式，條件要為一次式)，而且在允許犯錯的情況下，沒有辦法分辦到底犯錯的嚴重程度(小錯或是大錯)。為了解決這兩個問題，引入ξn來紀錄離想要的值(是否靠近1)有多近，即將犯了幾個錯誤轉成犯了多大的錯誤。除了可以解決無法分辨犯錯程度的問題，也可以讓問題符合QP。</p>\n<img src=\"/2020/02/05/Machine-Learning-Techniques-4/SoftMargin2.JPG\" class=\"\" width=\"500\">\n\n<p>如同前面說的，C可以用來控制large margin和margin violation，越大的C代表越重視分類的正確性，而越小的C代表margin可以比較大，但會造成某些資料分錯。</p>\n<img src=\"/2020/02/05/Machine-Learning-Techniques-4/SimplifyBeta.JPG\" class=\"\" width=\"500\">\n\n<p>當我們將Hard-Margin轉成Soft-Margin後，再來就是將它轉成對偶問題，就可以如同Hard-Margin一樣引入不同不同維度轉換的kernel function。第一步就是帶入Lagrange，有別於原本的Hard-Margin只需要帶入一個α，因為這邊分成兩個部分，因此分別帶入α和β。再進一步將ξn作微分拿掉ξ，可以發現在最佳解的位置C會等於αn+βn，就可以將βn簡化成C-αn，又因前後兩項分別都有C-αn互相消掉，所以可以再將式子簡化。</p>\n<img src=\"/2020/02/05/Machine-Learning-Techniques-4/OtherSimplify.JPG\" class=\"\" width=\"500\">\n\n<p>到這邊可以發現內部要解的問題其實就和之前的Hard-Margin SVM相同，只差在外面的條件帶入了C的限制，所以這邊可以和之前一樣分別對b和w作微分來得到Soft-Margin SVM的對偶問題。</p>\n<img src=\"/2020/02/05/Machine-Learning-Techniques-4/SoftMarginSVMDual.JPG\" class=\"\" width=\"500\">\n\n<p>再仔細看一下Soft-Margin SVM的對偶問題，可以發現和Hard-Margin SVM的對偶問題幾乎一樣，只差在現在α會有一個上限值C，而這個C是來自引入β後得到的。</p>\n<img src=\"/2020/02/05/Machine-Learning-Techniques-4/SoftMarginGaussianSVM.JPG\" class=\"\" width=\"500\">\n\n<p>當我們把Gaussian SVM用在Soft-Margin上並調整不同的C值時，可以發現最左邊當C設成1的時候，會得到一個邊界但有部份的資料是分錯的；當C一直調到到100可以發現邊界會越來越複雜，但是分錯的資料會越來越少。其中最右邊的邊界雖然可以讓所有的資料分對，但也可以造成雜訊的容忍度下降，也就是容易造成overfit，因此C和γ值需要慎選。</p>\n<img src=\"/2020/02/05/Machine-Learning-Techniques-4/SelectionbyCrossValidation.JPG\" class=\"\" width=\"500\">\n\n<p>介紹完Soft-Margin和kernel，參數該怎麼選呢?第一個方法可以嘗試使用cross validation的方式，並帶入不同的C和γ值來找到比較好的參數組合。</p>\n<img src=\"/2020/02/05/Machine-Learning-Techniques-4/LeaveOneOutError.JPG\" class=\"\" width=\"500\">\n\n<p>另一個有趣的方法則是使用Leave-One-Out CV，SVM在使用Leave-One-Out CV的error會小於等於support vector的比例(support vector的數量除上所有樣本數)，其概念為即使少了non support vector(non-SV)的點，結果並不會影響到margin的計算。</p>\n<img src=\"/2020/02/05/Machine-Learning-Techniques-4/SelectionbySV.JPG\" class=\"\" width=\"500\">\n\n<p>所以也可以嘗使用support vector的數量來選擇模型，因此在作cross validation前可以透過檢查support vector的數量，去掉support vector數量較多的組合作模型的安全檢查。</p>\n<img src=\"/2020/02/05/Machine-Learning-Techniques-4/summary.JPG\" class=\"\" width=\"500\">\n\n<p>總結這堂課介紹了soft-margin SVM，其核心概念在於不強求把所有的類別都分對，並加上犯錯的程度大小的懲罰項。在推導的部份，Soft-Margin和Hard-Margin結果幾乎一樣，只差在Soft-Margin在αn會存在上限值C。而SVM可以將資料分成三種，分別為non-SV、存在邊界上的free-SV與可能違反邊界的SV。最後在model selection可以使用cross-validation或是參數SV的數量來作選擇。</p>\n<p>參考資料:<br><a href=\"https://www.csie.ntu.edu.tw/~htlin/mooc/doc/204_handout.pdf\">Machine Learning Techniques 4</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Techniques","Support Vector Machine","Kernel Trick"]},{"title":"機器學習技法(Machine Learning Techniques)第五講筆記","url":"/2020/02/14/Machine-Learning-Techniques-5/","content":"<img src=\"/2020/02/14/Machine-Learning-Techniques-5/wrapup.JPG\" class=\"\" width=\"500\">\n\n<p>上一堂講到在允許違反部份邊界下，引入C當作懲罰值，將Hard-Margin SVM轉成Soft-Margin。而Soft-Margin的對偶問題和Hard-Margin非常相似，只差在對偶問題中的α有上限值C。這堂課會談如果將kernel trick引入logistic regression可以怎麼作。</p>\n<img src=\"/2020/02/14/Machine-Learning-Techniques-5/SlackVariable.JPG\" class=\"\" width=\"500\">\n\n<p>回顧Soft-Margin SVM，裡面發生的違反邊界會被紀錄在ξn裡面，而ξn會是1-yn(W．Zn+b)，因為會紀錄下與1的距離來表式違反的程度和嚴重性；相反的在沒有違反下ξn值為0。再來可以把ξn寫成另一個更簡單的式子，即為轉換成對1-yn(W．Zn+b)和0之間取最大值來算出ξn，並帶入SVM的最佳化式子中，將ξn轉成b和w算出來的結果。</p>\n<img src=\"/2020/02/14/Machine-Learning-Techniques-5/UnconstrainForm.JPG\" class=\"\" width=\"500\">\n\n<p>這個轉換後的最佳式其實和之前教過的regularization非常相似，就是在求長度w控制複雜度之下加上regularization項次。所以從這裡可以看到，Soft-Margin SVM其實可以從regularization推導過來，但上一講會選擇從Hard-Margin推導過來的原因是因為這個式子並不是一個QP問題，而且在兩項取最大值時也會有微分求解問題。</p>\n<img src=\"/2020/02/14/Machine-Learning-Techniques-5/SVMasRegularization.JPG\" class=\"\" width=\"500\">\n\n<p>在前面課程推導對偶問題時有提到SVM和regularization的相似地方，而這裡可以看到Soft-Margin SVM其實就和L2 regularization是相似的，所以SVM的large margin就是一個對regularization的實現。但其中細部的差異在於Soft-Margin會使用到特別的error表示，而C的大小即為控制regularization的程度(越大的C代表越小的regularization)。</p>\n<img src=\"/2020/02/14/Machine-Learning-Techniques-5/AlgorithmErrorMeasure.JPG\" class=\"\" width=\"500\">\n\n<p>在計算zero-one error時會是一個像階梯狀的函數，因為ys是正的error為0(猜的方向正確)，ys如果是負的error為1(猜的方向錯誤)。而SVM的error會由兩個線段組成，在ys離1越遠error會越大，而ys為正時error為0，SVM的error為zero-one error的上限，所以Soft-Margin也是在間接的把zeor-one error作好。</p>\n<img src=\"/2020/02/14/Machine-Learning-Techniques-5/SVMandLogisticRegression.JPG\" class=\"\" width=\"500\">\n\n<p>如果將SVM和logistic regression比較的話，從圖上可以發現logistic regression會和SVM很接近，進一步將ys在正無限大和負無限大比較時，兩者的error也是相近的，所以SVM其實也很像在作L2-regularized，因為在加上error項後，其實error項和logistic regression的error項非常接近。</p>\n<img src=\"/2020/02/14/Machine-Learning-Techniques-5/LinearModelClassification.JPG\" class=\"\" width=\"500\">\n\n<p>在比較三種兩元分類方法，最一開始教的PLA需要在線性可分的情況下才好作，如果在線性不可分要透過pocket也不好達成；logistic regression的函數有很好的最佳化性質，而且加上L2-regularized後還能對模型的複雜度有一定的保護；Soft-Margin SVM差異在於最佳化使用了QP，並且在有large margin的理論保證，其error的計算方式雖然和logistic regression不同，但確實非常接近，而且兩者都是在作最佳化zero-one error的上限值。因此regularized logistic regression其實就幾乎是在作Soft-Margin SVM。</p>\n<img src=\"/2020/02/14/Machine-Learning-Techniques-5/BinaryClassfication.JPG\" class=\"\" width=\"500\">\n\n<p>在二元分類問題中可以有兩種簡易的方法，第一種是透過SVM找到最佳的b和w，再直接丟進logistic reression作出二元分類，但這樣的手法就缺少了點logistic regression像是maximum likelihood的特色；第二種則是將SVM找到的最佳b和w，放進logistic regression當作始初解，之後再作最佳化找到最佳解，但這樣和本來logistic regression用其他初始解再找最佳解的結果相同，而且解變動後也失去了SVM的特性。</p>\n<img src=\"/2020/02/14/Machine-Learning-Techniques-5/TwoLevelLearning.JPG\" class=\"\" width=\"500\">\n\n<p>如果要同時有兩種方法的特性，可以先作SVM找到分數，再加上放縮的A與平移的B，最後再放進logistic regression訓練，其意義為先透過SVM找到最佳的超平面，再透過logistic regression作放縮與平移調整到最佳。也就是先透過SVM當作轉換，再丟進logistic regression作兩階段的的學習。</p>\n<img src=\"/2020/02/14/Machine-Learning-Techniques-5/ProbabilisticSVM.JPG\" class=\"\" width=\"500\">\n\n<p>透過這樣的方式就可得到SVM的Soft binary clasifier，因為引入縮放和平移所以會和原本的SVM會不太相同，在求解logistic regression時可以使用Gradient Descent即可。到這裡我們透過kernel SVM去推論logistic regression在z空間的近似解，但這裡不是真的在z空間解出logistic regression，而且透過SVM在z空間找近似解。</p>\n<img src=\"/2020/02/14/Machine-Learning-Techniques-5/KeyBehindKernelTrick.JPG\" class=\"\" width=\"500\">\n\n<p>複習一下SVM能使用kernel的關鍵點，是在於將W．Z的內積問題，將W轉換成一堆Z的線性組合，成為求Z．Z內積問題，這時候就能讓kernel上場。在SVM中，W就是Zn的線性組合，組合的系數就是對偶問題的解；PLA的W也是Zn的線性組合，組合的系數取決定每次犯錯的修正，而logistic regression中的W也是Zn的線性組合，這些系數來自梯度下降最終求得的結果。所以這些方法應該都能夠應用kernel trick輕易的在取得z空間的解，最好的W即可透過這些Zn來表達出來。</p>\n<img src=\"/2020/02/14/Machine-Learning-Techniques-5/RepresenterTheorem.JPG\" class=\"\" width=\"500\">\n\n<p>老師在這裡用例子證明任何的L2-regularized線性模型皆可以應用kernel。</p>\n<img src=\"/2020/02/14/Machine-Learning-Techniques-5/KernelLogisticRegression.JPG\" class=\"\" width=\"500\">\n\n<p>因此，在L2-regularized的logistic regression，就可以將W替換成Zn的線性組合，從求W轉成求所有β系數。在將Zn線數組合代進入取代W後，就能將Z．Z的部份使用kernel，接著就可以透過梯度下降來求最佳解，這就是kernel logistic regression。</p>\n<img src=\"/2020/02/14/Machine-Learning-Techniques-5/KLROtherView.JPG\" class=\"\" width=\"500\">\n\n<p>如果看這個kernel logistic regreaaion，先從β的角度看起來就像是在求β的線性組合，而且其中還將kernel用來作轉換與正規化；如果是從w角度來看，即為藏有kernel轉換與L2正規化的線性模型。但要注意常常β解出來會有很多0。</p>\n<img src=\"/2020/02/14/Machine-Learning-Techniques-5/Summary.JPG\" class=\"\" width=\"500\">\n\n<p>總結這堂課從將Soft-Margin SVM解釋成使用hinge error的regularize model，再進一步和L2-regularized logistic regresion比較兩者的相似性，透過結合兩者建立two-level learning應用在Soft Binary Classification，最後真的證明logistic regression也可以應用kernel並求出z空間的解，但會付出解出來很多β會為0的代價。</p>\n<p>參考資料:<br><a href=\"https://www.csie.ntu.edu.tw/~htlin/mooc/doc/205_handout.pdf\">Machine Learning Techniques 5</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Techniques","Support Vector Machine","Kernel Trick","Regularization","Logistic Regression"]},{"title":"機器學習技法(Machine Learning Techniques)第六講筆記","url":"/2020/02/22/Machine-Learning-Techniques-6/","content":"<img src=\"/2020/02/22/Machine-Learning-Techniques-6/RecallRepresenterTheorem.JPG\" class=\"\" width=\"500\">\n\n<p>上一堂講到kernel logistic regression，並證明L2-regularized linear model都可以kernel化。這堂課會嘗試將kernel放進L2-regularized linear regression作出kernel ridge regression。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/KernelRidge.JPG\" class=\"\" width=\"500\">\n\n<p>因為已經知道最佳的w會是βZ的線性組合，所以這裡一樣可以將w轉換為z的線性組合，當出現Z與Z乘積時就可以換成kernel，轉成透過kernel trick解β問題。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/SolvingKernelRidgeRegression.JPG\" class=\"\" width=\"500\">\n\n<p>因為這是一個無條件的最佳化問題，所以可以求梯度為0，即對β微分等於0求出讓梯度為0的β最佳解。因為K一定大於0所以可以求出需要求解的反矩陣來解出最好的β。原本之前說的要作nonlinear的方法是先作transform轉換再作regression，而且現可以另一種方法即使用kernel來達成nonlinear regression。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/LinearVSKernelRidgeRegression.JPG\" class=\"\" width=\"500\">\n\n<p>比較linear ridge regression和kernel ridge regression，kernel ridge rgression具有非線性性質所以有更彈性的應用來解決較複雜的問題，但其缺點就是要付出較大的計算時間複雜度。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/vsLSSVM.JPG\" class=\"\" width=\"500\">\n\n<p>kernel ridge regression當然也可以拿來作classification，這個方法又稱為LSSVM(least-squares SVM)。在比較Soft-Margin SVM和LSSVM，兩者得到的邊界可能會差不多，但比起Soft-Margin裡面求出的α是稀疏的，前面在解kernel ridge時β沒有特別的限制，因此β會求出dense的解，因而得到比Soft-Margin更多的support vector。而support vector較多的情況下，會造成在預測時效率較差。所以再來的重點是如何讓β也可以和標準SVM一樣求出稀疏解。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/TubeRegression.JPG\" class=\"\" width=\"500\">\n\n<p>這裡介紹到Tube Regression，比起原本的regression會計算每一點算與實際值的誤差，tube regression允許在一個範圍內，即落在tube內的點可以不計算error，而落在tube外的點除了計算與實際值的誤差外要再減掉tube的寬度，得到一種新的error計算方法。這種error被稱為ε-insensitive error，下一步會嘗試透過這個新的error來解出稀疏的β值。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/TubeVSSquaredRegression.JPG\" class=\"\" width=\"500\">\n\n<p>在比較Tube Regression和Squared Regresion會發現，兩者在預測值和實際值接近時，error計算是比較接近的。但是在相差越來越大時，squared regression的error會成長的比較快，因此也比較容易受到雜訊的影響。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/L2REgularizedTubeRegression.JPG\" class=\"\" width=\"500\">\n\n<p>L2-Regularized Ture Regression在求解時可以使用任何unconstrain的方式，和之前SVM求hinge error時一樣會遇到max無法微分，雖然也可以使用reprsenter的方式作kernel化，但卻無法保證最後求出的是稀疏解。而標準的SVM一樣無法微分，但是可以被寫成QP問題求解，再透過求對偶問題達成kernel化，而且因為滿足KKT condition可以保證其具有稀疏性。因此這裡可以把L2-Regularized Tube Regression模擬成像原本的SVM再求解(加入C並將w0拆出b值)。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/StandartSVR.JPG\" class=\"\" width=\"500\">\n\n<p>再進一步加入ξn來紀錄犯錯的程度，其中為了將限制式的絕對值拆掉，會得到upper tube violation和lower tube violation兩個ξn。這個式子就是一個Support Vector Regression(SVR)的標準式，而且也會符合QP問題。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/QPforSVR.JPG\" class=\"\" width=\"500\">\n\n<p>這個SVR的標準式會有兩個參數，一個是C和之前的SVM一樣用來控制regularization和violation之間的trade-off。第二個是ε用來紀錄tube的寬度決定允許的犯錯範圍。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/LagrangeMultiplier.JPG\" class=\"\" width=\"500\">\n\n<p>有了SVR的primal後，就可以引入Langrange multiplier來轉成對偶問題，所以這裡會引入兩個α來對應兩個ξn，再來就是重複之前課程的推導。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/SVRdual.JPG\" class=\"\" width=\"500\">\n\n<p>因為SVM和SVR的問題相似，所以可以發現兩者的對偶很相近，而且可以透過QP來解。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/SparsitySVRSolution.JPG\" class=\"\" width=\"500\">\n\n<p>回到原本的問題，我們希望β可以是稀疏的，也就是β系數在某些情況要是0。可以發現如果資料是在tube內部ξ會為0，而ξ為0的情況下complementary slackness括號內部的值就不等於0，又因為α和括號內部其中要有一邊要為0，所以α必定要為0，也就是β會等於0。所以位在tube內部的β會為0，而tube外面或是邊界就是對w有貢獻的support vector，這就可以得到β要稀疏解。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/MapofLinearModel.JPG\" class=\"\" width=\"500\">\n\n<p>到目前為止教過的linear model總共有5種，在分類問題上，除了最早教到的PLA/pocket方法，這幾講教的linear soft-margin SVM是透過找到具有soft-margin性質的超平面來解分類問題；在regression問題中除了前面講到的linear ridge regression，還引申出透過Tube與SVM概念所延伸出來的linear SVR。另外還有regularized logistic regression結合regularization作模型複雜度修正與maximum likelihood概念來處理分類問題。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/MapofKernelModel.JPG\" class=\"\" width=\"500\">\n\n<p>當linear model具有regularized性質時都可以引入kernel的概念，而這6講的內容分別教了如何將SVM、ridge regression、SVR和logistic regression帶入kernel trick。其中第一排的PLA/pocket和linear SVR，因為其表現都沒有第二排linear soft-margin SVM和linear ridge regression來的好，所以實務上比較少用。第三排的kernel ridge regression和kernel logistic regression因為β解出來是不是稀疏解，所以實務上傾向使用第四排的SVR。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/KernelModela.JPG\" class=\"\" width=\"500\">\n\n<p>kernel是一個power的方法強化linear model來解更複雜的問題，但要注意的是要小心處理參數的選擇以避免發生overfit。</p>\n<img src=\"/2020/02/22/Machine-Learning-Techniques-6/Summary.JPG\" class=\"\" width=\"500\">\n\n<p>總結這一講的內容，教到將representer theorem應用在ridge regression上，並結合tube regression引申出SVR的primal形式，再透過求解對偶得到β的稀疏解。最後則比較到目前為止教到的線性模型，並且有嘗試使用kernel來解更複雜的問題時要小心使用，避免overfit。</p>\n<p>參考資料:<br/><a href=\"https://www.csie.ntu.edu.tw/~htlin/mooc/doc/206_handout.pdf\">Machine Learning Techniques 6</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Techniques","Support Vector Machine"]},{"title":"機器學習基石(Machine Learning Foundation)第一講筆記","url":"/2017/06/26/Machine_Learning_Foundation-1/","content":"<p>林軒田老師的機器學習基石(Machine Learning Foundation)又開始在Coursera上開課囉!雖然老師已經在youtube上公開所有的課程影片還有課程Slide了，不過在Coursera上面跟著每周的課程，也滿有上課的感覺！剛好也針對上課的內容，希望在有時間之餘，隨手寫下一些其中自己覺得印象深刻的部份來加深對機器學習的瞭解。<img src=\"/2017/06/26/Machine_Learning_Foundation-1/KeyEssenceML.jpg\" class=\"\" width=\"500\">在第一講裡面談到了機器學習的背景，機器學習的過程是從資料出發，經過計算後可以得到某種表現的增進。比如說我們透過股市的資料，經過計算後讓電腦自動投資，來賺到更多的錢。那什麼時候該使用機器學習，其中有提到三個關鍵：</p>\n<ol>\n<li>資料或問題有潛藏的模式(Pattern)可以學習，並得到某種表現的增進</li>\n<li>具有存在的規則，但我們無法得知該如何(或是簡單的)定義</li>\n<li>需要有資料，因為機器學習需要從資料來學習潛在的規則</li>\n</ol>\n<img src=\"/2017/06/26/Machine_Learning_Foundation-1/KeyEssenceFunTime.jpg\" class=\"\" width=\"500\">\n\n<p>上面共有四個問題，讓我們思考倒底什麼時候可以使用機器學習(答案是3)。</p>\n<ol>\n<li>預測小孩下次什麼時候哭，因為是沒有pattern所以無法使用機器學習</li>\n<li>要判斷一個graph裡面是否有cycle，其實寫程式就可以判斷，而不用使用到機器學習</li>\n<li>判斷是否要核信用卡，其中包含了pattern，而且不容易被定義，且可以使用歷史資料來學習</li>\n<li>核能是否會毀滅地球，這個問題太有爭議性而且也沒有足夠的資料來學習</li>\n</ol>\n<img src=\"/2017/06/26/Machine_Learning_Foundation-1/FormalizeML.jpg\" class=\"\" width=\"500\">\n\n<p>在看機器學習的流程前，機器學習有幾個重要的定義:<br/>x: 機器學習的輸入資料，會透過這些輸入作學習<br/>y: 我們想要機器學習告訴我們的結果<br/>f: 目標函數，也可以說是x和y之間的pattern，他定義了x和y之間實際上的關係，因為f是未知的，所以這也是後們想透過機器學習來學到的<br/>D: 即資料，每一組資料包含了x和他相對應的y。d={(x1, y1)…..}<br/>g: 我們希望透過機器學習學到f，但事實上我們並不一定真的能得學到f。所以我們希望機器學習可以學到一個假說(hypothesis)的函數g，而且和f越接近越好</p>\n<img src=\"/2017/06/26/Machine_Learning_Foundation-1/DefinitionML.jpg\" class=\"\" width=\"500\">\n\n<p>上面可以看到機器學習的流程，透過資料餵給機器學習的演算法來學習到一個函式g，並且可以和f可以很像，這裡的f即是指資料的一種隱藏pattern，而且是未知的，而函式g會從hypothesis的集合內選出一個最符合資料的hypothesis。</p>\n<p>機器學習常常被和很多不同領域搞混或是分不出清楚，在課程也有說明機器學習和不同領域的關係</p>\n<p>Machine Learning vs Data Mining</p>\n<img src=\"/2017/06/26/Machine_Learning_Foundation-1/MLvsDM.jpg\" class=\"\" width=\"500\">\n\n<p>資料探勘簡單來說是指，期望從資料庫中大量的資料出發，並從中找到一些有趣的發現來回答問題。以超市來說，會希望透過銷售的資料來找到一個人買了一樣商品後，是否也會買另一樣商品(像是之前的<a href=\"https://www.inside.com.tw/2016/11/10/beer-diapers-myth\">尿布與啤酒</a>都市傳說)。但如果在資料探勘中想要找到有趣的事情，是指要找到一個假說G來作預測的話，那這裡的資料探勘就等同於機器學習。但資料探勘並非都會專注在作預測，有時可能只是想找到一些關聯性。</p>\n<p>所以機器學習和資料探勘兩個領或可以說是密不可分的，甚至兩者是可以互補的。比如說可以透過資料探勘找到有趣的性質可以幫助機器學習找到好的假說(可以用在摘取好的特徵值)，或是透過機器學習的假說來幫助資料探勘找到有趣的發現。</p>\n<p>Machine Learning vs AI</p>\n<img src=\"/2017/06/26/Machine_Learning_Foundation-1/MLvsAI.jpg\" class=\"\" width=\"500\">\n\n<p>人工智慧: 希望電腦能夠作出智慧的表現，來完成一件事情(開車、下棋、預測)</p>\n<p>有很多的方法可以達到不同的人工智慧任務，以下棋來說，傳統的人工智慧作法會設計演算法，透過分析一個game tree(下某一步棋的好處和壞處)來讓電腦自動下棋。如果是使用機器學習方法的話，就是設計演算法來可以告訴機器怎麼下棋會贏怎麼下會輸，然後讓機器分析後自己決定怎麼下(Alpha GO)。所以可以說，機器學習是實現人工智慧的一種方法。</p>\n<p>Machine Learning vs Statistics<img src=\"/2017/06/26/Machine_Learning_Foundation-1/MLvsStatistic.jpg\" class=\"\" width=\"500\"></p>\n<p>統計:使用資料來推論原本不知道的事情(ex: 丟銅板的機器)</p>\n<p>機器學習中的假說G實際上是一個推論的結果，F則是一個我們不知道的事情，所以統計可以說是實現機器學習的一種方法。我們可以透過很多傳統統計的工具來實現機器學習，將這些工具借過來，使用機器學習的角度來看他。</p>\n<p>參考資料:<br/><a href=\"http://www.csie.ntu.edu.tw/~htlin/mooc/doc/01_handout.pdf\">Machine Learning Foundation 01</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Machine Learning Foundation"]},{"title":"Andrew深度學習課程五 - Sequence Model第1周筆記","url":"/2018/02/05/andrew-deep-learning-course5-week1/","content":"<p>有序列性質的資料(sequence data)可以泛指輸入資料(X)是有序列的，或是輸出資料(Y)是有序列的。比如說在翻譯問題上，輸入和輸出都是有序列性的句子；但在情感分析問題上，輸入會是一個有序列性質的評論句子，但是輸出為情感的等級或是分數。</p>\n<img src=\"/2018/02/05/andrew-deep-learning-course5-week1/sequence_model_example.JPG\" class=\"\" width=\"500\">\n\n<p>量化句子的方法可以使用詞庫加上one-hot encoding，可以透過自己建立或是使用已存在的詞庫，並將詞庫使用one-hot encoding作編碼來將文字資料作量化產生可以用來學習的輸入資料X。</p>\n<img src=\"/2018/02/05/andrew-deep-learning-course5-week1/Representing_words.JPG\" class=\"\" width=\"500\">\n\n<p>如果使用一般標準的類神經網路會有什麼問題呢？1. 每一個訓練資料的輸入和輸出的長度不同，不好處理。2. 在不同文字中的不同位置無法學習出共同的特徵。如果要像CNN一樣能夠在不同的訓練資料的不同位置中學習到共同的特徵，就必須要透過RNN來達成。</p>\n<img src=\"/2018/02/05/andrew-deep-learning-course5-week1/recurrent_neural_networks.JPG\" class=\"\" width=\"500\">\n\n<p>Recurrent Neural Network(RNN)在每個訓練樣本會共同相同的weight和activation function。RNN會將每一個字詞X&lt; i &gt;經過激活函式後的結果，再傳給下一個字詞X&lt; i+1 &gt;，所以每個字詞會拿到由前面傳遞過來的資訊。但是只拿到前面字詞的資訊是不夠的，例如在判斷Teddy時，就需要使用字詞後面的句子內容，才能夠有效的區分Teddy究竟是指總統還是玩具。這時會使用到雙向的RNN(BRNN)才能夠解決這個問題。</p>\n<img src=\"/2018/02/05/andrew-deep-learning-course5-week1/why_not_standard_network.JPG\" class=\"\" width=\"500\">\n\n<p>前面有提到RNN的輸入和輸出長度可能會不一樣長，針對不同輸入輸出長度可分為不同類型的RNN。在翻釋問題上，不同的語言可能翻譯後的長度都不同，這是一個Many to Many問題；如果是情感分析會將一則評論輸出成正反或是1到5星等級，屬於Many to One問題；One to Many會適用在像是音樂生成，給定一種音樂類型來產生一首音樂；One to One這種類型就是一般的神經網路了。</p>\n<img src=\"/2018/02/05/andrew-deep-learning-course5-week1/RNN_type.JPG\" class=\"\" width=\"500\">\n\n<p>RNN可以被應用在建立語言模型(Language Model)，例如在語音辨識中，透過語言模型可以透過計算不同輸出句子的機率，來辨識出哪一個句子是最符合的輸出。</p>\n<img src=\"/2018/02/05/andrew-deep-learning-course5-week1/language_model.JPG\" class=\"\" width=\"500\">\n\n<p>把每個句字斷詞並量化後，就可以丟進RNN來建立模型。舉例來說，在訓練時，將第一層RNN輸入空向量，再將本來的實際詞Y&lt; i &gt;從第兩次RNN依序丟進去訓練，就可以建立模型來預測某段句子後會接什麼樣的詞。即輸入Cats average，判斷下個接每個詞的機率。所以可以透過將每個詞依序輸入來計算出在給定某個句子下，輸出某個詞的機率。在這裡可以透過外部詞典，並使用softmax來算出每個詞的機率</p>\n<img src=\"/2018/02/05/andrew-deep-learning-course5-week1/language_model_rnn.JPG\" class=\"\" width=\"500\">\n\n<p>進一步我們就可以使用這個模型來隨機的產生句子，首先先隨機選出一個詞，接著將每個詞依序丟進下個結點來產生新的詞，直到取出字尾EOS或是設定一個固定的句子長度終止。</p>\n<img src=\"/2018/02/05/andrew-deep-learning-course5-week1/sample_sentense_word_level.JPG\" class=\"\" width=\"500\">\n\n<p>除了使用詞(Word-level)來組成句子，也可以使用字元(Character-level)來建且模型組成句子。如果使用字元來組成句子，那麼每一個輸出就是一個字元而非一個詞，好處在於不用怕取到辭典裡面沒有的詞，壞處則會產生更長的句子，也會降低訓練速度，所以目前經常是使用詞來建立模型。</p>\n<h1 id=\"梯度消失-Gradient-Vanishing\"><a href=\"#梯度消失-Gradient-Vanishing\" class=\"headerlink\" title=\"梯度消失(Gradient Vanishing)\"></a>梯度消失(Gradient Vanishing)</h1><p>如果句子太長的話，使得神經網路過於深，會讓梯度在作back propagation時很難影響到前面的layer，產生梯度消失現象。對於RNN來說，實際上的影響在於如果太前面的神經元，將會無法去記住前面的詞(例如區分單數詞或是複數詞)。因此，傳統的RNN的輸出結果主要會受到接近神經元的影響，較遠的神經元不容易影響到最終的輸出。比起梯度爆炸容易被發現與處理，梯度消失反而不容易被處理，而且更容易影響到RNN的訓練結果。</p>\n<p>Gate Recurrent Unit(GRU)是一個改善RNN長期記憶問題的方法，他引入了memory cell(C)的概念，在這裡的C就等同於activation function的輸出a，這個memory cell會將長期的記憶儲存下來，並用一個帶使用sigmoid轉換後的Γu值來判斷要不要選擇忘記之前的記憶並更新，還是要保留之前的記憶，直到不需時再忘記。實際上為什麼應用GRU會改善梯度消失的現象，主是要在Γu值透過sigmoid轉換後如數數值很小那麼就可能會非常的接近0，在這個情況下，C&lt; t &gt;就會非常接近C&lt; t-1 &gt;並很容易的保存較遠的記憶來大幅改善梯度消失的現象。</p>\n<img src=\"/2018/02/05/andrew-deep-learning-course5-week1/GRU.JPG\" class=\"\" width=\"500\">\n\n<p>另一個常用的方法為Long Short Term Memory(LSTM)，在LSTM裡面C不再等同於a，LSTM會用到3種gate，分別為update gate, forget gate和output gate。</p>\n<img src=\"/2018/02/05/andrew-deep-learning-course5-week1/GRU_and_LSTM.JPG\" class=\"\" width=\"500\">\n\n<p>透過update gate和forget gate來決定是否保存較長遠的記憶，並透過output gate來輸出a到下一個神經元。</p>\n<img src=\"/2018/02/05/andrew-deep-learning-course5-week1/LSTM.JPG\" class=\"\" width=\"500\">\n\n<p>如果要同時合併前後神經元的資訊，就得使用Bidrectional RNN(BRNN)。BRNN除了從左到右作forward propagation外，也會從右到左作forward propagation。在輸出資料時，會同時輸入兩個方向進入activation function。而其中每個神經元也可以是GRU或是LSTM，所以實務上也會使用LSTM結合BRNN來建立模型。</p>\n<img src=\"/2018/02/05/andrew-deep-learning-course5-week1/BRNN.JPG\" class=\"\" width=\"500\">\n\n<p>RNN可以疊多層起來變成深度的RNN模型，本來RNN每一個順序都只有連接一個神經元，但也可以在每一個序順接處多個神經元來建立深度的RNN模型，甚至結合GRU和LSTM與BRNN來建立複雜的RNN模型。不過因為深度的RNN在訓練是非常耗資源的，所以不太常見到超過3層的RNN模型。</p>\n<img src=\"/2018/02/05/andrew-deep-learning-course5-week1/Deep_RNN.JPG\" class=\"\" width=\"500\">\n\n<p>參考資料:<br/><a href=\"https://www.coursera.org/learn/nlp-sequence-models\">Deep Learning Course 5 - Sequece Models</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Deep Learning","RNN","GRU","LSTM","Gradient Vanishing"]},{"title":"Andrew深度學習課程五 - Sequence Model第2周筆記","url":"/2018/02/18/andrew-deep-learning-course5-week2/","content":"<p>在上一週的課程中，我們使用了one-hot結合詞庫來將句子作量化處理。但是使用one-hot的缺點是每個詞被視為獨立的，也就是無法衡量出兩個詞之間的相似或與重要性(兩個one-hot vector內積都會為0)。所以當你想知道apple和orange之間的關係比起apple和king還接近，就無法單純的使用one-hot來作文字的量化。其中一個方法是可以用不同的特性來作量化，比如說使用性別、是否為食物等等的特性，這個時候便可以辯識出具有相同性質的詞。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/word_embeddings_feature.JPG\" class=\"\" width=\"500\">\n\n<p>這種量化文字的方法又可以被稱為Word Embedding，像是每個詞會嵌在高維度的特徵向量中，即每個詞都可以在高維度的特徵找到一個能表示它的位置，而如果要將多個維度的特徵壓縮到兩維來表示，可以使用t-SNE演算法來找到相同的詞會彼此較相近。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/word_embeddings_visualize.JPG\" class=\"\" width=\"500\">\n\n<p>使用Word Embedding的好處除了可以判斷出兩個詞之間的相關係，也對Transfer learning有很大的幫助，即使用已經訓練好的word embeddig來用在新的任務。在使用word embedding於transfer learning有幾種方法。1. 從大量的詞庫(1-3B)中進行訓練(或是下載已被訓練過的) 2. 使用原本已建立的embedding並transfer到新的而且訓練資料集較小(1-3k)的任務 3. 持續的使用新的資料來對embeddings進行finetune。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/word_embeddings_transfer.JPG\" class=\"\" width=\"500\">\n\n<p>Word Embeddings也可以作到比擬(analogy)，比如說Man之於Woman等同於King之於Queen，這可以透過向量相減來找到相似的結果。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/analogy.JPG\" class=\"\" width=\"500\">\n\n<p>實際上要基於Man與Woman的關係來找到King和某個詞，可以透過向量相似度的計算來找到，只要找到King和哪一個詞的相似度與Man和Woman的相似度最接近即可。這裡的相似度計算是從原始的高維度(~300D)來的，雖然可以透過t-SNE來將高維度使用非線性的轉換到2維空間作視覺化，但如果使用了轉換的2維來計算反而會失真，所以在實際上的相似度計算會使用原始的高維度向量空間。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/analogy_vector.JPG\" class=\"\" width=\"500\">\n\n<p>一個常用的相似度計算是Cosine similarity，即計算兩個向量的角度來判斷兩個相向之間的相似度。Cosine similarity也經常被用在文本分析中，透過計算代表兩筆資料的高維度向量，來評估兩筆資料的相似度。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/cosine_similarity.JPG\" class=\"\" width=\"500\">\n\n<p>Word Embedding的學習最終會得到一個Embedding Matrix，凡是把這個矩陣乘上某一個詞的one-hot向量，所得到的即是代表這個詞的embedding。因為one-hot是高維度而且幾乎都是0的稀疏矩陣，所以在實務上並不會真的相乘，而且透過特別的方法來找到詞的embeddings。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/embedding_matrix.JPG\" class=\"\" width=\"500\">\n\n<p>在word embeddings的學習演算法中，過去往往會使用很多很複雜的演算法來學習，但後來卻發現很多簡單的方法就可以達到很好的效果。在複雜的方法中，比如說要預測一句話的下一個詞，可以把每個詞的word embeddings輸入到一個類神經網路學習，最後訓練出我們要的embedding matrix(E)。如果有300維度，那麼要輸入到網路裡面的維度就會多達300乘6共1800維，也可以選擇只看前4個詞來學習，那麼維度就會降到300乘4共1200維。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/other_context_target.JPG\" class=\"\" width=\"500\">\n\n<p>不過事實上用簡單一點的模型也可以訓練出好的效果，比如說只用預測詞的前一個字，或是最接近預測詞前一個詞的詞(又稱為skip gram)來訓練word embeddings matrix。</p>\n<p>這裡介紹Word2Vec的Skip-grams模型，Skip-grams在選擇Context與Target組合時，針對Target可透過隨機挑選的方式選出不同的組合，比如說Context詞的+-5~10個詞來選出Target詞。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/skip_grams.JPG\" class=\"\" width=\"500\">\n\n<p>再來將這些對應的組合透過matrix E轉成word embeddings後丟入神經路網學習，接著經過softmax後計算loss function來訓練出matrix E。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/skip_grams_model.JPG\" class=\"\" width=\"500\">\n\n<p>但這個方法的主要缺點在於需要大量的計算，因為在計算softmax時，分別需要加總所有詞，如果詞的數量越多，那麼速度就會越慢，因此很難擴充到大型的訓練詞集。一個解法是使用hierarchical softmax，先拆出詞位於哪個部份(前或是後五千詞)，接著再接續往下作二元拆解。在tree的結構可以把常出現的通用詞放在上半部，這樣就可以較快的被找到。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/softmax_problem.JPG\" class=\"\" width=\"500\">\n\n<p>因為skip-grams在計算softmax需要花費大量運算，使用Negative Sampling則可以避免這個問題。Negative Sampling首先會先建立postive pair和negaive pair，比如說orange和juice會一起出現，就給予label 1，然後再隨機選出其他K個詞和orange組成negative pair給予label 0(即便某些時候negative pair組合真的有一起出現也沒關係)。最後將這些組合透過監督式學習訓練模型。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/negative_sampling.JPG\" class=\"\" width=\"500\">\n\n<p>接著可以使用logistic regression來計算在給定label為1時，postive pair組合的機率，並使用K+1組資料進行訓練，然後再將這個分類器應用在10000個詞作二元分類。因此比起原本作skip-grams要一次訓練10000組資料，使用negatiev sampling的方法只需要用少量的資料訓練，再一次用在多組詞的分類。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/negative_sampling_model.JPG\" class=\"\" width=\"500\">\n\n<p>但是該如何去選擇negative sampling呢？一個方法可以從詞出現的頻率選起，但是很容易選到停用詞(stop word)；或是假定他是均勻分配，使用1/|V|來選擇，而在這篇論文裡面是用了每個詞在訓練詞庫中出現的3/4次方來計算機率作選擇。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/negative_sampling_selection.JPG\" class=\"\" width=\"500\">\n\n<p>另一個學習方法為GloVe，首先會計算context和target一起出現在訓練資料的次數，Xij會等於Xji如果是用target的正負距離來選擇context，但是如果只看target出現在context後面，就會不相等。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/GlovVe.JPG\" class=\"\" width=\"500\">\n\n<p>GloVe的模型中為了避免Xij為0，因此會乘上一個權重f(Xij)，如果Xij為0則f(Xij)為0，當然這個函式也可以用來給予不同詞頻的詞有不同的權重處理。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/GlovVe_model.JPG\" class=\"\" width=\"500\">\n\n<p>情感分析(Sentiment Analysis/Classification)是NLP其中一種應用，主要用在判斷文本中是表達喜歡或是不喜歡(正或負)。比如說，輸入的X為評論的內容，輸出Y為評論的情感等級，像是從網路評論中判斷對於餐廳或是旅館的正負評論。其最大的困難在於情感分析缺乏大量的標記資料來學習，如果使用word embedding可以幫助在少量訓練資料的情況下學習。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/sentiment_classification.JPG\" class=\"\" width=\"500\">\n\n<p>在建立情感分析模型時，一樣使將每個詞透過embedding matrix選出該詞的embeddings向量，接著透過加總或是取平均值後，再使用softmax函式得到輸出Yhat。不過因為這樣的方法是沒有前後順序的，所以如果遇到明明有否定詞在前面，但是後面出現很多的正向詞good，這可能就會造成誤判斷把明明是一星的評論判成五星，因為出現很多次的good會把結果導到正向，這個時候就需要使用RNN來建立模型。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/sentiment_classification_model.JPG\" class=\"\" width=\"500\">\n\n<p>使用RNN一開始也是將每個詞透過embeddings matrix找到該詞的embeddings向量，接著將每個詞輸入進RNN，最後再接softmax判斷結果，這個就一開始提到的Many to One的RNN類型。因為RNN是會有順序性的，所以對於出現否定詞的句子能夠處理的比較好。因為word embedding可以從較大的訓練資料訓練出來，所以即使在情感分析的訓練集裡面缺少了某些詞，但這些詞有被word embedding訓練過，這樣在作情感分析時也可以得到較好的結果。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/sentiment_classification_rnn.JPG\" class=\"\" width=\"500\">\n\n<p>在word embeddings的訓練過程中，可能會造成帶有偏見的學習結果，比如說本來是希望學出Man之於Woman等於King之於Queen，但可能會學習出Man之於Programer對於Woman之於Home_keeper這種帶偏見，或是Father之於Doctor對於Mother之於Nurse這種錯誤的結果。因為機器學習現在已經越來越普及的被應用在許多不同的領域上，所以這種帶偏見的錯誤結果應該要被避免的。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/bias_problem.JPG\" class=\"\" width=\"500\">\n\n<p>解決這種錯誤的學習有不同的方法，以解決性別偏見為例來說明，第一先將girl-boy和mother-father來找到屬於性別的分界向量，這時把任一個詞和這個分界向量作內積，就可以找到這個詞會偏向哪個性別，並找出bias direction，要讓不能帶有性別偏差的詞向量去除bias。透過Neutralize將一些對於性別來說屬於中性的詞，將其投影到non bias的方向軸，最後為確保像是doctor這種應該屬於中性的詞，與帶不同性別的詞(像Girl或是Boy)距離要是相同的，會使用Equalize pairs的手法將帶性別的詞移動到以軸為中性對稱的位置，這樣就會讓兩者與doctor的距離或是相似度是相同的。在選擇哪些詞需要進行Neutralize，可以透過練一個分類器來分辨；在選擇要equalize的部份因為較少量，所以可以簡單透過人工挑選的方式完成。</p>\n<img src=\"/2018/02/18/andrew-deep-learning-course5-week2/bias_problem_addressing.JPG\" class=\"\" width=\"500\">\n\n<p>參考資料:<br/><a href=\"https://www.coursera.org/learn/nlp-sequence-models\">Deep Learning Course 5 - Sequece Models</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Deep Learning","RNN","Natural Language Processing","Word Embeddings","Word2Vec","GloVe","Sentiment Analysis"]},{"title":"Andrew深度學習課程五 - Sequence Model第3周筆記","url":"/2018/02/27/andrew-deep-learning-course5-week3/","content":"<p>在RNN的應用中，有一種是sequence to sequence模型，像是在語言翻譯問題上，要把長度為5的法文翻譯成長度為6的英文。首先先透過一個encoder將每個法文字詞輸入進RNN模型，再透過decoder逐一輸出英文字詞直到結尾，這樣的模型被證實只要使用足夠大量的法文和英文句子就可以完成。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/sequence_to_sequence.JPG\" class=\"\" width=\"500\">\n\n<p>另一個類似的應用是給一張照片，然後自動給予這張照片適當的標題，這時可以透過CNN來建立一個encoder，接著再透過RNN建立一個decoder來產生適當的標題。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/image_caption.JPG\" class=\"\" width=\"500\">\n\n<p>第一週有學到language model，會計算產生句子的機率。而在翻譯問題中的encoder部分和language model非常相似，只是在輸入不是向量0，而是一個encoder的網絡。翻譯問題其實很像是一個conditional language model，即給定輸入翻譯前的句子X之下，輸出不同翻譯結果的機率。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/conditional_language_model.JPG\" class=\"\" width=\"500\">\n\n<p>我們並不希望直接對這個分布輸出作隨機的取樣，因為取樣的結果容易很不穩定，有時取到好的翻譯結果，有時取到不好的翻譯結果。所以在使用這個模型的時候，需要使用一個演算法來計算出給定X輸出譯翻結果Y的最大條件機率。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/most_likely_translate.JPG\" class=\"\" width=\"500\">\n\n<p>一個方法是使用貪婪搜尋法(Greedy Search)，即先根據conditional language model來產生第一個詞，接著在後面的翻譯部份每一次再依據前個詞選取最大機率來產生下個詞。但我們實際上希望的是找到輸出翻譯結果中每個詞Yi最大的聯合機率(Joint Probability)，而不是每次都產生一個機率最大的詞，比如說法文翻譯到英文的問題中，如果前兩個字的翻譯結果開頭都是Jane is…，但是going這個字在英文上比起visiting還常見，所以用這個方法會造成第3個詞比較容易接going，但是這並不是一個最佳化的翻譯結果。但在英文可選的詞非常多，所以會使用approximate搜尋法來嘗試找到最大的條件機率。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/greedy_search.JPG\" class=\"\" width=\"500\">\n\n<p>Beam Search演算法的特性在於不會像之前一樣只找一個最大的機率，而是會存下前B個最大的機率值在記憶體裡面。比如說第1個詞已經找出是in, jane和september，再來會繼續再找出第1個詞是in的情況下，第2個是哪個詞。這時會計算出在給定輸入X且第一個詞是in之下，哪個詞的機率最大，即P(Y2|X,Y1)。再將機率乘上P(Y1|X)就可以得到給定X之下，前兩個詞的機率P(Y1,Y2|X)。然後存下前三個最大的可能性，這時可能會存下in september, jane is和jane visiting，再繼續往下找第3個詞。這時也就代表演算法認為september不會是第一個詞。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/beam_search_step2.JPG\" class=\"\" width=\"500\">\n\n<p>接著beam search再從前兩個詞的三組詞往下展開來，並找出前三個詞最大機率的三組保留，透過這個方法持續到接到結尾EOS並停止。要注意的是如果把B設定成1的話，就等同於前面介紹的Greedy Search。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/beam_search2.JPG\" class=\"\" width=\"500\">\n\n<p>有些不同的方法可以讓beam search可以得到更好的結果，其中一個是length normalization。beam search會持續連乘使得機率值變很小，這可以透過取log相加取代，因為logP(y|x)和P(y|x)兩者取最大值將會有一樣的結果。當句子很長時，可以透過改變目標函式的方法來解決這個問題。因為取log後為&lt;=1，所以當詞越多值也就會越小，一個方法是除上詞的數量來作正規化，這可以大幅的降低因為句子太長所造成的懲罰(Penalty)效果。另外為了要讓這個正規化效果更加的平滑，可以將Ty取α次方，比如說設定成0.7(1為完整的正規化，0為不作正規化)</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/length_normalization.JPG\" class=\"\" width=\"500\">\n\n<p>但B值到底該如何選擇呢？B值越大會可以留下更多的組合來找到更好的結果，但卻訓練的時間會更久，而且也會使用更多的記憶體。Andrew這邊建立在production系統B為10就可以了，但是在研究的系統上，可以取更大的B來計算不同的組合，多次作嘗試。</p>\n<p>因為翻譯問題不是像是圖像辨識一樣有正確的答案可以用accuracy來衡量，翻譯結果可能可以有多個一樣好的結果，這個時候可以使用Bleu(Biligual Evaluation Understudy) score來作訓練結果的衡量。<br/>Precision會比對機器翻譯出來的結果和人翻譯的結果，看機器翻譯的每個詞，是否都有出現在不同的答案reference中。比如果機器翻譯出來有7個詞，其中the這個詞都出現在reference中，所以precision為7/7。但這樣的計算顯然不夠精確。Modified Precision則會給予每個詞不同權重，像是the在reference 1出現2次，在reference 2出現1次，因此會給它權重為2，那邊Modified Precision將會修正2/7。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/evaluation_machine_translation.JPG\" class=\"\" width=\"500\">\n\n<p>但是衡量並不會只看單一詞的結果，比如說使用兩個詞為一組(Bigram)來作計算的話，會先透過bigram來取出所有組合，並計算每個組合在機器翻譯結果出現次數，再來計算每個組合在所有的reference中有沒有出現(1或0)，再來則將reference的數量除上機器翻譯bigram出現次數來計算 bigram的precision。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/bleu_score_bigram.JPG\" class=\"\" width=\"500\">\n\n<p>所以在使用N-gram取組合時，即可以歸納出一個公式，如果機器翻譯出來的結果和其中一組reference相同時，modified precision就會等於1。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/bleu_score_unigram.JPG\" class=\"\" width=\"500\">\n\n<p>把多個n-grams分數綜合起來，可以計算出一個綜合的分數再乘上BP。因為當機器的翻譯結果過短時，會造成大多的字存在reference中，使得modified precision會偏高，此時會引入BP(Brevity Penalty)的概念，當機器翻譯的長度比起reference還長時，BP為1即不給予懲罰分數；反之給予一個懲罰分數。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/bleu_detail.JPG\" class=\"\" width=\"500\">\n\n<p>實際上人在進行翻譯時，並不會把整段都看完再翻譯，而是先看一小段翻完再往後看另一小段。而且當句子越長時，Bleu score會逐漸降低，這時如果使用Attention Model來幫助每一小段作翻譯的話，則可以解決這個問題。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/long_sequence_problem.JPG\" class=\"\" width=\"500\">\n\n<p>雖然attention model是用在比較長的句子，但這邊使用短句來作說明。這裡encoder使用bidirectional RNN，在decoder時透過另一個RNN來完成翻譯。在產生第1個詞時會透過α來表示要產生這個詞應該要注意的資訊量有多少。接著再產生第2個詞時，會產生一組新的attention weight來表示產生第兩個詞時該注意的資訊量，並加上前一個產生的詞。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/attention_model_intuition.JPG\" class=\"\" width=\"500\">\n\n<p>在建立attention model時，encoder使用的bidirectional RNN會貢獻兩個activation值，此值即為α權重。接著在decoder產生每個Y值時會輸入C，這個C即為α值的加總，用來表示要產生的Y值需要注意多少的資料量，而這個α會取softmax確保其加總為1。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/attention_model.JPG\" class=\"\" width=\"500\">\n\n<p>所以在產生Y時主要有兩個輸入，一個是上個hidden狀態S&lt; t-1 &gt;，一個是要注意的資訊量a &lt; t’ &gt;，透過建立這個小的神經網路來使用梯度下降作訓練。但attention model的缺點就是他的計算成本較高，複雜度為Tx * Ty。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/computing_attention.JPG\" class=\"\" width=\"500\">\n\n<p>seqence to sequence可以被使用在文字的正規化，把不同型態的文字表達轉成一個相同的表示方法。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/attention_example.JPG\" class=\"\" width=\"500\">\n\n<p>語音辨識(Speech Recognition)也是一種sequence to sequence的問題，輸入一段語音後期望可以輸出一段正確的辨識結果。傳統的語音辨識方法會使用音位(Phoneme)當作基本的單位來表示語音結果，但在end to end的深度學習方法，已經不再需要使用這種方法。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/speech_recognition_problem.JPG\" class=\"\" width=\"500\">\n\n<p>一個有效的方法是使用CTC cost，語音辨識因為每秒可能有多次的取樣，所以輸入的資料會很大，光是10秒的語音就可以變成上1000的輸入，但是輸出的辨識結果並不會有上千的輸出。CTC可以協助幫輸出的結果作適當的collapse，其會對重複的字作collapse像是重複的t, e和q來產生較短的結果。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/CTC_cost.JPG\" class=\"\" width=\"500\">\n\n<p>這裡以trigger word偵測系為例來說明語音辨識問題，trigger word常被使用在一些智慧管家的產品當中，像是Google Home或是Amazon Echo。在訓練過程中會輸入語音，並在出現trigger word時的目標label設定為1，其它部份為0。</p>\n<img src=\"/2018/02/27/andrew-deep-learning-course5-week3/trigger_word.JPG\" class=\"\" width=\"500\">\n\n<p>參考資料:<br/><a href=\"https://www.coursera.org/learn/nlp-sequence-models\">Deep Learning Course 5 - Sequece Models</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Deep Learning","RNN","Attention"]},{"title":"在採用Cassandra前你必須要知道的事-CQL怎麼GROUPBY","url":"/2023/12/24/before-adopt-cassandra-you-need-to-know-cql-groupby/","content":"<p>SQL開發者絕對少不了會使用聚合函式對資料作加總、平均、計數和取大小值，而Cassandra也支援了SUM、AVG、COUNT、和MIN/MAX的聚合函式。以下用員工表範例來作說明。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- create</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> CASSANDRA.EMPLOYEE (</span><br><span class=\"line\">  deptName text,</span><br><span class=\"line\">  jobgrade text,</span><br><span class=\"line\">  empId text,</span><br><span class=\"line\">  name text,</span><br><span class=\"line\">  gender text,</span><br><span class=\"line\">  <span class=\"keyword\">primary</span> key(deptName, jobgrade, gender, empId)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- insert</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;HR&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;001&#x27;</span>, <span class=\"string\">&#x27;Tom&#x27;</span>, <span class=\"string\">&#x27;Male&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;HR&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;002&#x27;</span>, <span class=\"string\">&#x27;Amy&#x27;</span>, <span class=\"string\">&#x27;Female&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;Design&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;003&#x27;</span>, <span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;Male&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;Design&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;004&#x27;</span>, <span class=\"string\">&#x27;Alice&#x27;</span>, <span class=\"string\">&#x27;Female&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;HR&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;005&#x27;</span>, <span class=\"string\">&#x27;Mary&#x27;</span>, <span class=\"string\">&#x27;Female&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;Design&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;006&#x27;</span>, <span class=\"string\">&#x27;Henry&#x27;</span>, <span class=\"string\">&#x27;Male&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- select</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE;</span><br><span class=\"line\"></span><br><span class=\"line\">deptname <span class=\"operator\">|</span> jobgrade <span class=\"operator\">|</span> gender <span class=\"operator\">|</span> empid <span class=\"operator\">|</span> name</span><br><span class=\"line\"><span class=\"comment\">----------+----------+--------+-------+-------</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">005</span> <span class=\"operator\">|</span>  Mary</span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">001</span> <span class=\"operator\">|</span>   Tom</span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">3</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">002</span> <span class=\"operator\">|</span>   Amy</span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">004</span> <span class=\"operator\">|</span> Alice</span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">2</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">003</span> <span class=\"operator\">|</span>  John</span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">3</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">006</span> <span class=\"operator\">|</span> Henry</span><br></pre></td></tr></table></figure>\n\n<p>假設在RDBMS裡用以上建立的資料表，舉幾種查詢情境如下:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 依部門計數</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> deptname, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) </span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> deptname</span><br><span class=\"line\"></span><br><span class=\"line\">  deptname <span class=\"operator\">|</span> count</span><br><span class=\"line\"><span class=\"comment\">----------+-------</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>     <span class=\"number\">3</span></span><br><span class=\"line\">   Design <span class=\"operator\">|</span>     <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 依職等計數</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> jobgrade, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) </span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> jobgrade</span><br><span class=\"line\"></span><br><span class=\"line\"> jobgrade <span class=\"operator\">|</span> count</span><br><span class=\"line\"><span class=\"comment\">----------+-------</span></span><br><span class=\"line\">        <span class=\"number\">1</span> <span class=\"operator\">|</span>     <span class=\"number\">3</span></span><br><span class=\"line\">        <span class=\"number\">2</span> <span class=\"operator\">|</span>     <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"number\">2</span> <span class=\"operator\">|</span>     <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 依部門, 職等計數</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> deptname, jobgrade, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) </span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> deptname, jobgrade</span><br><span class=\"line\"></span><br><span class=\"line\"> deptname <span class=\"operator\">|</span> jobgrade <span class=\"operator\">|</span> count</span><br><span class=\"line\"><span class=\"comment\">----------+----------+-------</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span>     <span class=\"number\">2</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">3</span> <span class=\"operator\">|</span>     <span class=\"number\">1</span></span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span>     <span class=\"number\">1</span></span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">2</span> <span class=\"operator\">|</span>     <span class=\"number\">1</span></span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">3</span> <span class=\"operator\">|</span>     <span class=\"number\">1</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"只能用在primary-key\"><a href=\"#只能用在primary-key\" class=\"headerlink\" title=\"只能用在primary key\"></a>只能用在primary key</h4><p>如同在Cassandra查詢資料一樣，Cassandra對於使用聚合函式也是有所限制。在使用聚合函式時，只能針對被設定為primary key的欄位使用GROUP BY，也就是聚合函式只能用在被定義為partition key或是clustering key的欄位，而且嚴格限制GROUP BY的順序。以下我們看在Cassandra執行第一支CQL的結果：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 依部門計數</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> deptname, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) </span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> deptname</span><br><span class=\"line\"></span><br><span class=\"line\">  deptname <span class=\"operator\">|</span> count</span><br><span class=\"line\"><span class=\"comment\">----------+-------</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>     <span class=\"number\">3</span></span><br><span class=\"line\">   Design <span class=\"operator\">|</span>     <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">Warnings :</span><br><span class=\"line\">Aggregation query used <span class=\"keyword\">without</span> <span class=\"keyword\">partition</span> key</span><br></pre></td></tr></table></figure>\n<p>因為deptname在這張表是partition key因此這支CQL可以被執行，但同時Cassandra會附帶警告訊息，表示這個聚合查詢沒有使用partition key。原因在於Cassandra會使用partition key在cluster中存放資料，如果沒有在CQL中使用partition key當作查詢條件，CQL在執行時便會在Cassandra cluster中遍尋(Full Scan)所有的資料，這會造成效能降低與資源浪費。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 依部門計數</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> deptname, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) </span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> deptname <span class=\"operator\">=</span> <span class=\"string\">&#x27;HR&#x27;</span></span><br><span class=\"line\"> <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> deptname</span><br><span class=\"line\"></span><br><span class=\"line\"> deptname <span class=\"operator\">|</span> count</span><br><span class=\"line\"><span class=\"comment\">----------+-------</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>     <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>如果加上deptname當作查詢條件就不會出現警告訊息，這時Cassandra會直接從存放資料的node取出deptname=HR的資料作計數，而不需要遍尋整座Cassandra cluster。</p>\n<h4 id=\"必須依照primary-key順序\"><a href=\"#必須依照primary-key順序\" class=\"headerlink\" title=\"必須依照primary key順序\"></a>必須依照primary key順序</h4><p>接著我們看第二支CQL，第二支CQL在執行時會出現以下的錯誤：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 依職等計數</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> jobgrade, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) </span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> jobgrade</span><br><span class=\"line\"></span><br><span class=\"line\"> InvalidRequest: Error <span class=\"keyword\">from</span> server: code<span class=\"operator\">=</span><span class=\"number\">2200</span> [Invalid query] message<span class=\"operator\">=</span>&quot;Group by currently only support groups of columns following their declared order in the PRIMARY KEY&quot;</span><br></pre></td></tr></table></figure>\n\n<p>當在Cassandra中執行GROUP BY時，必須要依照primary key的順序，也就是deptname、jobgrade和gender這個順序，跳過deptname直接使用jobgrade或是gender作GROUP BY是不允許的。</p>\n<p>其中原因在於Cassandra使用partition key決定資料存放的位置，並在每份partion中使用clustering key決定資料的排序順序。因此如果要對沒有任何索引的非primary key欄位作分組計算，就會需要遍尋Cassandra cluster。</p>\n<p>第三支CQL因為符合partition和clustering的順序限制所以可以成功執行。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 依部門, 職等計數</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> deptname, jobgrade, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) </span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> deptname, jobgrade</span><br><span class=\"line\"></span><br><span class=\"line\"> deptname <span class=\"operator\">|</span> jobgrade <span class=\"operator\">|</span> count</span><br><span class=\"line\"><span class=\"comment\">----------+----------+-------</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span>     <span class=\"number\">2</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">3</span> <span class=\"operator\">|</span>     <span class=\"number\">1</span></span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span>     <span class=\"number\">1</span></span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">2</span> <span class=\"operator\">|</span>     <span class=\"number\">1</span></span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">3</span> <span class=\"operator\">|</span>     <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>從以上查詢範例可以發現Cassandra在使用聚合函式時會受限於資料表primary key設計，並不是所有的欄位都能使用。因此如果預期會對資料欄位作聚合函式的計算，就必須預先在建立資料表就放進primary key中。</p>\n","categories":["SQL&NoSQL"],"tags":["Cassandra","NoSQL","CQL","data aggregation"]},{"title":"在採用Cassandra前你必須要知道的事-CQL怎麼ORDERBY","url":"/2024/01/27/before-adopt-cassandra-you-need-to-know-cql-orderby/","content":"<p>SQL開發者在查詢完資料後，往往會使用ORDER BY語法對查詢結果作排序調整。Cassandra的排序是對partition中的資料作排序，而且這個排序必須在建立資料表時就先定義好，並不能在查詢時使用任意的欄位改變排序。</p>\n<p>Cassandra在建立資料表時定義的partition key決定資料存放的位置，並在每份partion中使用clustering key決定資料的排序，而且資料在寫入Cassandra時就會依據clustering key定義的欄位順序將資料排序好。</p>\n<p>以下用員工表範例來作說明：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- create</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> CASSANDRA.EMPLOYEE (</span><br><span class=\"line\">  deptName text,</span><br><span class=\"line\">  jobgrade text,</span><br><span class=\"line\">  empId text,</span><br><span class=\"line\">  name text,</span><br><span class=\"line\">  gender text,</span><br><span class=\"line\">  <span class=\"keyword\">primary</span> key(deptName, jobgrade, gender, empId)</span><br><span class=\"line\">) <span class=\"keyword\">WITH</span> CLUSTERING <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> (jobgrade <span class=\"keyword\">ASC</span>, gender <span class=\"keyword\">ASC</span>, empId <span class=\"keyword\">ASC</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- insert</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;HR&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;001&#x27;</span>, <span class=\"string\">&#x27;Tom&#x27;</span>, <span class=\"string\">&#x27;Male&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;HR&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;002&#x27;</span>, <span class=\"string\">&#x27;Amy&#x27;</span>, <span class=\"string\">&#x27;Female&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;Design&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;003&#x27;</span>, <span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;Male&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;Design&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;004&#x27;</span>, <span class=\"string\">&#x27;Alice&#x27;</span>, <span class=\"string\">&#x27;Female&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;HR&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;005&#x27;</span>, <span class=\"string\">&#x27;Mary&#x27;</span>, <span class=\"string\">&#x27;Female&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;Design&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;006&#x27;</span>, <span class=\"string\">&#x27;Henry&#x27;</span>, <span class=\"string\">&#x27;Male&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- select</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE;</span><br><span class=\"line\"></span><br><span class=\"line\">deptname <span class=\"operator\">|</span> jobgrade <span class=\"operator\">|</span> gender <span class=\"operator\">|</span> empid <span class=\"operator\">|</span> name</span><br><span class=\"line\"><span class=\"comment\">----------+----------+--------+-------+-------</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">005</span> <span class=\"operator\">|</span>  Mary</span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">001</span> <span class=\"operator\">|</span>   Tom</span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">3</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">002</span> <span class=\"operator\">|</span>   Amy</span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">004</span> <span class=\"operator\">|</span> Alice</span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">2</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">003</span> <span class=\"operator\">|</span>  John</span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">3</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">006</span> <span class=\"operator\">|</span> Henry</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在建立資料表時決定資料排序\"><a href=\"#在建立資料表時決定資料排序\" class=\"headerlink\" title=\"在建立資料表時決定資料排序\"></a>在建立資料表時決定資料排序</h4><p>從以上的範例可以看到定義的clustering key包含了jobgrade、gender和empId，也可以發現資料查詢出來預設就會依照這三個欄位排序。因為Cassandra在執行資料寫入時，就已經將排序完成了，所以查詢出來就是排序後的結果。<br>像是HR部門的資料，雖然有一筆jobgrade為1的資料後來才寫入，但仍然會被排序在jobgrade為3的資料前面。</p>\n<p>我們可以嘗試再寫入一筆測試看看：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;Design&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;007&#x27;</span>, <span class=\"string\">&#x27;Grace&#x27;</span>, <span class=\"string\">&#x27;Female&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE <span class=\"keyword\">WHERE</span> deptname <span class=\"operator\">=</span> <span class=\"string\">&#x27;Design&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> deptname <span class=\"operator\">|</span> jobgrade <span class=\"operator\">|</span> gender <span class=\"operator\">|</span> empid <span class=\"operator\">|</span> name</span><br><span class=\"line\"><span class=\"comment\">----------+----------+--------+-------+-------</span></span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">004</span> <span class=\"operator\">|</span> Alice</span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">2</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">007</span> <span class=\"operator\">|</span> Grace</span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">2</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">003</span> <span class=\"operator\">|</span>  John</span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">3</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">006</span> <span class=\"operator\">|</span> Henry</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>從上面新增的資料和查詢結果，可以發現這筆資料先依jobgrade被排序在1和3中間，再依gender排序在Male前面。</p>\n<h4 id=\"ORDER-BY的使用限制\"><a href=\"#ORDER-BY的使用限制\" class=\"headerlink\" title=\"ORDER BY的使用限制\"></a>ORDER BY的使用限制</h4><p>也因為Cassandra的特性，在下CQL查詢時使用ORDER BY時會有以下幾個限制:</p>\n<ol>\n<li>ORDER BY只能支援partition key有給定的情況</li>\n<li>ORDER BY的欄位必須被定義在clustering key中</li>\n<li>ORDER BY的欄位順序必須符合clustering key定義的順序</li>\n<li>ORDER BY的欄位正/逆排方向必須和clustering key定義的欄位正/逆排方向一致</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 對HR部門的職等作逆排序</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> deptname <span class=\"operator\">=</span> <span class=\"string\">&#x27;HR&#x27;</span> <span class=\"comment\">-- 符合限制1</span></span><br><span class=\"line\"> <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> jobgrade <span class=\"keyword\">DESC</span>; <span class=\"comment\">-- 符合限制2</span></span><br><span class=\"line\"></span><br><span class=\"line\"> deptname <span class=\"operator\">|</span> jobgrade <span class=\"operator\">|</span> gender <span class=\"operator\">|</span> empid <span class=\"operator\">|</span> name</span><br><span class=\"line\"><span class=\"comment\">----------+----------+--------+-------+------</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">3</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">002</span> <span class=\"operator\">|</span>  Amy</span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">001</span> <span class=\"operator\">|</span>  Tom</span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">005</span> <span class=\"operator\">|</span> Mary</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"必須依照clustering-key順序\"><a href=\"#必須依照clustering-key順序\" class=\"headerlink\" title=\"必須依照clustering key順序\"></a>必須依照clustering key順序</h5><p>Cassandra可以將原本定義好的排序在查詢時轉向，因此會將資料依jobgrade改成從大到小排序。又因為資料已經依clustering key的欄位順序與方向關係儲存下來了，所以gender和empid會連帶隨jobgrade的排序轉向而一起轉向。</p>\n<p>接著再來看下面這支CQL，如果不依clustering key定義的欄位順序排序會發生什麼事：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 對HR部門的員工編號與性別逆排序</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> deptname <span class=\"operator\">=</span> <span class=\"string\">&#x27;HR&#x27;</span> <span class=\"comment\">-- 符合限制1</span></span><br><span class=\"line\"> <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> empid <span class=\"keyword\">DESC</span>, gender <span class=\"keyword\">DESC</span>; <span class=\"comment\">-- 違反限制2&amp;3 (跳過jobgrade且欄位順序不符)</span></span><br><span class=\"line\"></span><br><span class=\"line\">InvalidRequest: Error <span class=\"keyword\">from</span> server: code<span class=\"operator\">=</span><span class=\"number\">2200</span> [Invalid query] message<span class=\"operator\">=</span>&quot;Order by currently only supports the ordering of columns following their declared order in the PRIMARY KEY&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> deptname <span class=\"operator\">=</span> <span class=\"string\">&#x27;HR&#x27;</span> <span class=\"comment\">-- 符合限制1</span></span><br><span class=\"line\">   <span class=\"keyword\">AND</span> jobgrade <span class=\"operator\">=</span> <span class=\"string\">&#x27;1&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> gender <span class=\"keyword\">DESC</span>, empid <span class=\"keyword\">DESC</span>;  <span class=\"comment\">-- 符合限制2&amp;3 (已綁定jobgrade且剩下欄位順序正確)</span></span><br><span class=\"line\"></span><br><span class=\"line\"> deptname <span class=\"operator\">|</span> jobgrade <span class=\"operator\">|</span> gender <span class=\"operator\">|</span> empid <span class=\"operator\">|</span> name</span><br><span class=\"line\"><span class=\"comment\">----------+----------+--------+-------+------</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">001</span> <span class=\"operator\">|</span>  Tom</span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">005</span> <span class=\"operator\">|</span> Mary</span><br></pre></td></tr></table></figure>\n\n<p>如果想對員工編號與性別作逆排序，這時會違反clustering key的順序，就會看到Cassandra跳出Order by只支援PRIMARY KEY宣告的欄位順序的錯誤訊息。因為Cassandra在建立資料表時就已經決定好資料儲存的順序，除非對前面順序的clustering key下filter否則不能跳過，並且排序的欄位順序須符合clustering key的定義。</p>\n<h5 id=\"必須符合clustering-key排序方向\"><a href=\"#必須符合clustering-key排序方向\" class=\"headerlink\" title=\"必須符合clustering key排序方向\"></a>必須符合clustering key排序方向</h5><p>接著再來看下面這支CQL，如果欄位正/逆排方向和clustering key定義的欄位正/逆排方向不一致會發生什麼事：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> deptname <span class=\"operator\">=</span> <span class=\"string\">&#x27;HR&#x27;</span> <span class=\"comment\">-- 符合限制1</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> jobgrade <span class=\"keyword\">DESC</span>, gender <span class=\"keyword\">ASC</span>, empid <span class=\"keyword\">DESC</span>;  <span class=\"comment\">-- 符合限制2&amp;3但違反限制4</span></span><br><span class=\"line\"></span><br><span class=\"line\">InvalidRequest: Error <span class=\"keyword\">from</span> server: code<span class=\"operator\">=</span><span class=\"number\">2200</span> [Invalid query] message<span class=\"operator\">=</span>&quot;Unsupported order by relation&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> deptname <span class=\"operator\">=</span> <span class=\"string\">&#x27;HR&#x27;</span> <span class=\"comment\">-- 符合限制1</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> jobgrade <span class=\"keyword\">DESC</span>, gender <span class=\"keyword\">DESC</span>, empid <span class=\"keyword\">DESC</span>;  <span class=\"comment\">-- 符合限制2&amp;3&amp;4</span></span><br><span class=\"line\"></span><br><span class=\"line\"> deptname <span class=\"operator\">|</span> jobgrade <span class=\"operator\">|</span> gender <span class=\"operator\">|</span> empid <span class=\"operator\">|</span> name</span><br><span class=\"line\"><span class=\"comment\">----------+----------+--------+-------+------</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">3</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">002</span> <span class=\"operator\">|</span>  Amy</span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">001</span> <span class=\"operator\">|</span>  Tom</span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">005</span> <span class=\"operator\">|</span> Mary</span><br></pre></td></tr></table></figure>\n\n<p>因為建資料表時已經決定每個欄位的排序方向組合，因為在查詢時如果要作排序轉向，就必須要滿足每個欄位的方向都作轉向。以這個資料表為例，三個欄位宣告為ASC，在排序轉向時就必須都要是DESC，否則Cassandra是無法把順序排出來的。</p>\n<p>如果排序結果又沒辦法透過CQL達成的話，只能重建新的資料表，或是將資料表讀進程式裡面再作排序了。</p>\n<p>為了讓資料查詢的速度可以提升，Cassandra嚴格限制資料排序都必須要預先設計與定義，即查詢出來就是排序好的結果，而不是在查詢時才作排序。正因為Cassandra的data modeling是query-driven的，必須先分析未來資料查詢的需求包含查詢欄位、排序順序，這可能會和RDBMS的使用經驗不同，也是在使用Cassandra前必須要有的思維轉換。</p>\n<p>參考資料: </p>\n<p><a href=\"https://cassandra.apache.org/doc/stable/cassandra/data_modeling/data_modeling_rdbms.html#sorting-is-a-design-decision\">Cassandra Data Modeling - Sorting is a design decision</a></p>\n<p><a href=\"https://docs.datastax.com/en/dse/6.7/cql/cql/cql_reference/cql_commands/cqlSelect.html#cqlSelect__compound-primary-keys\">DataStax document - Using compound primary keys and sorting results</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=svoI3ytd-TQ\">Dear DataStax Episode 18: How can you order by any field in Cassandra?</a></p>\n","categories":["SQL&NoSQL"],"tags":["Cassandra","NoSQL","CQL","Sorting"]},{"title":"在採用Cassandra前你必須要知道的事-CQL不是SQL","url":"/2023/11/11/before-adopt-cassandra-you-need-to-know-cql/","content":"<p>過去兩年的時間投入了數據平台的建置，希望可以打造一個所謂的現代化數據平台(Modern Data Platform)，這中間可是比想像中困難多了。但兩年過去了團隊成員從也是從小貓幾隻，一路成長到十多人的團隊。講到現代化的數據平台，NoSQL的儲存方案肯定是會被考量到的一項技術，在一陣研究和討論後，我們決定採用Cassandra當作在數據平台服務中，擔任NoSQL的主要儲存技術。</p>\n<p>在導入的過程中當然沒有這麼順利，特別是對於只用過Oracle或是SQL Server等RDBMS技術，完全沒有碰過NoSQL的開發團隊，大家對於使用Cassandra總是有錯誤的想像，或是在不熟悉與不合適的使用情境下，最後造成大家與Cassandra「不歡而散」。</p>\n<p>這篇想開始談談實際使用Cassandra後會因為Cassandra的設計限制遇到的問題，希望大家在一頭熱投入Cassandra的研究前，可以評估使用情境是否適合。我特別推薦在準備DataStax的Cassandra Developer Certification時上到的一堂課，這堂<a href=\"https://www.youtube.com/watch?v=jYvKiewV-5Q&list=PL2g2h-wyI4SqIigskyJNAeL2vSTJZU_Qp\">DS220</a>提到許多Cassandra在實在作data modeling會需要知道的技巧和特性。</p>\n<p>回到這次想談的，CQL不是SQL。</p>\n<p>在初期投入Cassandra技術評估，看到Cassandra支援CQL(Cassandra Query Language)時，肯定會讓RDBMS開發者眼睛一亮，這看起來多麼的熟悉，忍不住在比較NoSQL方案時在Cassandra蓋上一個優勝的章。當然我不能否認當初我們也這麼認為，一直到大家實際使用時，才會發現CQL和SQL有根本上的不同。</p>\n<h4 id=\"不是任意欄位都能FILTER\"><a href=\"#不是任意欄位都能FILTER\" class=\"headerlink\" title=\"不是任意欄位都能FILTER\"></a>不是任意欄位都能FILTER</h4><p>簡單來說，比起RDBMS的SQL查詢，Cassandra因為本身的設計，所以CQL本來就只能作到有限度的查詢。CQL不能像SQL一樣可以將任意欄位放在where條件執行查詢，而是只能針對設定成partition key和clustering key的欄位進行查詢，甚至對組成clustering key的欄位，還有查詢順序的限制。當然這裡我們就先不提建立secondary index或是materialize view的情況。</p>\n<p>拿下面這個簡單的員工資料表來說明。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">deptname</th>\n<th align=\"right\">jobgrade</th>\n<th align=\"right\">gender</th>\n<th align=\"right\">emplid</th>\n<th align=\"center\">name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">HR</td>\n<td align=\"right\">1</td>\n<td align=\"right\">Male</td>\n<td align=\"right\">001</td>\n<td align=\"center\">Tom</td>\n</tr>\n<tr>\n<td align=\"left\">HR</td>\n<td align=\"right\">3</td>\n<td align=\"right\">Female</td>\n<td align=\"right\">002</td>\n<td align=\"center\">Amy</td>\n</tr>\n<tr>\n<td align=\"left\">Design</td>\n<td align=\"right\">2</td>\n<td align=\"right\">Male</td>\n<td align=\"right\">003</td>\n<td align=\"center\">John</td>\n</tr>\n<tr>\n<td align=\"left\">Design</td>\n<td align=\"right\">1</td>\n<td align=\"right\">Female</td>\n<td align=\"right\">004</td>\n<td align=\"center\">Alice</td>\n</tr>\n<tr>\n<td align=\"left\">HR</td>\n<td align=\"right\">1</td>\n<td align=\"right\">Male</td>\n<td align=\"right\">005</td>\n<td align=\"center\">Bob</td>\n</tr>\n<tr>\n<td align=\"left\">Design</td>\n<td align=\"right\">3</td>\n<td align=\"right\">Male</td>\n<td align=\"right\">006</td>\n<td align=\"center\">Henry</td>\n</tr>\n</tbody></table>\n<p>在Cassandra的員工表作了以下設計，如果不說是Cassandra的話，看起來其實就和一般的RDBMS沒有差別。但在Cassandra中下面建立的員工表其實隱含了將deptName設定為partition key，clustering key設定為jobgrade、gender和emplid的意思。以下的語法可以把這個範例建起來，<a href=\"https://astra.datastax.com/\">DataStax</a>有提供線上的serverless database可以使用。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- create</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> CASSANDRA.EMPLOYEE (</span><br><span class=\"line\">  deptName text,</span><br><span class=\"line\">  jobgrade text,</span><br><span class=\"line\">  empId text,</span><br><span class=\"line\">  name text,</span><br><span class=\"line\">  gender text,</span><br><span class=\"line\">  <span class=\"keyword\">primary</span> key(deptName, jobgrade, gender, empId)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- insert</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;HR&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;001&#x27;</span>, <span class=\"string\">&#x27;Tom&#x27;</span>, <span class=\"string\">&#x27;Male&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;HR&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;002&#x27;</span>, <span class=\"string\">&#x27;Amy&#x27;</span>, <span class=\"string\">&#x27;Female&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;Design&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;003&#x27;</span>, <span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;Male&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;Design&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;004&#x27;</span>, <span class=\"string\">&#x27;Alice&#x27;</span>, <span class=\"string\">&#x27;Female&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;HR&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;005&#x27;</span>, <span class=\"string\">&#x27;Mary&#x27;</span>, <span class=\"string\">&#x27;Female&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CASSANDRA.EMPLOYEE(deptName,jobgrade,empId,name,gender) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;Design&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;006&#x27;</span>, <span class=\"string\">&#x27;Henry&#x27;</span>, <span class=\"string\">&#x27;Male&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- select</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE;</span><br><span class=\"line\"></span><br><span class=\"line\">deptname <span class=\"operator\">|</span> jobgrade <span class=\"operator\">|</span> gender <span class=\"operator\">|</span> empid <span class=\"operator\">|</span> name</span><br><span class=\"line\"><span class=\"comment\">----------+----------+--------+-------+-------</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">005</span> <span class=\"operator\">|</span>  Mary</span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">001</span> <span class=\"operator\">|</span>   Tom</span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">3</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">002</span> <span class=\"operator\">|</span>   Amy</span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">004</span> <span class=\"operator\">|</span> Alice</span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">2</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">003</span> <span class=\"operator\">|</span>  John</span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">3</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">006</span> <span class=\"operator\">|</span> Henry</span><br></pre></td></tr></table></figure>\n<p>假設在RDBMS裡用以上建立的資料表，舉幾種查詢情境如下:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查詢jobgrade為1的員工資料</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> </span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> jobgrade <span class=\"operator\">=</span> <span class=\"string\">&#x27;1&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">deptname <span class=\"operator\">|</span> jobgrade <span class=\"operator\">|</span> gender <span class=\"operator\">|</span> empid <span class=\"operator\">|</span> name</span><br><span class=\"line\"><span class=\"comment\">----------+----------+--------+-------+-------</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">001</span> <span class=\"operator\">|</span>   Tom</span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">005</span> <span class=\"operator\">|</span>  Mary</span><br><span class=\"line\">   Design <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">004</span> <span class=\"operator\">|</span> Alice</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查詢deptname為HR, gender為Male的名字</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> name </span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> deptname <span class=\"operator\">=</span> <span class=\"string\">&#x27;HR&#x27;</span></span><br><span class=\"line\">   <span class=\"keyword\">AND</span> gender <span class=\"operator\">=</span> <span class=\"string\">&#x27;Male&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> name</span><br><span class=\"line\"><span class=\"comment\">------</span></span><br><span class=\"line\">  Tom</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">--查詢deptname為HR, jobgrade為1的員工資料 </span></span><br><span class=\"line\"> <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> deptname <span class=\"operator\">=</span> <span class=\"string\">&#x27;HR&#x27;</span></span><br><span class=\"line\">   <span class=\"keyword\">AND</span> jobgrade <span class=\"operator\">=</span> <span class=\"string\">&#x27;1&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> deptname <span class=\"operator\">|</span> jobgrade <span class=\"operator\">|</span> gender <span class=\"operator\">|</span> empid <span class=\"operator\">|</span> name</span><br><span class=\"line\"><span class=\"comment\">----------+----------+--------+-------+------</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">005</span> <span class=\"operator\">|</span> Mary</span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">001</span> <span class=\"operator\">|</span>  Tom</span><br></pre></td></tr></table></figure>\n\n<p>以上看起來很直覺的查詢，如果是在Cassandra的世界裡，執行第一支CQL會得到以下的錯誤：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> </span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> jobgrade <span class=\"operator\">=</span> <span class=\"string\">&#x27;1&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">InvalidRequest: Error <span class=\"keyword\">from</span> server: code<span class=\"operator\">=</span><span class=\"number\">2200</span> [Invalid query] message<span class=\"operator\">=</span>&quot;Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING&quot;</span><br></pre></td></tr></table></figure>\n\n<p>Cassandra會將資料依partitiony key分散放到不同的partition存放，所以在CQL查詢中的第一個條件必須要帶partition key(也就是deptname)，Cassandra才能直接到指定的partition取回資料，用來加速資料查詢的速度。因此在不給定partition key條件下直接用jobgrade作filter是不允許的。</p>\n<p>第二支CQL執行則會得到以下的錯誤：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> name </span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> deptname <span class=\"operator\">=</span> <span class=\"string\">&#x27;HR&#x27;</span></span><br><span class=\"line\">   <span class=\"keyword\">AND</span> gender <span class=\"operator\">=</span> <span class=\"string\">&#x27;Male&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">InvalidRequest: Error <span class=\"keyword\">from</span> server: code<span class=\"operator\">=</span><span class=\"number\">2200</span> [Invalid query] message<span class=\"operator\">=</span>&quot;PRIMARY KEY column &quot;gender&quot; cannot be restricted as preceding column &quot;jobgrade&quot; is not restricted&quot;</span><br></pre></td></tr></table></figure>\n\n<p>因為Cassandra的世界裡，會將一個partition內部的資料依據clustering key作排序。以員工資料表為例，會以deptname切partition後，再依序用jobgrade、gender和emplid排序。</p>\n<p>Casssandra透過預先排序的方式，在查詢資料時就可以得到排序結果，和SQL查詢完才作order by不同。因此Cassandra嚴格限制clustering key的欄位必須要依順序作filter，所以跳過jobgrade先查詢gender是不允許的。</p>\n<p>第三支CQL則因為符合partition和clustering限制所以可以成功執行。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> CASSANDRA.EMPLOYEE</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> deptname <span class=\"operator\">=</span> <span class=\"string\">&#x27;HR&#x27;</span></span><br><span class=\"line\">   <span class=\"keyword\">AND</span> jobgrade <span class=\"operator\">=</span> <span class=\"string\">&#x27;1&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> deptname <span class=\"operator\">|</span> jobgrade <span class=\"operator\">|</span> gender <span class=\"operator\">|</span> empid <span class=\"operator\">|</span> name</span><br><span class=\"line\"><span class=\"comment\">----------+----------+--------+-------+------</span></span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span> Female <span class=\"operator\">|</span>   <span class=\"number\">005</span> <span class=\"operator\">|</span> Mary</span><br><span class=\"line\">       HR <span class=\"operator\">|</span>        <span class=\"number\">1</span> <span class=\"operator\">|</span>   Male <span class=\"operator\">|</span>   <span class=\"number\">001</span> <span class=\"operator\">|</span>  Tom</span><br></pre></td></tr></table></figure>\n\n<p>由以上可以發現，CQL雖然和SQL語法非常相似，但本質上Cassandra就是NoSQL資料庫，也有本身的設計限制。因此對於SQL使用者來說，千萬不要因為看到很像SQL的語法，就覺得可以很容易的上手使用！</p>\n","categories":["SQL&NoSQL"],"tags":["Cassandra","NoSQL","CQL"]},{"title":"在採用Cassandra前你必須要知道的事-沒有JOIN","url":"/2024/02/28/before-adopt-cassandra-you-need-to-know-no-join/","content":"<p>關聯式資料庫的使用者在使用Cassandra設計資料模型時，通常第一個會遇到的問題就是不能使用join。Cassandra明確說明不支援join，建議的方式為建立一個反正規化(Denormalization)的資料表。</p>\n<h4 id=\"什麼叫反正規化-Denormalization\"><a href=\"#什麼叫反正規化-Denormalization\" class=\"headerlink\" title=\"什麼叫反正規化(Denormalization)\"></a>什麼叫反正規化(Denormalization)</h4><p>有別於關聯式資料庫的正規化(Normalization)設計，透過減少資料庫內的資料冗餘(Data Redundancy)和去除相依性來增進資料的一致性。這種方式的缺點在當資料被拆成多個資料表後，依不同使用情境下將資料join起來查詢時，會導致效能不佳。</p>\n<p>而反正規化則是相反，反正規化會增加資料冗餘或是對資料進行分組，來得到最佳化的讀取效能。所以在反正規化的實例中，會把預先join完的資料建成一張資料表，這時就會有同一份資料被複製成多張資料表的情況。</p>\n<h4 id=\"怎麼將反正規化應用在資料設計\"><a href=\"#怎麼將反正規化應用在資料設計\" class=\"headerlink\" title=\"怎麼將反正規化應用在資料設計\"></a>怎麼將反正規化應用在資料設計</h4><h5 id=\"關聯式資料庫正規化設計\"><a href=\"#關聯式資料庫正規化設計\" class=\"headerlink\" title=\"關聯式資料庫正規化設計\"></a>關聯式資料庫正規化設計</h5><p>舉DataStax的課程<a href=\"https://www.youtube.com/playlist?list=PL2g2h-wyI4SqIigskyJNAeL2vSTJZU_Qp\">DS220.08</a>範例來說明。這個範例為電影資料庫被設計成videos、users和comments三張資料表。</p>\n<img src=\"/2024/02/28/before-adopt-cassandra-you-need-to-know-no-join/typical_relational_structure.png\" class=\"\" width=\"500\">\n\n<p>如果想要依電影標題查詢評論時，可以使用videos的id和comments的video_id將兩張表join起來，這時就可以使用videos的title欄位查詢出對應的comment資訊。</p>\n<img src=\"/2024/02/28/before-adopt-cassandra-you-need-to-know-no-join/query_comment_by_video.png\" class=\"\" width=\"500\">\n\n<p>如果要依會員帳號查詢評論時，則是使用users的id和comments的user_id將兩張表join起來，接著就可以使用users的login欄位查詢出該會員帳號留過的評論。</p>\n<img src=\"/2024/02/28/before-adopt-cassandra-you-need-to-know-no-join/query_comment_by_user.png\" class=\"\" width=\"500\">\n\n<h5 id=\"Cassandra反正規化設計\"><a href=\"#Cassandra反正規化設計\" class=\"headerlink\" title=\"Cassandra反正規化設計\"></a>Cassandra反正規化設計</h5><p>在Cassandra的反正規化資料模型設計會直接建立成兩張資料表，並透過不同的primary key來提供兩種查詢方式。第一張comments_by_video會將video_title設定成partition key，第二張comments_by_user會將user_login設計成partition key。</p>\n<img src=\"/2024/02/28/before-adopt-cassandra-you-need-to-know-no-join/denormalizing_for_query_performance.png\" class=\"\" width=\"500\">\n\n<p>因為Cassandra會使用partition key決定存放資料的位置，因為在作Cassandra的資料模型設計時，要查詢的欄位都必須被設計成partition key才能達到最佳的查詢效能。以這個例子來說，這兩張表的建立資料表指令如下，可以看的出來兩張資料表幾乎有共通的欄位，只差在partition key的設計不同。</p>\n<img src=\"/2024/02/28/before-adopt-cassandra-you-need-to-know-no-join/denormalizing_for_query_performance2.png\" class=\"\" width=\"500\">\n\n<p>這就是反正規化中對資料作pre-join並且會將資料複製成多張資料表的作法。而目的就是為了要讓查詢的效能可以最佳化，不需要在查詢時面對可能不可控的join結果，或是複雜的join行為帶來的查詢效能低落。</p>\n<p><a href=\"https://cassandra.apache.org/doc/stable/cassandra/data_modeling/data_modeling_rdbms.html#no-joins\">Cassandra Data Modeling - No Join</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=PcH9b0janp0\">DS220.08 Denormalization</a></p>\n","categories":["SQL&NoSQL"],"tags":["Cassandra","NoSQL","denormalization","no join"]},{"title":"Flutter Web Migration - 使用conditional import處理跨平台功能","url":"/2021/09/11/flutter-from-mobile-to-web-migration-tips-conditional-import/","content":"<p>上一篇有提到真的有重要的功能不支援web的情況下，可以採用conditional import的方式，在不同平台運行不同的程式片段，避免使用過多的平台判斷邏輯造成程式碼過長，或是在compile階段出現error。</p>\n<p>假設今天要實作一個platform判斷邏輯，因為我們已經知道web平台不支援dart:io，且其他的平台(ios, android等)都可以用dart:io.Platform。所以設計的邏輯為，當dart:io能被使用時採用dart:io.Platform判斷運行平台，否則即判定為web。</p>\n<p>首先可以先作一個簡單的列舉項目PlatformType，用來比較platform判斷結果。接著設計一個PlatformCheck類別，並實作類似dart:io的isPlatform檢查。而checkPlatform函式會實作在拆出去的platform_web或platform_io兩個dart裡面。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// platform_type.dart</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;platform_web.dart&#x27;</span> <span class=\"keyword\">if</span> (dart.<span class=\"keyword\">library</span>.io) <span class=\"string\">&#x27;platform_io.dart&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> PlatformType &#123;</span><br><span class=\"line\">  WEB,</span><br><span class=\"line\">  ANDROID,</span><br><span class=\"line\">  IOS</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlatformCheck</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> isWeb() =&gt; checkPlatform() == PlatformType.WEB;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> isAndroid() =&gt; checkPlatform() == PlatformType.ANDROID;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> isIos() =&gt; checkPlatform() == PlatformType.IOS;</span><br><span class=\"line\">  <span class=\"comment\">// ...other platform</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回頭看開頭的conditional import，我們想到達成的效果為，如果可以使用dart.library.io的話就import platform_io.dart，不行的話則import platform_web.dart。</p>\n<p>所以只要分別在platform_io.dart實作非web平台的checkPlatform函式，接著在platform_web.dart實作web平台的checkPlatform函式即可。<br>如果今天app是運行在可以使用dart:io的非web平台上，platform_io.dart就會被import進來，接著就可以在checkPlatform裡面實作使用dart:io.Platform的平台判斷邏輯。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// platform_io.dart</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;dart:io&#x27;</span> <span class=\"keyword\">show</span> Platform;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:webapp/platform_type.dart&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">PlatformType checkPlatform() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Platform.isIOS) <span class=\"keyword\">return</span> PlatformType.IOS;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Platform.isAndroid) <span class=\"keyword\">return</span> PlatformType.ANDROID;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> PlatformType.IOS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果app是運行在不能使用dart:io的web平台上，會變成import platform_web.dart，因為目前只有web平台無法使用dart:io，所以如果是web情況下checkPlatform就不作其他的邏輯判斷，直接回傳是web。</p>\n<p>到這裡可以再往回看一次，如果是運行在web平台上，在程式compile時就完全不會import到platform_io.dart，可以避免在web平台上import dart:io造成的compile錯誤。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// platform_web.dart</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:webapp/platform_type.dart&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">PlatformType checkPlatform() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> PlatformType.WEB;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最後只要import自己寫的platform_type.dart，就可以用以下的語法達成跨平台的platform檢查。如果今天app是運行在web之下，就會回傳web。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> currPlatform = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (PlatformCheck.isWeb()) currPlatform = <span class=\"string\">&#x27;Web&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (PlatformCheck.isAndroid()) currPlatform = <span class=\"string\">&#x27;Android&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (PlatformCheck.isIos()) currPlatform = <span class=\"string\">&#x27;iOS&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; WEB</span><br></pre></td></tr></table></figure>\n\n<p>如果專案在考量到web平台下，勢必會遇一個功能在不同的平台上要運行不同的package或是程式片段的跨平台問題。比起使用多個if-else的platform判斷邏輯，再把所有程式碼都寫進每個if-else中，使用conditaional import的方式可以有效的規劃程式碼，也可以避免import到平台不支援的package造成的compile錯誤。</p>\n<p>參考資料:<br><a href=\"https://medium.com/flutter-community/conditional-imports-across-flutter-and-web-4b88885a886e\">Conditional imports across Flutter and Web</a></p>\n","categories":["Flutter"],"tags":["Flutter","Flutter Web","Flutter Web Migration","Conditional Import"]},{"title":"Flutter Web Migration - Package跨平台兼容性","url":"/2021/08/07/flutter-from-mobile-to-web-migration-tips-package-compatibility/","content":"<p>打開Flutter web開發的方法並不困難，但在將手機app轉換(migration)到web app時會遇到許多轉換問題。在Flutter Engage的發佈會上官方有特別展示<a href=\"https://www.youtube.com/watch?v=HAstl_NkXl0\">web migration</a>要注意的地方。而使用Flutter開發跨平台應用程式時，第一個要考量到的就是package的跨平台兼容性。</p>\n<h4 id=\"使用pub-dev確認package兼容性\"><a href=\"#使用pub-dev確認package兼容性\" class=\"headerlink\" title=\"使用pub.dev確認package兼容性\"></a>使用pub.dev確認package兼容性</h4><p>為了確保使用到的package在所有的平台都能正常的執行，專案在評估採用package時就必須確認是否兼容所有要發佈的平台，或是未來可能會發佈的平台。</p>\n<p>剛起頭的專案在pub.dev尋找可採用的package時，就可以邊從資訊頁上方找到平台支援資訊。如果是從mobile轉移到web，就建議要掃過所有使用到的package，當然也可以直接把web app在debug模式跑起來就知道哪些不能用了。</p>\n<img src=\"/2021/08/07/flutter-from-mobile-to-web-migration-tips-package-compatibility/pubdev.jpg\" class=\"\" width=\"500\"> \n\n<h4 id=\"dart-io不支援web的解決方法\"><a href=\"#dart-io不支援web的解決方法\" class=\"headerlink\" title=\"dart:io不支援web的解決方法\"></a>dart:io不支援web的解決方法</h4><p>dart:io可以協助處理File、Socket、HTTP與其他I/O任務，官方的<a href=\"https://flutter.dev/docs/development/platform-integration/web#can-i-use-dartio-with-a-web-app\">Web FAQ</a>和<a href=\"https://api.dart.dev/stable/2.13.4/dart-io/dart-io-library.html\">dart:io api</a>都有特別寫到dart:io是不支援web app的。自己的經驗有遇過以下兩種情況有使用到dart:io須要特別注意：</p>\n<h5 id=\"1-使用http處理http-request\"><a href=\"#1-使用http處理http-request\" class=\"headerlink\" title=\"1. 使用http處理http request\"></a>1. 使用http處理http request</h5><p>有些專案會使用dart:io的<a href=\"https://api.dart.dev/stable/2.13.4/dart-io/HttpClient-class.html\">HttpClient</a>處理跟Http server之間的request與response。但因為dart:io不支援web平台，所以<a href=\"https://flutter.dev/docs/development/data-and-backend/networking\">官方建議</a>使用<a href=\"https://pub.dev/packages/http\">http</a>進行跨平台的http處理，在開發時也可以參考官方的<a href=\"https://flutter.dev/docs/cookbook#networking\">Networking Cookbook</a>有詳細的介紹。</p>\n<h5 id=\"2-使用universal-platform檢查運行平台\"><a href=\"#2-使用universal-platform檢查運行平台\" class=\"headerlink\" title=\"2. 使用universal_platform檢查運行平台\"></a>2. 使用universal_platform檢查運行平台</h5><p>一般跨平台專案會使用dart:io.Platform判斷當前的運行平台，但dart:io.Platform並不支援web，所以在運行於web環境時會出現Unsupported operation: Platfor._operationSystem錯誤。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;dart:io&#x27;</span> <span class=\"keyword\">show</span> Platform;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (Platform.isAndroid) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Do something on Android</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Platform.isIOS) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Do something on iOS</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// I want do something on web, but I only get Unsupported operation: Platform._operatingSystem</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>考量到web的情境下，另一個方法可以使用kIsWeb再搭配Theme.of與TargetPlatform就可以達到避開使用dart:io.Platform又能夠在建立widget時判斷當下的運行平台。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:flutter/foundation.dart&#x27;</span> <span class=\"keyword\">show</span> kIsWeb, TargetPlatform;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> platform = Theme.of(context).platform;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (kIsWeb) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Do something on Web</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (platform == TargetPlatform.android) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Do something on Android</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (platform == TargetPlatform.iOS) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Do something on iOS</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但比較適合的方法為採用<a href=\"/2021/09/11/flutter-from-mobile-to-web-migration-tips-conditional-import/\">conditional import</a>來解決。當dart:io能被import時採用dart:io.Platform判斷運行平台，無法被import的情況下判定為web。這種方式因為已經有被實作過了(<a href=\"https://pub.dev/packages/universal_platform\">universal_platform</a>)，所以可以考慮不用再自己實作。</p>\n<h4 id=\"使用conditional-import在不同平台上運行不同程式片段\"><a href=\"#使用conditional-import在不同平台上運行不同程式片段\" class=\"headerlink\" title=\"使用conditional import在不同平台上運行不同程式片段\"></a>使用<a href=\"/2021/09/11/flutter-from-mobile-to-web-migration-tips-conditional-import/\">conditional import</a>在不同平台上運行不同程式片段</h4><p>如果真的有一個重要的功能，但又不支援web該怎麼辦？像是上面提到只在mobile使用dart:io判斷運行平台，或是須要在mobile上用dart:io的HttpClient處理proxy問題，然後在web單純使用http處理與server的溝通。</p>\n<p>若無法確保package跨平台兼容，相同feature在不同平台上要執行不同程式片段時，較簡單的方法是使用上述提到的平台判斷。例如使用universal_platform判斷當下運行的平台後，再執行於不同平台要執行的函式或是widget。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:universal_platform/universal_platform.dart&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;dart:js&#x27;</span> <span class=\"comment\">// web platform need this, but it will cause Not Found Error on Android/iOS</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (UniversalPlatform.isWeb) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Do something or render widget on Web</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (UniversalPlatform.isAndroid) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Do something or render widget on Android</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (UniversalPlatform.isIOS) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Do something or render widget on iOS</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但如果功能複雜度高且程式碼又很長的話，程式片段會變很長易讀性也會變差。另外若使用到只有web能用的package，也會造成在其他平台compile階段出現錯誤。這時會建議將不同平台要執行的程式片段拆成不同dart，並使用<a href=\"/2021/09/11/flutter-from-mobile-to-web-migration-tips-conditional-import/\">conditional import</a>在開頭就決定要import哪個dart進來使用。</p>\n<blockquote>\n<p>import “web_support_func.dart” if (dart.library.io) “non_web_support_func.dart”</p>\n</blockquote>\n<p>以上是進行web migration馬上會遇到的跨平台兼容問題，除了專案本身使用到的第三方package可能不支援web平台外，要特別注意因為dart:io不支援web引發的http request還有platform判斷問題。如果真的有feature要在不同平台執行不同程式片段時，建議使用<a href=\"/2021/09/11/flutter-from-mobile-to-web-migration-tips-conditional-import/\">conditional import</a>來設計程式碼。</p>\n","categories":["Flutter"],"tags":["Flutter","Flutter Web","Flutter Web Migration","Conditional Import"]},{"title":"Flutter Web在連網限制環境下使用CanvasKit渲染器","url":"/2021/07/03/flutter-web-canvaskit-renderer-in-restricted-internet-access-environment/","content":"<p>在使用CanvasKit渲染器開發Flutter web app時，會在app啟動時從CDN服務下載CanvasKit，因此在採用CanvasKit渲染器的情況下預設是需要有連網的環境，否則app在啟動時會因為無法下載CanvasKit出現Failed to load resource: net::ERR_INTERNET_DISCONNECTED的錯誤訊息。</p>\n<img src=\"/2021/07/03/flutter-web-canvaskit-renderer-in-restricted-internet-access-environment/unpkg.jpg\" class=\"\" width=\"300\"> \n\n<p>但如果是在有連網限制的開發環境下，雖然可以在開發環境使用html渲染器進行開發，並在佈署環境使用CanvasKit渲染器來達到最佳的操作效果，但因為兩種渲染器方法不同，所以渲染出來的效果還是有所差異，這會造成開發和佈署的版面不一致。</p>\n<p>雖然預設需要連網才能使用CanvasKit，但目前版本(2.2.2)可以透過指定CanvasKit URL的方式置換掉預設的URL，而且也支援將CanvasKit與web檔案bundle在一起佈署，達到在離線或是有連網限制的環境下執行。但這個方法目前只支援profile與release模式，<a href=\"https://github.com/flutter/flutter/issues/80482\">不支援debug模式</a>。</p>\n<h4 id=\"下載CanvasKit放入web資料夾\"><a href=\"#下載CanvasKit放入web資料夾\" class=\"headerlink\" title=\"下載CanvasKit放入web資料夾\"></a>下載CanvasKit放入web資料夾</h4><p>下載canvaskit.js與canvaskit.wasm並放進web資料夾，舉例來說目前版本使用的CanvasKit為0.25.1，可以先從CDN下載<a href=\"https://unpkg.com/canvaskit-wasm@0.25.1/bin/canvaskit.js\">canvaskit.js</a>和<a href=\"https://unpkg.com/canvaskit-wasm@0.25.1/bin/canvaskit.wasm\">canvaskit.wasm</a>。如果要使用profile模式就將兩個檔案在進/web/profiling/目錄內，要使用release模式的話直接放在/web/目錄。</p>\n<img src=\"/2021/07/03/flutter-web-canvaskit-renderer-in-restricted-internet-access-environment/LocalCanvaskit.jpg\" class=\"\" width=\"300\"> \n<h4 id=\"修改url指到CanvasKit位置\"><a href=\"#修改url指到CanvasKit位置\" class=\"headerlink\" title=\"修改url指到CanvasKit位置\"></a>修改url指到CanvasKit位置</h4><p>透過--dart-define覆寫FLUTTER_WEB_CANVASKIT_URL<a href=\"https://github.com/flutter/engine/blob/7b2db6dbe1c49a8004ff865607988eec36868ccc/lib/web_ui/lib/src/engine/canvaskit/initialization.dart#L51\">環境變數</a>，並指到下載的CanvasKit檔案位置。因為這裡的預設根目錄會是web/，所以如果用上述的檔案放法的話只要給/就行了。這樣在profile模式下會自動在/web/profiling/讀取CanvasKit，在release模式會自動在根目錄(預設輸出的local位置為/web/，實際佈署會存在於根目錄)讀取CanvasKit。</p>\n<p>使用profile模式：</p>\n<blockquote>\n<p>flutter run -d chrome --profile  --dart-define=FLUTTER_WEB_CANVASKIT_URL=/</p>\n</blockquote>\n<p>使用release模式：</p>\n<blockquote>\n<p>flutter build web  --dart-define=FLUTTER_WEB_CANVASKIT_URL=/</p>\n</blockquote>\n<p>使用profile模式也可以透過在VS Code<a href=\"https://flutter.dev/docs/perf/rendering/ui-performance#run-in-profile-mode\">設定launch.json檔</a>中的flutterMode與args參數，接著直接在VS Code執行啟動偵錯就可以進入profile模式。如果是使用release模式也可以透過<a href=\"https://pub.dev/packages/dhttpd\">dhttpd</a>在本地端啟動web server測試。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// launch.json</span></span><br><span class=\"line\"><span class=\"string\">&quot;configurations&quot;</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Flutter&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;dart&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;request&quot;</span>: <span class=\"string\">&quot;launch&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;program&quot;</span>: <span class=\"string\">&quot;lib/main.dart&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;flutterMode&quot;</span>: <span class=\"string\">&quot;profile&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;args&quot;</span>: [<span class=\"string\">&quot;--dart-define=FLUTTER_WEB_CANVASKIT_URL=/&quot;</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在專案中引用Roboto預設字型\"><a href=\"#在專案中引用Roboto預設字型\" class=\"headerlink\" title=\"在專案中引用Roboto預設字型\"></a>在專案中引用Roboto預設字型</h4><p>如果app內Text相關widget沒有指定字型(fontFamily)，或是雖然有指定字型但沒有將字型檔(.ttf/.otf)放進專案並在pubspec宣告，使用CanvasKit渲染器時會預設從fonts.google.com下載<a href=\"https://fonts.google.com/specimen/Roboto\">Roboto-Regular</a>使用。</p>\n<p>因此要先將Roboto放在專案並宣告在pubspec，在web啟動時就會自動使用專案內的字型檔而不會連到google下載字型。如果有使用到其它字型，可以參考官方的<a href=\"https://flutter.dev/docs/cookbook/design/fonts\">字型引用</a>方法。</p>\n<p>從google下載下來會有Rotobo全部的ttf檔，只要把Roboto-Regular放進來即可</p>\n<img src=\"/2021/07/03/flutter-web-canvaskit-renderer-in-restricted-internet-access-environment/roboto.jpg\" class=\"\" width=\"400\"> \n\n<p>接著在pubspec宣告引用</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">flutter:</span></span><br><span class=\"line\">  <span class=\"attr\">uses-material-design:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">fonts:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">family:</span> <span class=\"string\">Roboto</span></span><br><span class=\"line\">      <span class=\"attr\">fonts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">asset:</span> <span class=\"string\">assets/fonts/Roboto-Regular.ttf</span></span><br></pre></td></tr></table></figure>\n\n<p>預設app啟動就會自動使用Roboto而不會連到google下載字型。</p>\n<img src=\"/2021/07/03/flutter-web-canvaskit-renderer-in-restricted-internet-access-environment/DefaultFont.jpg\" class=\"\" width=\"500\"> \n\n<p>在Flutter官方提供更簡易的支援前，可以使用上述的三個步驟來達成在連網限制的環境上使用CanvasKit渲染器，在部署時只要將CanvasKit檔案一起部署即可。</p>\n<p>參考資料:<br><a href=\"https://github.com/flutter/flutter/issues/78235\">Flutter issues - Can’t build web apps with CanvasKit without internet</a><br><a href=\"https://github.com/flutter/flutter/issues/70101\">Flutter issues - support bundling CanvasKit instead of CDN</a><br><a href=\"https://github.com/flutter/flutter/issues/80482\">Flutter issues - support specifying CanvasKit URL in debug builds</a></p>\n","categories":["Flutter"],"tags":["Flutter","Flutter Web"]},{"title":"從Flutter走到Flutter Web的app開發新手歷程","url":"/2021/05/13/from-flutter-to-flutter-web-for-beginner/","content":"<p>最近幾個月來工作的職務上有些轉換，加入到一個小規模的app開發團隊，並且嘗試導入Flutter開發一套codebase就能夠佈署到多個平台的跨平台app。其實網路上已經有非常多介紹Flutter的文章，而原生與跨平台的解決方案比較也很多人討論過，所以這篇會以一個初入Flutter的新手，到成功交付產品上線後，一直到採用Flutter Web的心路歷程分享。</p>\n<h4 id=\"老闆問：能不能弄個跨平台app\"><a href=\"#老闆問：能不能弄個跨平台app\" class=\"headerlink\" title=\"老闆問：能不能弄個跨平台app\"></a>老闆問：能不能弄個跨平台app</h4><p>其實跨平台一直都存在並且持續有新的技術出現，雖然Flutter還很年輕，但是在這幾年的熱度也快速的竄升。我認為採用跨平台技術對於單純開發給公司內部使用的系統來說，最大的優點就是在人力的節省。在一個開發了web就會被問能不能放在行動裝置上，作了手機app就會被問能不能web也有的環境下，為了提供多個平台管道給使用者，一支系統難道不能只開發一次就好了嗎(彷彿老闆的聲音飄出來了)。</p>\n<p>要開發多個平台可以使用的應用程式，除了能夠支援不同裝置尺寸的web應用程式外，如果需求面上又希望能保留行動裝置功能的支援，那Flutter自然是一個適合的選擇。</p>\n<p>Flutter官方網站直接的介紹是這樣寫的：</p>\n<blockquote>\n<p>Flutter is Google’s UI toolkit for building beautiful, natively compiled applications for mobile, web, and desktop from a single codebase.</p>\n</blockquote>\n<h4 id=\"Web-Hit-Stable-Millestone\"><a href=\"#Web-Hit-Stable-Millestone\" class=\"headerlink\" title=\"Web Hit Stable Millestone\"></a>Web Hit Stable Millestone</h4><p>Android和iOS是Flutter最先開始穩定支援的平台，但終究web平台還是一個觸及度最高的管道，也許平板電腦不是每個人都有，但user們還是都用電腦上班。在專案達成mobile first的任務，接著要開始擴大觸及程度時，剛好迎來Flutter Engage在3月3號發佈了Flutter 2的更新。</p>\n<blockquote>\n<p>Perhaps the single largest announcement in Flutter 2 is production-quality support for the web.</p>\n</blockquote>\n<p>Flutter 2正式將Web支援放進stable channel，原本要打開Web支援還得使用beta channel才行，甚至官方也建議在web正式穩定支援前，要發佈成產品都需要仔細的確認執行起來是否有bug。當下還在觀望是否該導入Flutter Web才過沒多久，隨著Flutter 2的發佈後，馬上就在隔天拿起現有的Flutter專案進行POC，直到最近成功的將原本的app正式發佈給使用者使用。</p>\n<h4 id=\"從Flutter到Flutter-Web\"><a href=\"#從Flutter到Flutter-Web\" class=\"headerlink\" title=\"從Flutter到Flutter Web\"></a>從Flutter到Flutter Web</h4><p>下面我分享三個如果今天從新手Flutter開發者，一路走到開發產品等級的Flutter Web可能會發生的心路歷程與重點學習資源：</p>\n<ul>\n<li>從零開始開始的Flutter菜鳥</li>\n</ul>\n<p>身為第一次接觸Flutter的開發者，自己覺得還不算難上手，基本上跟著官方的文件把開發環境裝起來後，接著讀完stateless和stateful widget還有column和row的layout概念後，就可以作出簡單的切版畫面。</p>\n<p>Flutter的widget其實很多，常常都是需要的時候邊查邊實作，通常第一步會先找是不是有Flutter已經提供的<a href=\"https://flutter.dev/docs/development/ui/widgets\">widget</a>(像是drawer、search、bottom navigation等)，如果沒有的話這裡推薦<a href=\"https://pub.dev/\">pub.dev</a>還有<a href=\"https://fluttergems.dev/\">Flutter Gems</a>，這兩個網站的資源可以幫你找到很多你需要的功能。最後再上<a href=\"https://pub.dev/packages/http\">http</a>加上<a href=\"https://flutter.dev/docs/development/data-and-backend/json\">json serialization</a>，或是直接跟著<a href=\"https://flutter.dev/docs/cookbook/networking/fetch-data\">cookbook</a>作大致上就能接完後端了。</p>\n<ul>\n<li>一個好的狀態管理很重要</li>\n</ul>\n<p>成功發佈完app的1.0.0版後，接著來的就是各種app的新功能需求，在追加越來越多的跳頁功能下，開始出現很多的渲染失敗或是改一改就出現畫面亂跳頁的bug。這時候才會發現真的需要一個好的狀態管理，領悟到沒有好好規畫狀態管理的app不止難以維護，更會造成app效能變差。如果這段是在趕鴨子上架的過程被忽略掉的，這時直接建議把<a href=\"https://flutter.dev/docs/development/data-and-backend/state-mgmt/intro\">Flutter狀態管理</a>這篇讀完，至少用<a href=\"https://pub.dev/packages/provider\">Provider</a>好好設計每個widget的狀態變化與重新渲染的時機。</p>\n<p>另外要注意在取後端資料時是否有使用<a href=\"https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html\">FutureBuilder</a>，FutureBuilder可以幫你確認取得async資料(通常是後端的一包資料)的各種狀態，例如在接到資料前可以先拋出一個自己準備有讀取效果的widget，並在取得資料後再使用這包資料渲染出要程現的widget(對Dashboard而言可能就是一些圖表)。</p>\n<ul>\n<li>打開web支援要怎麼作</li>\n</ul>\n<p>Flutter web在開發上其實也不困難，而且可以在VSCode用debug模式就可以直接進行開發，<a href=\"https://flutter.dev/web\">Web support for Flutter</a>官方有一個篇章在作介紹，如果是專案一開始就有打算作Web平台，那建議直接跟著文件說明就能夠<a href=\"https://flutter.dev/docs/get-started/web\">建立Flutter Web應用程式</a>。</p>\n<p>但如果今天是有一個已經開發好的app產品要打開Web平台的支援，通常就會遇到比較多的阻礙，當我以為一個彈指就能把web支援打開，但遇到的就是滿滿的error訊息。要將現有的app打開web支援，通常在開發上會遇到的問題我大致上分成三種。</p>\n<ol>\n<li><p>Responsive Design(響應式設計): 不管是從手機或是平板使用的app，如果沒有對螢幕尺寸作適當的處理，通常直接放到web都會直接跑版，官方文件也有一個篇章在介紹<a href=\"https://flutter.dev/docs/development/ui/layout/adaptive-responsive\">響應式設計</a>。</p>\n</li>\n<li><p><a href=\"/2021/08/07/flutter-from-mobile-to-web-migration-tips-package-compatibility/\">Cross-Platform Support Package</a>(跨平台支援套件): 在開發過程中會有一定程度的使用第三方的package，要注意是否有支援所需要的平台特別是web，通常可以在<a href=\"https://pub.dev/\">pub.get</a>查到。</p>\n</li>\n<li><p><a href=\"/2021/09/11/flutter-from-mobile-to-web-migration-tips-conditional-import/\">Platform Dependency Feature</a>(平台相依性功能): 因為不同平台還是會有差異存在，有些dart自帶的library本身就不支援，比如說web就不能使用dart:io相關的函式，因此在開發的時候需要特別注意。如果需要針對不同的平台用該平台才有支援的widget，通常會先用邏輯判斷目前使用者是使用哪個平台，再渲染該平台特有的widget。</p>\n</li>\n</ol>\n<p>以上是自己在投入開發Flutter到打開web支援的一些心得整理，開發過程也許遇到許多不同的問題，特別是在web支援的部份遇到了許多挑戰。雖然花了許多時間解決各種遇到的轉換問題，但確實可以達到透過single codebase在web和app渲染出一樣的畫面！</p>\n","categories":["Flutter"],"tags":["Flutter","Flutter Web"]},{"title":"從零開始開發Flutter Web App","url":"/2021/06/21/implement-flutter-web-app-from-scratch-and-tips/","content":"<p>在Flutter正式將web支援放進stable channel後，現在只要從官網下載最新的stable版sdk，就可以直接開發與佈建web應用程式。這篇會紀錄Flutter web開發從前置準備到發佈前的環節，提供給有Flutter經驗而且要嘗試打開web支援的開發者。如果需要從頭開始建立Flutter的開發環境，可以依不同開發平台參考<a href=\"https://flutter.dev/docs/get-started/install\">flutter.dev</a>的說明。</p>\n<h4 id=\"前置準備\"><a href=\"#前置準備\" class=\"headerlink\" title=\"前置準備\"></a>前置準備</h4><p>以<a href=\"https://flutter.dev/docs/get-started/install/windows\">Windows開發</a>為例，在完成Flutter開發環境與IDE設定後，就可以執行flutter doctor來協助診斷是否設定完全。其中可以看到開發web需要使用chrome所以會有一項檢查chrome是否有安裝。</p>\n<blockquote>\n<p>flutter doctor</p>\n</blockquote>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Running &quot;flutter pub get&quot; in flutter_tools...                       8.4s</span><br><span class=\"line\">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class=\"line\">[√] Flutter (Channel stable, 2.2.2, on Microsoft Windows [Version 10.0.19041.1052], locale zh-TW)</span><br><span class=\"line\">[√] Android toolchain - develop for Android devices (Android SDK version 30.0.2)</span><br><span class=\"line\">[√] Chrome - develop for the web</span><br><span class=\"line\">[√] Android Studio (version 4.0)</span><br><span class=\"line\">[√] VS Code (version 1.57.1)</span><br><span class=\"line\">[√] Connected device (2 available)</span><br><span class=\"line\">• No issues found!</span><br></pre></td></tr></table></figure>\n<p>其實Flutter也可以使用Edge，所以使用flutter devices來確定有連接到的device，如果有安裝Edge也會被偵測到。</p>\n<blockquote>\n<p>flutter devices</p>\n</blockquote>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">2 connected devices:</span><br><span class=\"line\"></span><br><span class=\"line\">Chrome (web) • chrome • web-javascript • Google Chrome 91.0.4472.106</span><br><span class=\"line\">Edge (web)   • edge   • web-javascript • Microsoft Edge 91.0.864.54</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"建立Flutter專案與打開web支援\"><a href=\"#建立Flutter專案與打開web支援\" class=\"headerlink\" title=\"建立Flutter專案與打開web支援\"></a>建立Flutter專案與打開web支援</h4><p>如果是要從頭建立一個專案，可以直接使用flutter create [project name]，建立的新專案就會帶有web資料夾，裡面會包含所有web需要的檔案像是index、manifest與icons。如果是已經存在的專案但要打開web支援，則可以使用flutter create [project path]就會自動產生web目錄。</p>\n<blockquote>\n<p>flutter create [project name]</p>\n</blockquote>\n<img src=\"/2021/06/21/implement-flutter-web-app-from-scratch-and-tips/ProjectFolder2.jpg\" class=\"\" width=\"300\"> \n\n<h4 id=\"設定IDE-VSCode\"><a href=\"#設定IDE-VSCode\" class=\"headerlink\" title=\"設定IDE(VSCode)\"></a>設定IDE(VSCode)</h4><p>打開VSCode點擊右下角設定，就能夠選擇現在可使用的emulator，為了開發web所以這裡選擇chrome。如果不先選擇emulator在執行run debug時也會跳出來請你選擇。</p>\n<img src=\"/2021/06/21/implement-flutter-web-app-from-scratch-and-tips/Emulator.jpg\" class=\"\" width=\"500\"> \n\n<p>如果需要在debug的時候帶進參數，可以在launch.json檔裡面寫入args。例如Flutter web預設使用的渲染器是Auto模式，即在桌上裝置使用CanvasKit，在行動裝置使用html。如果要指定渲染器都使用html的話，就可以寫進args。</p>\n<img src=\"/2021/06/21/implement-flutter-web-app-from-scratch-and-tips/LaunchJson.jpg\" class=\"\" width=\"500\"> \n\n<!-- <p float=\"moddle\">\n  <img src=\"/2021/06/21/implement-flutter-web-app-from-scratch-and-tips/Emulator.jpg\" width=\"250\" />\n  <img src=\"/2021/06/21/implement-flutter-web-app-from-scratch-and-tips/LaunchJson.jpg\" width=\"250\" /> \n</p> -->\n\n<h4 id=\"運行debug模式\"><a href=\"#運行debug模式\" class=\"headerlink\" title=\"運行debug模式\"></a>運行debug模式</h4><p>再來可以在IDE啟動偵錯就會開始debug模式，除了使用IDE啟動偵錯外也可以透過指令flutter run來運行debug模式。因為Flutter會運行dartdevc並對app進行compile將dart轉成javascript，所以第一次啟動debug模式的時間會比較長。web開發可以使用hot restart，Flutter只會對有更動到的部份recompile成javascript，而不需要從頭compile整個app。在IDE可以透過restart debug功能觸發hot restart，如果是使用command line可以按R觸發。</p>\n<blockquote>\n<p>flutter run -d chrome</p>\n</blockquote>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Launching lib\\main.dart on Chrome in debug mode...</span><br><span class=\"line\">Waiting for connection from debug service on Chrome...             22.7s</span><br><span class=\"line\">This app is linked to the debug service: ws://127.0.0.1:50526/2kZvThD-K8w=/ws</span><br><span class=\"line\">Debug service listening on ws://127.0.0.1:50526/2kZvThD-K8w=/ws</span><br><span class=\"line\"></span><br><span class=\"line\"> Running with sound null safety</span><br><span class=\"line\"></span><br><span class=\"line\">  To hot restart changes while running, press &quot;r&quot; or &quot;R&quot;.</span><br><span class=\"line\">For a more detailed help message, press &quot;h&quot;. To quit, press &quot;q&quot;.</span><br></pre></td></tr></table></figure>\n\n<img src=\"/2021/06/21/implement-flutter-web-app-from-scratch-and-tips/FlutterDemo.jpg\" class=\"\" width=\"500\"> \n\n<h4 id=\"建構web發佈版本\"><a href=\"#建構web發佈版本\" class=\"headerlink\" title=\"建構web發佈版本\"></a>建構web發佈版本</h4><p>在開發完準備要發佈後，可以使用flutter build web指令來建構發佈版本。預設發佈時使用的渲染器是auto模式(即在桌上裝置使用canvaskit，在行動裝置使用html)，如果要指定使用特定的渲染器，可以使用--web-renderer。</p>\n<blockquote>\n<p>flutter build web --web-renderer [auto/html/canvaskit]</p>\n</blockquote>\n<p>執行指令後Flutter會使用dart2js將app compile成一個單一的javascript檔案main.dart.js，發佈完後會在build目錄內產生web目錄，這整包資料會包含所有必要的檔案並且需要同時佈署。</p>\n<img src=\"/2021/06/21/implement-flutter-web-app-from-scratch-and-tips/BuildWeb.jpg\" class=\"\" width=\"300\"> \n\n<h4 id=\"使用dhttpd於本地端運行\"><a href=\"#使用dhttpd於本地端運行\" class=\"headerlink\" title=\"使用dhttpd於本地端運行\"></a>使用dhttpd於本地端運行</h4><p>最後在實際將整包web佈署到server上之前，可以使用dhttpd嘗試在本地端先運行app，檢視要發佈的app的功能與asset是否都正常。dhttpd安裝方法可以參考<a href=\"https://pub.dev/packages/dhttpd\">dhttpd</a>在pub.dev的安裝方法，並在運行時指定build/web/目錄就可以在本地端運行要發佈的app，在本地端運行app檢查沒問題後就可以準備將web佈署到正式的server了。</p>\n<blockquote>\n<p>dart pub global run dhttpd –path build/web/</p>\n</blockquote>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Server started on port 8080</span><br></pre></td></tr></table></figure>\n\n<img src=\"/2021/06/21/implement-flutter-web-app-from-scratch-and-tips/dhttpd.jpg\" class=\"\" width=\"500\"> \n\n<p>Flutter的web支援目前可以很容易的將自己開發好的app轉成web上線，而且設定到發佈其實也不困難，可以達成快速的支援跨平台的需求。但實際在使用時還是會遇到像是將app轉成web app所會遇到的migration問題，或是渲染器選擇使用跟canvaskit預設不支援offline模式問題，而且發佈完成的app本身會是一個PWA(Progressive Web Apps)需要設定manifest。這些問題會在實際實作的過程會遇到，有些自己踩過的坑也會再持續紀錄下來。</p>\n<p>參考資料:<br><a href=\"https://flutter.dev/web\">Fluter docs - Web</a></p>\n","categories":["Flutter"],"tags":["Flutter","Flutter Web"]},{"title":"第一次使用Keras就上手","url":"/2017/12/05/keras-intro/","content":"<p>最近正在學習Andrea在Coursera上開的Deep Learning課程，之前工作關係有接觸到keras，而且使用起來還滿容易上手的，所以就嘗試拿了MNIST資料集來試玩看看</p>\n<p>首先載入手寫辨識資料集mnist，這個資料集還滿廣泛被拿來使用的，而且在keras也可以直接載入，另外也會用到最基本的keras Sequential model。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> keras.datasets </span><br><span class=\"line\"><span class=\"keyword\">import</span> mnistfrom keras.models </span><br><span class=\"line\"><span class=\"keyword\">import</span> Sequentialfrom keras.layers </span><br><span class=\"line\"><span class=\"keyword\">import</span> Denseimport numpy <span class=\"keyword\">as</span> np</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">model = Sequential()</span><br><span class=\"line\">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br></pre></td></tr></table></figure>\n<p>再來直接宣告一個sequential模型，並載入訓練和測試資料集</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">x_train = np.reshape(x_train, (x_train.shape[<span class=\"number\">0</span>], -<span class=\"number\">1</span>))/<span class=\"number\">255</span></span><br><span class=\"line\">x_test = np.reshape(x_test, (x_test.shape[<span class=\"number\">0</span>], -<span class=\"number\">1</span>))/<span class=\"number\">255</span></span><br><span class=\"line\"></span><br><span class=\"line\">y_train = np.eye(<span class=\"number\">10</span>)[y_train.reshape(-<span class=\"number\">1</span>)]</span><br><span class=\"line\">y_test = np.eye(<span class=\"number\">10</span>)[y_test.reshape(-<span class=\"number\">1</span>)]</span><br></pre></td></tr></table></figure>\n<p>接著要先處理一下載入的資料，在x資料的部份要先將原本28×28的維度轉成1×784輸入，這裡可以使用numpy的reshape來處理，再來再將資料除上255作正規化。另外在label y資料集的部份則要作one-hot encoding，將每個標籤轉成長度為10的向量，並用0和1來表示屬於哪一個類別。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x_train.shape</span><br><span class=\"line\">(<span class=\"number\">60000</span>, <span class=\"number\">784</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x_test.shape</span><br><span class=\"line\">(<span class=\"number\">60000</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y_train.shape</span><br><span class=\"line\">(<span class=\"number\">10000</span>, <span class=\"number\">784</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y_test.shape</span><br><span class=\"line\">(<span class=\"number\">10000</span>, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>可以看到處理完後的資料維度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">model.add(Dense(units=<span class=\"number\">256</span>, activation=<span class=\"string\">&#x27;relu&#x27;</span>, input_dim=<span class=\"number\">28</span>*<span class=\"number\">28</span>))</span><br><span class=\"line\">model.add(Dense(units=<span class=\"number\">10</span>, activation=<span class=\"string\">&#x27;softmax&#x27;</span>))</span><br></pre></td></tr></table></figure>\n<p>再來加入兩個layer，即只使用一個hidden layer和一個output layer，其中hidden layer有256顆神經元，output layer有10顆，並透過softmax輸出結果</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">model.<span class=\"built_in\">compile</span>(loss=<span class=\"string\">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class=\"line\">              optimizer=<span class=\"string\">&#x27;Adam&#x27;</span>,              </span><br><span class=\"line\">              metrics=[<span class=\"string\">&#x27;accuracy&#x27;</span>])</span><br></pre></td></tr></table></figure>\n<p>接著開始設定使用什麼loss function與最佳化的方法，還有要評估模型的指標</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">model.fit(x_train, y_train, epochs=<span class=\"number\">10</span>, batch_size=<span class=\"number\">32</span>)</span><br></pre></td></tr></table></figure>\n<p>接著就開始訓練，其中會設定訓練的週期與每一次的批數</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>loss_and_metrics = model.evaluate(x_train, y_train, batch_size=<span class=\"number\">128</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(loss_and_metrics)</span><br><span class=\"line\">loss=<span class=\"number\">0.007</span>, acc=<span class=\"number\">0.998</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>loss_and_metrics = model.evaluate(x_test, y_test, batch_size=<span class=\"number\">128</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(loss_and_metrics)</span><br><span class=\"line\">loss=<span class=\"number\">0.08</span>, acc=<span class=\"number\">0.979</span></span><br></pre></td></tr></table></figure>\n<p>中間可以看到訓練的過程，在訓練完畢說可以透過evaluate來評估model在訓練資料集，還有測試資料集的正確率。</p>\n<p>keras在建立模型非常方便使用，可以很容易的加入需要的hidden layer數，而且針對常使用的activation function, loss function和最佳化的方法都有支援，如果需要快速的建出模型來作應用非常的推薦。另外keras也有支援CNN還有RNN，下次會用別的資料來試試看囉！</p>\n<p>參考資料:<br/><a href=\"https://keras.io/getting-started/sequential-model-guide/\">Keras Getting Start</a></p>\n","categories":["Machine Learning"],"tags":["Python","Machine Learning","Deep Learning","Keras"]},{"title":"Machine Learning on GCP - Feature Engineering(上)","url":"/2019/03/05/machine-learning-on-gcp-feature-engineering/","content":"<p>前陣子在上Coursera的Data Engineering on Google Cloud Platform這個系列課程，其中在Serverless Machine Learning with Tensorflow on Google Cloud Platform這週內有一個Feature Engineering單元，裡面展示了如何透過Feature Engineering來提升模型的表現。上完後覺得裡面提到一些關於Feature Engineering的技巧，決定還是找時間把筆記寫下來。</p>\n<img src=\"/2019/03/05/machine-learning-on-gcp-feature-engineering/GoodFeature.JPG\" class=\"\" width=\"500\">\n\n<p>好的特徵必須要和預測目標值是有相關的，對於特徵和預測值之間，需要有合理的假設，而不是隨意丟任意的資料進來，就希望特徵和預測值間具有關聯性，否則會落入Data Dredge的問題。Data Dredge意指可能會從大量資料中找到另人意外的相關性，這並不是我們想要的結果。(例如荷蘭的研究中指出一個地方送子鳥被看到的數量，和9個月後嬰兒出生的數量相關)</p>\n<h2 id=\"Causality\"><a href=\"#Causality\" class=\"headerlink\" title=\"Causality\"></a>Causality</h2><img src=\"/2019/03/05/machine-learning-on-gcp-feature-engineering/Causality.JPG\" class=\"\" width=\"500\">\n\n<p>好的特徵特性是要使用預測當下能夠掌握的資料當作特徵，例如當你要使用每日的銷售資料當作特徵值，但是這些資料可能需要一個月的資料才會產生，而不是及時會被收集到資料倉儲。像這種可能因為資料延遲造成在預測時無法取得完整的資料將可能造成模型失效。所以在訓練模型時，請確保這些特徵在預測時是可以完整取得的，否則不要使用在模型中。</p>\n<h2 id=\"Numeric-amp-Magnitude\"><a href=\"#Numeric-amp-Magnitude\" class=\"headerlink\" title=\"Numeric &amp; Magnitude\"></a>Numeric &amp; Magnitude</h2><img src=\"/2019/03/05/machine-learning-on-gcp-feature-engineering/Numeric.JPG\" class=\"\" width=\"500\">\n\n<p>因為在機器學習的過程中，會對輸入的資料作許多的運算，因此使用的特徵必須要為數值形態，且其數值是有大小意義的(例如coupon提供的打折數20%和10%存在折數大小關係)。</p>\n<h2 id=\"Enough-examples\"><a href=\"#Enough-examples\" class=\"headerlink\" title=\"Enough examples\"></a>Enough examples</h2><img src=\"/2019/03/05/machine-learning-on-gcp-feature-engineering/EnoughData.JPG\" class=\"\" width=\"500\">\n\n<p>好的特徵需要有足夠的資料，以講者的個人經驗來說，如果一個特徵中每個值出現至少5筆，才會將這個特徵用來訓練模型。舉例來說，有一個類別為自動交易，需要有足夠的詐欺/非詐欺資料才有辦法訓練出有效的機器學習模型。如果今天只有3筆自動交易資料，且3筆都是非詐欺，這樣數量的資料可能就無法訓練出可用的機器學習模型。我想這裡的用意是指一個特徵如果相似度太高，可能造成沒有鑑別度；例如在分類問題中，特徵在每個類別的值都一樣或相似，那麼這樣的特徵可能對分類問題沒辦法貢獻太多資訊，使用決策樹來切分也會找不到好的切點。</p>\n<p>參考資料:<br/><a href=\"https://www.coursera.org/learn/serverless-data-analysis-bigquery-cloud-dataflow-gcp/home/welcome\">Data Engineering on Google Cloud Platform 4 - Serverless Data Analysis with Google BigQuery and Cloud Dataflow</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Feature Engineering","GCP"]},{"title":"Machine Learning on GCP - Feature Engineering(下)","url":"/2019/03/14/machine-learning-on-gcp-feature-engineering2/","content":"<p><a href=\"https://qiubite31.github.io/2019/03/05/machine-learning-on-gcp-feature-engineering/\">上一篇</a>提到一些基本的Feature Engineering概念與方法，這一篇則是會說明當要使用類別型的特徵來訓練機器學習模型時的技巧。</p>\n<h2 id=\"Categorical\"><a href=\"#Categorical\" class=\"headerlink\" title=\"Categorical\"></a>Categorical</h2><img src=\"/2019/03/14/machine-learning-on-gcp-feature-engineering2/Categorical.JPG\" class=\"\" width=\"500\">\n\n<p>如果遇到類別型的特徵又需要拿進來訓練模型，則可以用one-hot encoding來處理。例如當今天要對商品銷售預測建立模型時，想要把員工拿進來考量，也許不同員工對顧客的服務上會影響到商品銷售。雖然員工的編號是數值，但其並不存在實際上數值的意義，這時候就可以透過one-hot來處理，並以多個欄位變數表示來將每個值轉成0/1表示的稀疏向量。</p>\n<img src=\"/2019/03/14/machine-learning-on-gcp-feature-engineering2/CustomerRating.JPG\" class=\"\" width=\"500\">\n\n<p>有時候在某些資料則可以當作連續型處理，也可以使用one-hot來處理。例如顧客的評分，如果你認為4分和2分是差距很大的，這時也可以依個人考量當作類別型處理。要特別注意的是，如果今天顧客沒有提供評分資料，在處理missing value上，第一種數值型的處理方法是使用另一個欄位來紀錄是否有收到評分(1/0)，並維持評分值為0；第二種類別型處理方法則將所有one-hot變數設為0，並一樣透過另一欄位紀錄是否有評分，注意不要使用自己的特別編碼(magic number)來處理。</p>\n<h2 id=\"Feature-Cross\"><a href=\"#Feature-Cross\" class=\"headerlink\" title=\"Feature Cross\"></a>Feature Cross</h2><img src=\"/2019/03/14/machine-learning-on-gcp-feature-engineering2/FeatureCross.JPG\" class=\"\" width=\"500\">\n\n<p>假設今天要建立模型來判斷車輛是否為計程車，而使用的特徵只有兩個，分別為車倆的顏色和車輛所屬城市。假設透過簡單的線性模型來作訓練，在調整權重的過程中，都沒辦法有好的辨識效果。因為模型在調整黃色和白色的權重時，當它看到黃色在紐約是計程車，提高了黃色的權重，但這反而造成所有黃色車倆比較容易判斷成計程車，這是不對的；相同的如果模型提高了紐約的權重，這也會造成所有紐約的車倆都容易判斷成計程車，這一樣是不對的。</p>\n<p>這時候則可以嘗試將兩個變數結合變成第三個變數，並透過one-hot encoding來處理，而在訓練過程中就會將黃色X紐約的組合單獨調整權重，可以避開原本的問題。例如在預測計程車車資問題中，雖然知道在上下班時間的旅程時間會比較長，車資也可能比較高，但是這時可以不特別作新增rule的處理(例如標注某天的某時段為上下班時間)，而是直接將Day of Week和24小時作feature cross建立組合。</p>\n<h2 id=\"Bucketize\"><a href=\"#Bucketize\" class=\"headerlink\" title=\"Bucketize\"></a>Bucketize</h2><img src=\"/2019/03/14/machine-learning-on-gcp-feature-engineering2/DiscreteFloat.JPG\" class=\"\" width=\"500\">\n\n<p>以加州的房價預測來說，如果觀察緯度這個特徵會發現有兩個高峰，一個是舊金山灣區，另一個則是洛杉磯大都市，這時就可以透過資料分群(bin)來拆成100個bucket，轉成類別型資料來訓練模型。注意在預測時也要透過資料前處理來將資料作bucketize。</p>\n<h2 id=\"Wide-and-Deep\"><a href=\"#Wide-and-Deep\" class=\"headerlink\" title=\"Wide and Deep\"></a>Wide and Deep</h2><img src=\"/2019/03/14/machine-learning-on-gcp-feature-engineering2/DenseAndSparse.JPG\" class=\"\" width=\"500\">\n\n<p>到這邊就會遇到一個問題，在銷售遇到時會有價格和員工兩種不同特性的變數，價格是密集的(Dense)的連續型變數，而員工編號是透過one-hot產生稀疏(Sparse)的類別型變數。而在使用類神經網路訓練模型時，因為在0在乘上權重還是為0，所以稀疏的矩陣可能造成訓練過程中收斂在區域最佳解跳不出來。但是以上面說的計程車例子，其實線性模型是比較容處理的。</p>\n<img src=\"/2019/03/14/machine-learning-on-gcp-feature-engineering2/EatAll.JPG\" class=\"\" width=\"500\">\n\n<p>因此在訓練模型時，可以嘗試合併兩種方法，透過類神經網路來使用連續型變數訓練深度(Deep)結果，再和類別型變數透過線性方式串聯(Wide)，這即是一個wid-and-deep架構的神經網路模型。</p>\n<p>參考資料:<br/><a href=\"https://www.coursera.org/learn/serverless-data-analysis-bigquery-cloud-dataflow-gcp/home/welcome\">Data Engineering on Google Cloud Platform 4 - Serverless Data Analysis with Google BigQuery and Cloud Dataflow</a></p>\n","categories":["線上課程筆記"],"tags":["Machine Learning","Feature Engineering","GCP"]},{"title":"如何將現有的專案與RDBMS轉移到Cassandra","url":"/2024/03/21/migrate-rdbms-to-cassandra-approach/","content":"<p>當專案已經準備要導入Cassandra時，可能是專案已經遇到某些困難與瓶頸，並已經考慮採用Cassandra是一個正確的使用情境。以下是使用<a href=\"https://live-datastaxd8.pantheonsite.io/sites/default/files/content/ebook/2020-04/9781492079514%20%282%29.pdf\">Cassandra: The Definitive Guide, Third Edition</a>其中第十五章的部份段落來說明如何將資料表轉移到Cassandra上。</p>\n<p>要將關聯式資料庫轉到Cassandra上，第一個遇到的問題就是如何將原本的資料表關係轉移到Cassandra上。一種方式是將既有的資料模型作直接轉譯(Direct Translation)，以下會舉旅館預約系統來說明如何對資料模型作直接轉譯。</p>\n<img src=\"/2024/03/21/migrate-rdbms-to-cassandra-approach/reservation_relational_model.png\" class=\"\" width=\"500\">\n\n<p>在將關聯式資料庫的資料表直接轉譯到Cassandra上，會分成二個部份：</p>\n<ol>\n<li>轉譯實體(Translation Entities)</li>\n<li>轉譯關聯(Translation Relationships)</li>\n</ol>\n<h4 id=\"轉譯實體-Translation-Entities\"><a href=\"#轉譯實體-Translation-Entities\" class=\"headerlink\" title=\"轉譯實體(Translation Entities)\"></a>轉譯實體(Translation Entities)</h4><img src=\"/2024/03/21/migrate-rdbms-to-cassandra-approach/entity_translation.png\" class=\"\" width=\"500\">\n\n<ol>\n<li> 根據主鍵設定建立相似鍵值的Cassandra資料表<br>首先找到原本關聯式資料模型中的實體。比如說Hotel這張資料表會被預約系統查詢使用，這時就可以在Cassandra也建立一個具有相似鍵值的資料表，即為上圖的hotels資料表，其中參照原本的設定將hotel_id設定成主鍵(在這裡亦為partition key)。</li>\n<li> 建立<a href=\"https://qiubite31.github.io/2024/02/28/before-adopt-cassandra-you-need-to-know-no-join/\">反正規化資料表</a>滿足不同查詢組合<br>因為並不是所有的查詢都是透過hotel_id查詢，假設要滿足使用name來查詢hotel資料的行為，那就需要建立另一張以name欄位為partition key的資料表叫hotels_by_name。這裡的主鍵為name和hotel_id組合，其中hotel_id為clustering key。</li>\n<li>使用<a href=\"https://docs.datastax.com/en/cql-oss/3.3/cql/cql_using/useCreateUDT.html\">UDT(User-defined Type)</a>描述複雜的型別資料<br>在資料表中的address可以是一個單純的字串表示地址，也可以是一個自定義的型別。因為在Cassandra中可以透過自定義型別來描述複雜的型別資料，以自定義型別Address來說，其中可以包含street、city等多個欄位的屬性。自定義型別並不是必須的，可以依系統的設計需求來考慮是否採用。</li>\n</ol>\n<h4 id=\"轉譯關聯-Translation-Relationships\"><a href=\"#轉譯關聯-Translation-Relationships\" class=\"headerlink\" title=\"轉譯關聯(Translation Relationships)\"></a>轉譯關聯(Translation Relationships)</h4><img src=\"/2024/03/21/migrate-rdbms-to-cassandra-approach/relationship_translation.png\" class=\"\" width=\"500\">\n\n<p>將實體的資料表轉譯到Cassandra的資料表後，接著就可以開始看這些實體資料表間的關聯性。以RoomToAmenity來說，這張為其實是描述Room和Amenity之間的關聯，而這類的關聯資料表常常沒有自己的屬性，可以看到RoomID和AmenityID這兩個欄位組成的主鍵，同時也分別是連接到Room和Amenity的外部鍵。</p>\n<ol>\n<li>將實體資料表間的關聯性建立Cassandra資料表<br>這些被用來表達實體間關聯的資料表，時常伴隨著實體資料表作使用。以amenities_by_room為例，這張資料表的主鍵會拿實體資料表中的鍵值作為查詢用的partition key(hotel_id, room_number)。因此在查詢時就可以從hotel_id查詢某一間room_number提供的amenities。 </li>\n<li>使用UDT描述從屬資料<br>以右下角rooms_by_hotel資料表為例，這張表是透過hotel_id查詢所有的room資料，這時可以設計一個amenity自定義型態，並設定amenities欄位是list of amenity型態。這種設計的好處在於可以透過一個查詢就一併查出room相關的amenities資料，不需要分多次查詢。當然UDT的使用也是依系統的設計需求來考慮是否採用。</li>\n</ol>\n<p>以上就是採用直接轉譯的方式將原本關聯式資料表轉成Cassandra資料表，這種方式好處在於可以直接對準在原本的資料模型作轉移，一步一步從實體資料表、資料表關聯還有結合應用層的查詢條件將專案作轉移。</p>\n","categories":["SQL&NoSQL"],"tags":["Cassandra","NoSQL","migration","UDT"]},{"title":"namespace與LEGB scope規則","url":"/2016/11/02/namespace%E8%88%87LEGB-scope%E8%A6%8F%E5%89%87/","content":"<p>python的namespace是一種”name-to-object”的對應關係，而在不同的namespace之間都有各自的作用域，就像是不同的module中雖然都定義了相同的名稱的函式，但卻不會互相影響。為了找到特定的”name-to-object”的namespace，python會採用scope的概念來找到特定object的所屬變數或是函式，而搜尋順序即是LEBG規則。</p>\n<p>python的scope規則LEGB查找順序分別為 Local -&gt; Enclosed -&gt; Global -&gt; Built-in</p>\n<p>Local: 宣告於於function或是class內的name<br/>Enclosed: 封閉的function，function被另一個function包起來，常見為<a href=\"/2016/11/08/Closure%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/\">Closure</a><br/>Global: 最上層位於module的global name<br/>Build-in: 內建module的name，例如print, input等等</p>\n<p>以下舉幾個範例說明:</p>\n<h5 id=\"1-L-local-scope\"><a href=\"#1-L-local-scope\" class=\"headerlink\" title=\"1. L - local scope\"></a>1. L - local scope</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">var = <span class=\"string\">&#x27;global&#x27;</span>    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">L</span>():</span>    </span><br><span class=\"line\">    var = <span class=\"string\">&#x27;local&#x27;</span>        </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(var)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;&gt; L()  <span class=\"comment\"># local 當function有定義local scope時，會優先使用local scope</span></span><br><span class=\"line\">local</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-LE-local-and-Enclosed-scope\"><a href=\"#2-LE-local-and-Enclosed-scope\" class=\"headerlink\" title=\"2. LE - local and Enclosed scope\"></a>2. LE - local and Enclosed scope</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">var = <span class=\"string\">&#x27;global&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">LE</span>():</span>    </span><br><span class=\"line\">    var = <span class=\"string\">&#x27;enclosed&#x27;</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inner</span>():</span>        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(var)    </span><br><span class=\"line\">    inner()</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;&gt; LE()  <span class=\"comment\"># 當function沒有local scope時，會往外找enclosed scope</span></span><br><span class=\"line\">enclosed</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-LEG-local-Enclosed-and-Global-scope\"><a href=\"#3-LEG-local-Enclosed-and-Global-scope\" class=\"headerlink\" title=\"3. LEG - local, Enclosed and Global scope\"></a>3. LEG - local, Enclosed and Global scope</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">var = <span class=\"string\">&#x27;global&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">LEG</span>():</span>    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(var)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>LEG()  <span class=\"comment\"># 當local和enclosed都沒有時，會往外找global</span></span><br><span class=\"line\"><span class=\"keyword\">global</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"4-LEGB-local-Enclosed-Global-and-Build-in-scope\"><a href=\"#4-LEGB-local-Enclosed-Global-and-Build-in-scope\" class=\"headerlink\" title=\"4. LEGB - local, Enclosed, Global and Build-in scope\"></a>4. LEGB - local, Enclosed, Global and Build-in scope</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">id</span>(<span class=\"params\">var</span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;global id()&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">LEGB</span>(<span class=\"params\">var</span>):</span>    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(var))    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">str</span>(var))</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>LEGB(<span class=\"string\">&#x27;Build-in str()&#x27;</span>)  <span class=\"comment\"># 當有定義global function，會呼叫global function，否則會呼叫Build-in function</span></span><br><span class=\"line\"><span class=\"keyword\">global</span> <span class=\"built_in\">id</span>()</span><br><span class=\"line\">Build-<span class=\"keyword\">in</span> <span class=\"built_in\">str</span>()</span><br></pre></td></tr></table></figure>\n<h5 id=\"5-NameError-name-is-not-defined\"><a href=\"#5-NameError-name-is-not-defined\" class=\"headerlink\" title=\"5. NameError - name is not defined\"></a>5. NameError - name is not defined</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>var = <span class=\"string\">&#x27;global&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(var2) <span class=\"comment\"># 當LEGB scope都找不到，會發生NameError</span></span><br><span class=\"line\">Traceback (most recent call last):    </span><br><span class=\"line\">    File “LEGB.py”, line <span class=\"number\">39</span>, <span class=\"keyword\">in</span> &amp;lt;module&gt;        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(var2)    </span><br><span class=\"line\">    NameError: name <span class=\"string\">&#x27;var2&#x27;</span> <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> defined</span><br></pre></td></tr></table></figure>\n<p>以上幾個是python LEGB scope順序的範例，了解LEGB的觀念也有助於幫助自己在開發的時候，避免誤用scope產生許多bug</p>\n<p>參考資料:<br/><a href=\"http://sebastianraschka.com/Articles/2014_python_scope_and_namespaces.html\">A Beginner’s Guide to Python’s Namespaces, Scope Resolution, and the LEGB Rule</a><br/><a href=\"https://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces\">Python docs - Scopes and Namespace</a></p>\n","categories":["Python"],"tags":["Python"]},{"title":"nonlocal與global關鍵字","url":"/2016/11/14/nonlocal%E8%88%87global%E9%97%9C%E9%8D%B5%E5%AD%97/","content":"<p>之前曾介紹過Python透過<a href=\"/2016/11/02/namespace%E8%88%87LEGB-scope%E8%A6%8F%E5%89%87/\">LEGB規則</a>來參照變數，今天要介紹有兩個python的關鍵字可以打破這樣的規則</p>\n<h5 id=\"1-global\"><a href=\"#1-global\" class=\"headerlink\" title=\"1. global\"></a>1. global</h5><p>如果我們需要在函式內部修改global變數，可以使用global來宣告函式內的變數，再進一步作修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">var = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">access_local</span>():</span>    </span><br><span class=\"line\">    var = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">access_global</span>():</span>    </span><br><span class=\"line\">    <span class=\"keyword\">global</span> var    </span><br><span class=\"line\">    var = <span class=\"number\">15</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;global is &#x27;</span> + <span class=\"built_in\">str</span>(var))</span><br><span class=\"line\"><span class=\"keyword\">global</span> <span class=\"keyword\">is</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>access_local()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;global is &#x27;</span> + <span class=\"built_in\">str</span>(var))</span><br><span class=\"line\"><span class=\"keyword\">global</span> <span class=\"keyword\">is</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>access_global()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;global is &#x27;</span> + <span class=\"built_in\">str</span>(var))</span><br><span class=\"line\"><span class=\"keyword\">global</span> <span class=\"keyword\">is</span> <span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n<p>呼叫access_local的函數後，此時依照LEGB的規則，access_local內的var為local變數，因此對var作任何操作都不會影響到global變數。但在呼叫access_global函數後，此時函式內的var經過global宣告後即為global變數，此時對var作的操作就會影響到原本的global變數。</p>\n<h5 id=\"2-nonlocal\"><a href=\"#2-nonlocal\" class=\"headerlink\" title=\"2. nonlocal\"></a>2. nonlocal</h5><p>nonlocal和global類似，nonlocal用來讓宣告在內層巢狀函式中的變數，不再是local變數，而是轉為外層的enclosed函式的變數。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">target_value</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compare</span>(<span class=\"params\">y</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> x</span><br><span class=\"line\">        x = <span class=\"number\">3</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&gt; target&#x27;</span> <span class=\"keyword\">if</span> y &gt; x <span class=\"keyword\">else</span> <span class=\"string\">&#x27;&lt; target&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> compare</span><br><span class=\"line\">    </span><br><span class=\"line\">func = target_value(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(func(<span class=\"number\">5</span>))</span><br><span class=\"line\">&gt; target</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(func.__closure__[<span class=\"number\">0</span>].cell_contents)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>以之前介紹過的的<a href=\"/2016/11/08/Closure%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/\">Closure</a>例子來說明，本來設定10當作x target，當內層函式去捕捉到enclosed的自由變數來比較時，會得到”&lt; target”。本來捕捉到的自由變數只能讀取而無法修改，但是現在在內層函式透過nonlocal來宣告x變數，即可以將local變數轉為外層的enclosed變數，當自由變數x被修改成3之後，最後的比較結果會變數”&gt; target”</p>\n<p>參考資料：<br/><a href=\"http://www.programiz.com/python-programming/keyword-list\">python keyword list</a></p>\n","categories":["Python"],"tags":["Python"]},{"title":"使用大型語言模型(LLM)完成Text-to-SQL任務","url":"/2024/10/06/text-to-sql-by-llm/","content":"<p>Text-to-SQL（Text2SQL）是一種自然語言處理（NLP）技術，旨在將自然語言文本自動轉換為SQL查詢語句。這項技術的核心在於將用戶輸入的自然語言描述轉換為結構化的SQL查詢，使這些查詢可以在關聯式資料庫中執行。</p>\n<p>在現代化的數據平台中，通常會提供自助服務環境，讓使用者在獲得資料存取權限後，可以自行進行數據分析。然而，有時使用者所面臨的問題並不需要將資料匯入Power BI或Tableau等BI工具進行可視化分析，而只是希望在資料中透過查詢、篩選、聚合運算找到答案。</p>\n<p>在這種情境下，對於不熟悉SQL的使用者來說，Text-to-SQL服務是一個很好的解決方案，因為它可以幫助使用者輕鬆地將自然語言轉換為SQL查詢，從而快速獲得所需的數據。</p>\n<p>拜大型語言模型(LLM)的普及，Text-to-SQL可以很容易的透過LLM完成。以下透過建立Chinook這個SQLite範例資料庫來當作Text-to-SQL任務中查詢用的關聯式資料庫：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sqlite3</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下載 SQL 腳本</span></span><br><span class=\"line\">url = <span class=\"string\">&quot;https://raw.githubusercontent.com/lerocha/chinook-database/master/ChinookDatabase/DataSources/Chinook_Sqlite.sql&quot;</span></span><br><span class=\"line\">response = requests.get(url)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 儲存 SQL 腳本到本地檔案</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;Chinook_Sqlite.sql&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    f.write(response.text)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 連接到 SQLite 資料庫 (會自動建立資料庫檔案)</span></span><br><span class=\"line\">conn = sqlite3.connect(<span class=\"string\">&#x27;Chinook.db&#x27;</span>)</span><br><span class=\"line\">cursor = conn.cursor()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 執行 SQL 腳本來建立資料庫</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;Chinook_Sqlite.sql&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    cursor.executescript(f.read())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交變更並關閉連接</span></span><br><span class=\"line\">conn.commit()</span><br><span class=\"line\">conn.close()</span><br></pre></td></tr></table></figure>\n\n<p>查詢資料表清單可以看到這個範例資料庫裡面包含了總共有11張資料表</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">con = sqlite3.connect(<span class=\"string\">&quot;Chinook.db&quot;</span>)</span><br><span class=\"line\">cursorObj = con.cursor()</span><br><span class=\"line\">cursorObj.execute(<span class=\"string\">&quot;SELECT name FROM sqlite_master WHERE type=&#x27;table&#x27;;&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(cursorObj.fetchall())</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; [(<span class=\"string\">&#x27;Album&#x27;</span>,), (<span class=\"string\">&#x27;Artist&#x27;</span>,), (<span class=\"string\">&#x27;Customer&#x27;</span>,), (<span class=\"string\">&#x27;Employee&#x27;</span>,), (<span class=\"string\">&#x27;Genre&#x27;</span>,), (<span class=\"string\">&#x27;Invoice&#x27;</span>,), (<span class=\"string\">&#x27;InvoiceLine&#x27;</span>,), (<span class=\"string\">&#x27;MediaType&#x27;</span>,), (<span class=\"string\">&#x27;Playlist&#x27;</span>,), (<span class=\"string\">&#x27;PlaylistTrack&#x27;</span>,), (<span class=\"string\">&#x27;Track&#x27;</span>,)]</span></span><br></pre></td></tr></table></figure>\n\n<p>以Employee這張資料表為例子，可以將資料表名稱和欄位清單提供給Gemini，並請Gemini將問題轉成SQL:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> getpass</span><br><span class=\"line\"><span class=\"keyword\">import</span> google.generativeai <span class=\"keyword\">as</span> genai</span><br><span class=\"line\"></span><br><span class=\"line\">prompt = <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">Please convert question into SQL query by following table and column information.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">table: Employee</span></span><br><span class=\"line\"><span class=\"string\">column: EmployeeId, LastName, FirstName, Title, ReportsTo, BirthDate, HireDate, Address, City, State, Country, PostalCode, Phone, Fax, Email</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Question: How many employees come from Canada?</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Configure Gemini</span></span><br><span class=\"line\">GEMINI_API_KEY = getpass.getpass() <span class=\"comment\"># input your gemini api key</span></span><br><span class=\"line\">genai.configure(api_key=GEMINI_API_KEY)</span><br><span class=\"line\"></span><br><span class=\"line\">model = genai.GenerativeModel(<span class=\"string\">&#x27;gemini-1.5-flash&#x27;</span>)</span><br><span class=\"line\">response = model.generate_content(prompt)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.text)</span><br></pre></td></tr></table></figure>\n\n<p>可以看到Gemini依據prompt生成了一段SQL，直接讀這段SQL也有符合前面給的問題。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">&gt;&gt;</span><span class=\"operator\">&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">AS</span> &quot;Number of Canadian Employees&quot;</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Employee</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> Country <span class=\"operator\">=</span> <span class=\"string\">&#x27;Canada&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>直接把這段SQL拿去查詢資料庫也能得到正確答案，所以在提供資料表和欄位清單的情況下，LLM確實可以生成出能執行的SQL。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">cursorObj.execute(<span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">SELECT COUNT(*) AS &quot;Number of Canadian Employees&quot;</span></span><br><span class=\"line\"><span class=\"string\">FROM Employee</span></span><br><span class=\"line\"><span class=\"string\">WHERE Country = &#x27;Canada&#x27;;&quot;&quot;&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(cursorObj.fetchall())</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; [(8,)]</span></span><br></pre></td></tr></table></figure>\n\n<p>到這裡可以發現，如果要作出一個簡單的Text-to-SQL服務，只要依據使用者的問題找到正確的資料表，接著將提示詞、資料表資訊與問題提供給LLM就可以詠唱出一段「可能」可以執行的SQL語法。</p>\n","categories":["LLM"],"tags":["Machine Learning","SQL","Text-to-SQL","LLM","prompt","Gemini"]},{"title":"使用Python裝飾器(Decorator)對函式實作","url":"/2017/05/20/%E4%BD%BF%E7%94%A8Python%E8%A3%9D%E9%A3%BE%E5%99%A8(Decorator)%E5%B0%8D%E5%87%BD%E5%BC%8F%E5%AF%A6%E4%BD%9C/","content":"<p>Python中的decorator是一種對python語法的轉換寫法，使用decorator可以更方便的對函式作修改，也可以提高程式的可讀性。但是decorator只是一種語法糖，使用decorator並不會對語法產生改變，只是讓程式寫法可以更加的簡潔，並且讓開發者可以更方便的使用。</p>\n<p>下面開始來說明一下，如何使用decorator來實作在函式的修改:</p>\n<p>假設我們寫了一個執行sql的函式:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">select_execute</span>(<span class=\"params\">sql</span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;execute select sql query!&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>如果我們想要對這個執行sql的函式，用一個debug模式來包起來，並在debug模式印出執行的sql與執行的時間，這時可以透過<a href=\"/2016/11/08/Closure%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/\">closure</a>來處理函式</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">debug_query</span>(<span class=\"params\">func</span>):</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">debug_execute</span>(<span class=\"params\">sql</span>):</span>        </span><br><span class=\"line\">        exec_msg = func(sql)        </span><br><span class=\"line\">        exec_time = datetime.now()        </span><br><span class=\"line\">        debug_msg = <span class=\"string\">&quot;&quot;&quot;        </span></span><br><span class=\"line\"><span class=\"string\">        Execute: &#123;sql&#125;        </span></span><br><span class=\"line\"><span class=\"string\">        Result: &#123;exec_msg&#125;        </span></span><br><span class=\"line\"><span class=\"string\">        Execute Time: &#123;exec_time&#125;&quot;&quot;&quot;</span>        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> debug_msg.<span class=\"built_in\">format</span>(**<span class=\"built_in\">locals</span>())    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> debug_execute</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sql = <span class=\"string\">&#x27;SELECT * FROM TABLE&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>select_execute(sql)  <span class=\"comment\"># 不使用debug模式來執行select sql</span></span><br><span class=\"line\">execute select sql query!</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func = debug_query(select_execute)  <span class=\"comment\"># 使用debug模式來執行select sql</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(sql)</span><br><span class=\"line\">Execute: SELECT * FROM TABLE</span><br><span class=\"line\">Result: execute select sql query!</span><br><span class=\"line\">Execute Time: <span class=\"number\">2017</span>-05-<span class=\"number\">20</span> <span class=\"number\">16</span>:09:<span class=\"number\">08.953792</span></span><br></pre></td></tr></table></figure>\n<p>從上面的範例可以看到，先將執行sql的函式傳入外部函式，並在內部函式捕捉後，加上debug要印的部份進行改寫，這樣就可以將執行sql的函式包裝成debug模式。下面是使用decorator的寫法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@debug_query</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">select_execute</span>(<span class=\"params\">sql</span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;execute select sql query!&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>select_execute(sql)</span><br><span class=\"line\">Execute: SELECT * FROM TABLE</span><br><span class=\"line\">Result: execute select sql query!</span><br><span class=\"line\">Execute Time: <span class=\"number\">2017</span>-05-<span class=\"number\">20</span> <span class=\"number\">16</span>:09:<span class=\"number\">08.953792</span></span><br></pre></td></tr></table></figure>\n<p>只要透過@和改寫的函式名稱，就可以簡化函式傳遞的語法，讓程式碼可以更加簡潔並達到相同效果</p>\n<p>decorator也可以支援帶參數，如果今天要簡單的多印出一行debug宣告，並指定是哪一種query type作說明，可以透過多加上一層outter函式來傳入參數</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">debug_describe</span>(<span class=\"params\">query_type</span>):</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">debug_query</span>(<span class=\"params\">func</span>):</span>        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">debug_execute</span>(<span class=\"params\">sql</span>):</span>            </span><br><span class=\"line\">            exec_msg = func(sql)            </span><br><span class=\"line\">            exec_time = datetime.now()            </span><br><span class=\"line\">            descirbe = <span class=\"string\">&#x27;It is &#123;&#125; debug mode&#x27;</span>.<span class=\"built_in\">format</span>(query_type)            </span><br><span class=\"line\">            debug_msg = <span class=\"string\">&quot;&quot;&quot;            </span></span><br><span class=\"line\"><span class=\"string\">            &#123;descirbe&#125;            </span></span><br><span class=\"line\"><span class=\"string\">            Execute: &#123;sql&#125;            </span></span><br><span class=\"line\"><span class=\"string\">            Result: &#123;exec_msg&#125;            </span></span><br><span class=\"line\"><span class=\"string\">            Execute Time: &#123;exec_time&#125;&quot;&quot;&quot;</span>            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> debug_msg.<span class=\"built_in\">format</span>(**<span class=\"built_in\">locals</span>())       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> debug_execute    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> debug_query</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func = debug_describe(<span class=\"string\">&#x27;select&#x27;</span>)(select_execute)  <span class=\"comment\"># 不使用decorator寫法</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(sql)</span><br><span class=\"line\">It <span class=\"keyword\">is</span> select debug mode</span><br><span class=\"line\">Execute: SELECT * FROM TABLEResult: execute select sql query!</span><br><span class=\"line\">Execute Time: <span class=\"number\">2017</span>-05-<span class=\"number\">20</span> <span class=\"number\">16</span>:09:<span class=\"number\">08.962798</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@debug_describe(<span class=\"params\"><span class=\"string\">&#x27;select&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">select_execute</span>(<span class=\"params\">sql</span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;execute select sql query!&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>select_execute(sql)  <span class=\"comment\"># 使用decorator寫法It is select debug mode</span></span><br><span class=\"line\">Execute: SELECT * FROM TABLE</span><br><span class=\"line\">Result: execute select sql query!</span><br><span class=\"line\">Execute Time: <span class=\"number\">2017</span>-05-<span class=\"number\">20</span> <span class=\"number\">16</span>:09:<span class=\"number\">08.962798</span></span><br></pre></td></tr></table></figure>\n<p>參考資料:<br/><a href=\"https://wiki.python.org/moin/PythonDecorators\">PythonDecorators</a><br/><a href=\"https://codequs.com/p/Ski411egq/understanding-decorators-in-python/\">Understanding Decorators in Python</a><br/><a href=\"http://ot-note.logdown.com/posts/67571/-decorator-with-without-arguments-in-function-class-form\">Python Decorator 四種寫法範例 Code</a></p>\n","categories":["Python"],"tags":["Python"]},{"title":"位置引數(Positional Argument)與關鍵字引數(Keyword Argument)","url":"/2016/08/22/%E4%BD%8D%E7%BD%AE%E5%BC%95%E6%95%B8-Positional-Argument-%E8%88%87%E9%97%9C%E9%8D%B5%E5%AD%97%E5%BC%95%E6%95%B8-Keyword-Argument/","content":"<p>Python函式參數所接收的引數(Argument)，主要可以分成兩種，分別為位置引數(Positional Argument)和關鍵字引數(Keyword Argment)，以下我們先來看個例子，說明什麼是位置引數</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">total_score</span>(<span class=\"params\">eng_score, math_score, eng_weight, math_weight</span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> eng_scoreeng_weight + math_scoremath_weight</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>total_score(<span class=\"number\">80</span>, <span class=\"number\">90</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>)</span><br><span class=\"line\"><span class=\"number\">85</span></span><br></pre></td></tr></table></figure>\n<p>假設今天我們寫了一個簡單的函式來計算小考的平均成績，共有英文和數學兩科，兩科各有一個權重比例來計算出綜合成績。這個函式要傳入4個引數，所以在呼叫時我們必須提供所有的引數(即4個)，而傳入的引數會被設成相應位置上參數的值。</p>\n<p>eng_score被設成80、eng_weight被設成0.2、math_score被設成90、math_weight被設成0.8，這就是位置引數</p>\n<p>函式接收的參數，也可以指定一個預設值。假設預設的計算分數的權重都是固定一半一半，我們可以在函式撰寫時就給予一個預設的權重值。有預設值的參數為選用參數，在沒有傳入引數的情況下，python會使用預設值；而沒有預計值的參數為必要參數，在呼叫函式時必須傳入所有必要參數</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">total_score</span>(<span class=\"params\">eng_score, math_score, eng_weight=<span class=\"number\">0.5</span>, math_weight=<span class=\"number\">0.5</span></span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> eng_scoreeng_weight + math_scoremath_weight</span><br></pre></td></tr></table></figure>\n<p>若要改變參數的預設值，我們也可以直接使用額外的位置引數，就可以取代原來的預設值，或者也可以使用關鍵字引數來傳遞引數。以下為幾個呼叫的範例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>total_score(<span class=\"number\">80</span>, <span class=\"number\">90</span>)  <span class=\"comment\"># 省略且不指定有預設值的參數</span></span><br><span class=\"line\"><span class=\"number\">85</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>total_score(eng_score=<span class=\"number\">80</span>, eng_weight=<span class=\"number\">0.2</span>, math_score=<span class=\"number\">90</span>, math_weight=<span class=\"number\">0.8</span>)  <span class=\"comment\"># 使用關鍵字引數，可隨意安排順序</span></span><br><span class=\"line\"><span class=\"number\">88</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>total_score(<span class=\"number\">80</span>, <span class=\"number\">90</span>, math_weight=<span class=\"number\">0.8</span>, eng_weight=<span class=\"number\">0.2</span>)  <span class=\"comment\"># 混用位置和關鍵字引數</span></span><br><span class=\"line\"><span class=\"number\">88</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>total_score(<span class=\"number\">80</span>, <span class=\"number\">90</span>, <span class=\"number\">0.2</span>, <span class=\"number\">0.8</span>)  <span class=\"comment\"># 單純使用位置引數</span></span><br><span class=\"line\"><span class=\"number\">88</span></span><br></pre></td></tr></table></figure>\n<p>其中可以看到使用關鍵字引數的好處在於，關鍵字引數可以讓函式呼叫變得具彈性，即針對自己所需的選用參數來指定引數；甚至也可以讓函式呼叫更加具可讀性，特別在傳入布林引數時。例如在排序時決定要不要作逆向排序，sorted(text, reverse=True)比起sorted(text, True)可讀性來的更高</p>\n<p>有兩個要注意的地方，第一個是函式語法不允許具預設值的參數之後接非預設值的參數，會引發SyntaxError。例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">total_score</span>(<span class=\"params\">eng_score, eng_weight=<span class=\"number\">0.5</span>, math_score, math_weight=<span class=\"number\">0.5</span></span>):</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>SyntaxError</span><br></pre></td></tr></table></figure>\n<p>再來是傳入函式的引數，若是位置引數和關鍵字引數混用的話，位置引數務必放在關鍵字引數的前面，否則也是會引發SyntaxError。所以total_score(math_weight=0.8, eng_weight=0.2, 80, 90)是不行的</p>\n","categories":["Python"],"tags":["Python"]},{"title":"使用assert來實作，第一次寫測試就上手","url":"/2017/09/07/%E4%BD%BF%E7%94%A8assert%E4%BE%86%E5%AF%A6%E4%BD%9C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AF%AB%E6%B8%AC%E8%A9%A6%E5%B0%B1%E4%B8%8A%E6%89%8B/","content":"<p>雖然python已經有很好用的測試框架可以使用，不過對於剛開始想要自己寫測試的人，這些框架該怎麼使用還是需要花點時間學習一番。在真正進入使用測試框架之後，不彷先來作個簡單的測試感覺一下，其實我們可以很簡單的使用python的assert來實作看看。</p>\n<p>假設今天要設計提款功能，其中有兩個函式，一個會回傳存款減去提款剩下的金額，一個會檢查提款金額只能以1000為單位。所以這台atm很簡單，就是只讓你提1000為單位的金額，而且不能提超過你餘額的錢。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">withdraw</span>(<span class=\"params\">deposit, money</span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> deposit - money</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_withdraw</span>(<span class=\"params\">money</span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;accept&#x27;</span> <span class=\"keyword\">if</span> money % <span class=\"number\">1000</span> == <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"string\">&#x27;refuse&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>接著就是來寫一個測試用的function class，把要測試的不同條件寫進去，如果全pass就給個PASS訊息。function class只是一個簡單的方法把函式都集中起來，當然可以再作不同的變化。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskTest</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_withdraw</span>(<span class=\"params\">self, func</span>):</span>        </span><br><span class=\"line\">        <span class=\"keyword\">assert</span> func(<span class=\"number\">1200</span>, <span class=\"number\">2000</span>) &amp;lt; <span class=\"number\">0</span>, <span class=\"string\">&#x27;存款小於提款不能允許提出&#x27;</span>        </span><br><span class=\"line\">        <span class=\"keyword\">assert</span> func(<span class=\"number\">3000</span>, <span class=\"number\">2000</span>) &gt; <span class=\"number\">0</span>, <span class=\"string\">&#x27;存款大於提款需允許提出&#x27;</span>        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;ALL withdraw PASS!&#x27;</span>)    </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_check_withdraw</span>(<span class=\"params\">self, func</span>):</span>        </span><br><span class=\"line\">        <span class=\"keyword\">assert</span> func(<span class=\"number\">1300</span>) == <span class=\"string\">&#x27;refuse&#x27;</span>, <span class=\"string\">&#x27;提款金額非以1000為單位必須拒絕&#x27;</span>        </span><br><span class=\"line\">        <span class=\"keyword\">assert</span> func(<span class=\"number\">1000</span>) == <span class=\"string\">&#x27;accept&#x27;</span>, <span class=\"string\">&#x27;提款金額以1000為單位必須接受&#x27;</span>        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;All check_withdraw test PASS!&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>接著就開始執行測試囉!</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>tester = TaskTest()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>tester.test_withdraw(withdraw)</span><br><span class=\"line\">ALL withdraw PASS!</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>tester.test_check_withdraw(check_withdraw)</span><br><span class=\"line\">All check_withdraw test PASS!</span><br></pre></td></tr></table></figure>\n<p>那如果今天有人不小心動到函式內容，1000被改成1300會發生什麼事情呢？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_withdraw</span>(<span class=\"params\">money</span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;accept&#x27;</span> <span class=\"keyword\">if</span> money % <span class=\"number\">1300</span> == <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"string\">&#x27;refuse&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>一樣執行看看，就會發現在作檢查提款的測試時被assert中斷了!當測試沒測過就可以趕快回去檢查一下程式碼究竟發生什麼問題了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>tester = TaskTest()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>tester.test_withdraw(withdraw)</span><br><span class=\"line\">ALL withdraw PASS!</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>tester.test_check_withdraw(check_withdraw)</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">&quot;assert.py&quot;</span>, line <span class=\"number\">23</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    tester.test_check_withdraw(check_withdraw)</span><br><span class=\"line\">  File <span class=\"string\">&quot;assert.py&quot;</span>, line <span class=\"number\">15</span>, <span class=\"keyword\">in</span> test_check_withdraw</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> func(<span class=\"number\">1300</span>) == <span class=\"string\">&#x27;refuse&#x27;</span>, <span class=\"string\">&#x27;提款金額非以1000為單位必須拒絕&#x27;</span></span><br><span class=\"line\">AssertionError: 提款金額非以<span class=\"number\">1000</span>為單位必須拒絕</span><br></pre></td></tr></table></figure>\n<p>第一次寫測試其實可以從python的assert開始玩起，自己就可以簡單寫單元測試囉！針對已經是大型的系統就可以考慮使用一些python的測試框架作單元測試或是整合測試。如果像這樣的單元測試要一進步的話，可以先從使用python的<a href=\"https://docs.python.org/3.4/library/unittest.html\">unittest</a>開始！</p>\n","categories":["Python"],"tags":["Python","Test"]},{"title":"使用*args和**kwargs來拆開函式參數","url":"/2016/08/31/%E4%BD%BF%E7%94%A8args%E5%92%8Ckwargs%E4%BE%86%E6%8B%86%E9%96%8B%E5%87%BD%E5%BC%8F%E5%8F%83%E6%95%B8/","content":"<p>我們可以透過拆開運算符，來達到建立具有接收不固定位置引數和不估定關鍵字引數的函式。假設我們今天要建立一個，可以讀取不固定引數數量的函式，就會很有用。</p>\n<p>舉例來說，當我們要建立一個能將所有引數平方相加函式，可以使用下列寫法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum_of_power</span>(<span class=\"params\">args</span>):</span></span><br><span class=\"line\">    result = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> arg <span class=\"keyword\">in</span> args:    </span><br><span class=\"line\">        result += arg ** <span class=\"number\">2</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sum_of_power(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sum_of_power([<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sum_of_power(*[<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>][<span class=\"number\">2</span>:]))</span><br><span class=\"line\"><span class=\"number\">61</span></span><br></pre></td></tr></table></figure>\n<p>有*前綴的argv表示函式接收的引數是一個元組(type(args)會得到&lt;class ‘tuple’=””&gt;)，像是把傳入的多個引數packing成一個元組，再透過拆開運算符來將元組拆開成多個位置引數作處理。而關鍵字引數也可以應用在位置引數之後，假如我們要讓相加的引數改成可指定的次方向，可在函式加上關鍵字引數：</class></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum_of_power</span>(<span class=\"params\">args power=<span class=\"number\">2</span></span>):</span></span><br><span class=\"line\">    result = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> arg inargs:    </span><br><span class=\"line\">        result += arg * power </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sum_of_power(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)  <span class=\"comment\"># 僅指定位置引數</span></span><br><span class=\"line\"><span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sum_of_power(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, power=<span class=\"number\">1</span>)  <span class=\"comment\"># 同時指定位置引數和關鍵字引數</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>有兩個*前綴的kwargv表示接收的引數是一個字典(type(kwargs)會得到&lt;class ‘dict’=””&gt;)，像是把傳入的多個關鍵字引數packing成一個字典，再透過拆開運算符來將字典拆開成多個關鍵字引數作處理。假設今天要針對不同會員設定多個會員詳細資料，可以用下列寫法:</class></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">personal_detail</span>(<span class=\"params\">account, **kwargs</span>):</span>    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Account detail: &#x27;</span> + account)    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> kwargs.keys():        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(key + <span class=\"string\">&#x27;: &#x27;</span> + kwargs[key])</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>personal_detail(<span class=\"string\">&#x27;a1234@gmail.com&#x27;</span>, first_name=<span class=\"string\">&#x27;Tom&#x27;</span>, last_name=<span class=\"string\">&#x27;Lin&#x27;</span>)</span><br><span class=\"line\">Account detail: a1234@gmail.com</span><br><span class=\"line\">first_name: Tom</span><br><span class=\"line\">last_name: Lin</span><br></pre></td></tr></table></figure>\n<p>呼叫此函式時，只允許傳入一個位置引數，或是可以用關鍵字引數方式，來額外提供多個資訊。</p>\n<p>參考資料:<br/><a href=\"/2016/08/22/%E4%BD%8D%E7%BD%AE%E5%BC%95%E6%95%B8-Positional-Argument-%E8%88%87%E9%97%9C%E9%8D%B5%E5%AD%97%E5%BC%95%E6%95%B8-Keyword-Argument/\">位置引數(Positional Argument)與關鍵字引數(Keyword Argument)</a><br/><a href=\"/2016/08/15/%E9%80%8F%E9%81%8Estar%E4%BE%86%E5%B0%8D%E7%BE%A4%E9%9B%86%E8%B3%87%E6%96%99Unpacking/\">透過*和**來對群集資料Unpacking</a><br/><a href=\"https://docs.python.org/dev/tutorial/controlflow.html#arbitrary-argument-lists\">Python docs - Arbitrary Argument Lists</a></p>\n","categories":["Python"],"tags":["Python"]},{"title":"使用bind variable執行SQL","url":"/2016/09/27/%E4%BD%BF%E7%94%A8bind-variable%E5%9F%B7%E8%A1%8CSQL/","content":"<p>在寫sql的時候，一開始總是習慣帶入一支完整的sql，遇到要替換的地方就在程式用取代來處理。例如下面這個範例，為了insert不用的資料，用format來作字串替代完成一支sql</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sql = <span class=\"string\">&quot;INSERT INTO ALBUM(TITLE, ARTIST_ID) VALUES (&#x27;&#123;0&#125;&#x27;,&#123;1&#125;)&quot;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sql = sql.<span class=\"built_in\">format</span>(<span class=\"string\">&#x27;The Archive&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">INSERT INTO ALBUM(TITLE, ARTIST_ID) VALUES (<span class=\"string\">&#x27;The Archive&#x27;</span>,<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>可以看到要insert的資料，如果是char型態會用’’括起來。但是當今天要取代的字串有特殊符號或是有引號處理起來就會很麻煩，像下面的例子在insert到db時就會造成syntax error</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sql = <span class=\"string\">&quot;INSERT INTO ALBUM(TITLE, ARTIST_ID) VALUES (&#x27;&#123;0&#125;&#x27;,&#123;1&#125;)&quot;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sql = sql.<span class=\"built_in\">format</span>(<span class=\"string\">&quot;It&#x27;s Time&quot;</span>, <span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">INSERT INTO ALBUM(TITLE, ARTIST_ID) VALUES (<span class=\"string\">&#x27;It&#x27;</span>s Time<span class=\"string\">&#x27;,2) # syntax error</span></span><br></pre></td></tr></table></figure>\n<p>所以再來要介紹一下用bind variable下SQL的好處，下面是一個oracle使用bind variable的方式，在執行SQL時，會將變數直接帶入:1和:2的位置，所以也不用考慮任何原本要處理的跳脫字元問題</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">sql = <span class=\"string\">&quot;INSERT INTO ALBUM (TITLE, ARTIST_ID) VALUES (:1, :2)&quot;</span></span><br><span class=\"line\">cursor.execute(sql, (<span class=\"string\">&quot;It&#x27;s Time&quot;</span>, <span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n<p>使用bind variable不止在處理SQL很方便之外，也可以避免有SQL injection的風險，甚至對操作DB的performance也有影響。</p>\n<p>例如對Oracle DB下SQL時，oracle首先會在share pool找到這支SQL是否之前曾執行過，有的話會取得這支SQL之前處理過的執行計畫(Execute Plan)並開始執行這支SQL；如果找不到的話oracle會hard parsing這支SQL，並找到最佳的執行計畫後才執行SQL。所以如果能在share pool找到之前有執行過的執行計畫，SQL執行前就不用再經過hard parsing。</p>\n<p>但是oracle在share pool尋找的時候，只有完全相同的SQL才會被認為有對應到。所以當我們在程式使用取代字串來完成SQL，在執行時每一支SQL都會被視為不同的SQL，自然每一次的SQL執行前都必須要經過hard parsing</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> ALBUM(TITLE, ARTIST_ID) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;The Archive&#x27;</span>,<span class=\"number\">1</span>)  # 兩支<span class=\"keyword\">SQL</span>會被oracle視為不同的<span class=\"keyword\">SQL</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> ALBUM(TITLE, ARTIST_ID) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;Hear Me&#x27;</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>為了避免這個問題，可以使用bind variable來下SQL，因為採用bind variable的SQL會被視為同一支SQL</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">sql = <span class=\"string\">&#x27;INSERT INTO ALBUM(TITLE, ARTIST_ID) VALUES (:1, :2)&#x27;</span></span><br><span class=\"line\">cursor.execute(sql, (<span class=\"string\">&quot;It&#x27;s Time&quot;</span>, <span class=\"number\">2</span>))  <span class=\"comment\"># 兩支SQL會被oracle視為相同的SQL</span></span><br><span class=\"line\">cursor.execute(sql, (<span class=\"string\">&quot;Hear Me&quot;</span>, <span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n\n<p>因此採用bind variable在操作SQL上不止處理起更方便(不用特別處理跳脫字元)，也更安全(避免SQL injection)，甚至更快速(重使用最佳化過後的執行計畫)</p>\n","categories":["SQL&NoSQL"],"tags":["Python","SQL"]},{"title":"使用collections中的namedtuple來操作簡單的物件結構","url":"/2017/03/02/%E4%BD%BF%E7%94%A8collections%E4%B8%AD%E7%9A%84namedtuple%E4%BE%86%E6%93%8D%E4%BD%9C%E7%B0%A1%E5%96%AE%E7%9A%84%E7%89%A9%E4%BB%B6%E7%B5%90%E6%A7%8B/","content":"<p>tuple在python中是一種不可變動(immutable)的資料結構，相較於list是可變動的(mutable)，兩者共同都可以使用index來讀取值，但因為tuple為不可變動，所以一經宣告即無法修改其中的值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>drink = (<span class=\"string\">&#x27;Black Tea&#x27;</span>, <span class=\"string\">&#x27;regular&#x27;</span>, <span class=\"string\">&#x27;sugar free&#x27;</span>)  <span class=\"comment\"># 我要一杯紅茶，正常冰量不加糖</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>drink[<span class=\"number\">0</span>]  <span class=\"comment\"># 可以使用index來讀取tuple中的item</span></span><br><span class=\"line\">Black Tea</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>drink[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;Green Tea&#x27;</span>  <span class=\"comment\"># tuple為不可變動，所以無法透過assign來修改其中的值</span></span><br><span class=\"line\">TypeError: <span class=\"string\">&#x27;tuple&#x27;</span> <span class=\"built_in\">object</span> does <span class=\"keyword\">not</span> support item assignment</span><br></pre></td></tr></table></figure>\n<p>tuple很適合用來儲存一些不需要頻繁變動的資料，但是在使用上要使用index來讀取tuple中item的值，若是tuple中的item數量少也許還沒問題，但如果tuple中的item數量很多，甚至是開發一段時間又沒寫註解，往往最後這種index的讀取就變成一種魔術數字(magic number)，造成維護上的困難。</p>\n<p>namedtuple是tuple的擴展，因為namedtuple在使用上可以透過類似讀取欄位(field)名稱的方式，來取用tuple不同的item資料，所以有時候namedtuple就很適合用來代替tuple儲存資料。如果有需要頻繁讀取tuple中的item，於是你開始想建立class和物件來操作，但是資料欄位又沒有到這麼複雜到需要額外建class，這種情況很適合。</p>\n<p>下面馬上來介紹一下namedtuple的使用方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> namedtuple</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Drink = namedtuple(<span class=\"string\">&#x27;Drink&#x27;</span>, <span class=\"string\">&#x27;product, ice, sugar&#x27;</span>)  <span class=\"comment\"># 宣告一種名稱(Drink)且包含三個欄位(product, ice, sugar)</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>black_tea = Drink(<span class=\"string\">&#x27;Black Tea&#x27;</span>, <span class=\"string\">&#x27;regular&#x27;</span>, <span class=\"string\">&#x27;sugar free&#x27;</span>)  <span class=\"comment\"># 我要一杯紅茶，正常冰量不加糖</span></span><br><span class=\"line\"></span><br><span class=\"line\">Drink(product=<span class=\"string\">&#x27;Black Tea&#x27;</span>, ice=<span class=\"string\">&#x27;regular&#x27;</span>, sugar=<span class=\"string\">&#x27;sugar free&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>black_tea.product  <span class=\"comment\"># 可以使用一開始定義的欄位名稱來讀取值</span></span><br><span class=\"line\">Black Tea</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>black_tea[<span class=\"number\">0</span>]  <span class=\"comment\"># 當然也可以使用index來讀取值</span></span><br><span class=\"line\">Black Tea</span><br></pre></td></tr></table></figure>\n<p>宣告namedtuple需要給定兩個參數，第一個是tuple的名稱(name)，再來是這個tuple包含的欄位名稱(field_name)。欄位名稱使用字串格式代入所有需要的欄位(其中的,可加可不加)。以上面的例子來看，tuple名稱就是Drink，欄位名稱是product, ice和sugar三個。之後透過宣告的namedtuple來儲存資料，就可以使用欄位名稱來讀取item值了!</p>\n<p>namedtuple可以和tuple一樣作unpack</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>product, ice, sugar = black_tea</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sugar</span><br><span class=\"line\">sugar free</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>ice</span><br><span class=\"line\">normal</span><br></pre></td></tr></table></figure>\n<p>也有支援直接從list和dict轉成namedtuple</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>l = [<span class=\"string\">&#x27;Bubble Tea&#x27;</span>, <span class=\"string\">&#x27;regular&#x27;</span>, <span class=\"string\">&#x27;regular&#x27;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>bubble_tea = Drink._make(l)  <span class=\"comment\"># 使用_make來將list轉成namedtuple</span></span><br><span class=\"line\">Drink(product=<span class=\"string\">&#x27;Bubble Tea&#x27;</span>, ice=<span class=\"string\">&#x27;regular&#x27;</span>, sugar=<span class=\"string\">&#x27;regular&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = &#123;<span class=\"string\">&#x27;product&#x27;</span>: <span class=\"string\">&#x27;Bubble Tea&#x27;</span>, <span class=\"string\">&#x27;ice&#x27;</span>: <span class=\"string\">&#x27;regular&#x27;</span>, <span class=\"string\">&#x27;sugar&#x27;</span>: <span class=\"string\">&#x27;regular&#x27;</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>bubble_tea = Drink(**d)  <span class=\"comment\"># 使用拆開映射運算符(double-star-operator)來拆開dict轉成namedtuple</span></span><br><span class=\"line\">Drink(product=<span class=\"string\">&#x27;Bubble Tea&#x27;</span>, ice=<span class=\"string\">&#x27;regular&#x27;</span>, sugar=<span class=\"string\">&#x27;regular&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>將namedtuple轉成dict(此dict為collection裡面OrderDict)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>bubble_tea_dict = bubble_tea._asdict()</span><br><span class=\"line\">OrderedDict([(<span class=\"string\">&#x27;product&#x27;</span>, <span class=\"string\">&#x27;Bubble Tea&#x27;</span>), (<span class=\"string\">&#x27;ice&#x27;</span>, <span class=\"string\">&#x27;regular&#x27;</span>), (<span class=\"string\">&#x27;sugar&#x27;</span>, <span class=\"string\">&#x27;regular&#x27;</span>)])</span><br></pre></td></tr></table></figure>\n<p>如果今天已經存在一個namedtuple，需要使用現存的namedtuple來新增一個新的namedtuple也可以使用_filed來辦到</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Ingredient = namedtuple(<span class=\"string\">&#x27;Ingredient&#x27;</span>, <span class=\"string\">&#x27;tapioca_pearls, grass_jelly, flan&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Order = namedtuple(<span class=\"string\">&#x27;Order&#x27;</span>, Drink._fields + Ingredient._fields)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 我要一杯奶茶，正常冰半糖加布丁</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>drink_order = Order(<span class=\"string\">&#x27;Milk Tea&#x27;</span>, <span class=\"string\">&#x27;regular&#x27;</span>, <span class=\"string\">&#x27;half sugar&#x27;</span>, <span class=\"literal\">False</span>, <span class=\"literal\">False</span>, <span class=\"literal\">True</span>)</span><br><span class=\"line\">Order(product=<span class=\"string\">&#x27;Milk Tea&#x27;</span>, ice=<span class=\"string\">&#x27;regular&#x27;</span>, sugar=<span class=\"string\">&#x27;half sugar&#x27;</span>, tapioca_pearls=<span class=\"literal\">False</span>, grass_jelly=<span class=\"literal\">False</span>, flan=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n<p>在開發過程中，如果可以巧妙的使用namedtuple，可以讓程式更加有可讀性，也可以讓幫助下降日後的維護成本!</p>\n<p><a href=\"https://docs.python.org/3.6/library/collections.html#collections.namedtuple\">Python docs - namedtuple() Factory Function for Tuples with Named Fields</a></p>\n","categories":["Python"],"tags":["Python","Collections"]},{"title":"使用format與locals進行字串格式化","url":"/2016/08/08/%E4%BD%BF%E7%94%A8format%E8%88%87locals%E9%80%B2%E8%A1%8C%E5%AD%97%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/","content":"<p>寫python在做字串格式化的時候，常常會使用format來達成。一般簡單的format用法，會使用大括弧加數字編號配合引數順序做取代</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">str</span> = <span class=\"string\">&quot;My name is &#123;0&#125;, and I&#x27;m &#123;1&#125; years old&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&#x27;Tom&#x27;</span>, <span class=\"number\">18</span>)</span><br><span class=\"line\"><span class=\"string\">&quot;My name is Tom, and I&#x27;m 18 years old&quot;</span></span><br></pre></td></tr></table></figure>\n<p>在Python3.1開始可以省略數字編號</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">str</span> = <span class=\"string\">&quot;My name is &#123;&#125;, and I&#x27;m &#123;&#125; years old&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&#x27;Tom&#x27;</span>, <span class=\"number\">18</span>)</span><br><span class=\"line\"><span class=\"string\">&quot;My name is Tom, and I&#x27;m 18 years old&quot;</span></span><br></pre></td></tr></table></figure>\n<p>或是使用欄位名稱來取代對應引數</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span> = <span class=\"string\">&quot;My name is &#123;name&#125;, and I&#x27;m &#123;age&#125; years old&quot;</span>.<span class=\"built_in\">format</span>(name=<span class=\"string\">&#x27;Tom&#x27;</span>, age=<span class=\"number\">18</span>)</span><br><span class=\"line\"><span class=\"string\">&quot;My name is Tom, and I&#x27;m 18 years old&quot;</span></span><br></pre></td></tr></table></figure>\n<p>format可以搭配dict一起使用，將dict傳入並取出其中的value來完成取代</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = &#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Tom&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">18</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">str</span> = <span class=\"string\">&quot;My name is &#123;0[name]&#125;, and I&#x27;m &#123;0[age]&#125; years old&quot;</span>.<span class=\"built_in\">format</span>(d)</span><br><span class=\"line\"><span class=\"string\">&quot;My name is Tom, and I&#x27;m 18 years old&quot;</span></span><br></pre></td></tr></table></figure>\n<p>既然可以使用dict來結合format做字串取代，所以我們可透過內建的locals()來取得一個儲存當前區域變數的dict，並把區域變數的值帶入fomat來取代對應引數</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name = <span class=\"string\">&#x27;Tom&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age = <span class=\"number\">18</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">str</span> = <span class=\"string\">&quot;My name is &#123;0[name]&#125;, and I&#x27;m &#123;0[age]&#125; years old&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">locals</span>())</span><br><span class=\"line\"><span class=\"string\">&quot;My name is Tom, and I&#x27;m 18 years old&quot;</span></span><br></pre></td></tr></table></figure>\n<p>我們可以再進一步使用拆開映射(maping unpacking)運算來將dic拆開來傳入format，python就會自動填入對應的值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name = <span class=\"string\">&#x27;Tom&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age = <span class=\"number\">18</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">str</span> = <span class=\"string\">&quot;My name is &#123;name&#125;, and I&#x27;m &#123;age&#125; years old&quot;</span>.<span class=\"built_in\">format</span>(**<span class=\"built_in\">locals</span>())</span><br><span class=\"line\"><span class=\"string\">&quot;My name is Tom, and I&#x27;m 18 years old&quot;</span></span><br></pre></td></tr></table></figure>\n<p>任何的dict都可以使用，上面的例子可以改寫成</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = &#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Tom&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">18</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">str</span> = <span class=\"string\">&quot;My name is &#123;name&#125;, and I&#x27;m &#123;age&#125; years old&quot;</span>.<span class=\"built_in\">format</span>(**d)</span><br><span class=\"line\"><span class=\"string\">&quot;My name is Tom, and I&#x27;m 18 years old&quot;</span></span><br></pre></td></tr></table></figure>\n<p>參考資料:<br/><a href=\"/2016/08/15/%E9%80%8F%E9%81%8Estar%E4%BE%86%E5%B0%8D%E7%BE%A4%E9%9B%86%E8%B3%87%E6%96%99Unpacking/\">Python Unpacking請參考: 透過*和**來對群集資料Unpacking</a></p>\n","categories":["Python"],"tags":["Python"]},{"title":"將*當作函式參數來強制使用關鍵字引數","url":"/2016/09/13/%E5%B0%87%E6%98%9F%E7%AC%A6%E7%95%B6%E4%BD%9C%E5%87%BD%E5%BC%8F%E5%8F%83%E6%95%B8%E4%BE%86%E5%BC%B7%E5%88%B6%E4%BD%BF%E7%94%A8%E9%97%9C%E9%8D%B5%E5%AD%97%E5%BC%95%E6%95%B8/","content":"<p>很特別的可以直接當作一個函式的參數來使用。如果當作函式的參數，可以用來限定*之後不可以使用位置引數，但可以使用關鍵字引數，這樣的使用方法被稱為Keyword-Only Arguments</p>\n<p>以下以<a href=\"/2016/08/22/%E4%BD%8D%E7%BD%AE%E5%BC%95%E6%95%B8-Positional-Argument-%E8%88%87%E9%97%9C%E9%8D%B5%E5%AD%97%E5%BC%95%E6%95%B8-Keyword-Argument/\">位置引數(Positional Argument)與關鍵字引數(Keyword Argument)</a>中的計算小考平均成績為例說明:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">total_score</span>(<span class=\"params\">eng_score, math_score, eng_weight=<span class=\"number\">0.5</span>, math_weight=<span class=\"number\">0.5</span></span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> eng_scoreeng_weight + math_scoremath_weight</span><br></pre></td></tr></table></figure>\n<p>在這個範例中，可以使用以下4種方式來呼叫函式都是沒問題的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>total_score(<span class=\"number\">80</span>, <span class=\"number\">90</span>)  <span class=\"comment\"># 省略且不指定有預設值的參數</span></span><br><span class=\"line\"><span class=\"number\">85</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>total_score(eng_score=<span class=\"number\">80</span>, eng_weight=<span class=\"number\">0.2</span>, math_score=<span class=\"number\">90</span>, math_weight=<span class=\"number\">0.8</span>)  <span class=\"comment\"># 使用關鍵字引數，可隨意安排順序</span></span><br><span class=\"line\"><span class=\"number\">88</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>total_score(<span class=\"number\">80</span>, <span class=\"number\">90</span>, math_weight=<span class=\"number\">0.8</span>, eng_weight=<span class=\"number\">0.2</span>)  <span class=\"comment\"># 混用位置和關鍵字引數</span></span><br><span class=\"line\"><span class=\"number\">88</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>total_score(<span class=\"number\">80</span>, <span class=\"number\">90</span>, <span class=\"number\">0.2</span>, <span class=\"number\">0.8</span>)  <span class=\"comment\"># 單純使用位置引數</span></span><br><span class=\"line\"><span class=\"number\">88</span></span><br></pre></td></tr></table></figure>\n<p>但如果今天在原本的函式中，把*加入到第三個參數，這樣在第四種單純使用位置引數來作函式呼叫就會引發TypeError，因為在之後不能使用位置引數</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">total_score</span>(<span class=\"params\">eng_score, math_score, * , eng_weight=<span class=\"number\">0.5</span>, math_weight=<span class=\"number\">0.5</span></span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> eng_scoreeng_weight + math_score*math_weight</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>total_score(<span class=\"number\">80</span>, <span class=\"number\">90</span>, <span class=\"number\">0.2</span>, <span class=\"number\">0.8</span>)  <span class=\"comment\"># 單純使用位置引數</span></span><br><span class=\"line\">TypeError: total_score() takes <span class=\"number\">2</span> positional arguments but <span class=\"number\">4</span> were given</span><br></pre></td></tr></table></figure>\n<p>今天如果要設計成防止呼叫者使用任何位置引數，就可以將*做為第一個參數，這樣就可以強迫叫者全部使用關鍵字引數，若使用任何的位置引數，都會引發TypeError</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">total_score</span>(<span class=\"params\">*, eng_score, math_score, eng_weight=<span class=\"number\">0.5</span>, math_weight=<span class=\"number\">0.5</span></span>):</span>    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> eng_scoreeng_weight + math_score*math_weight</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>total_score(<span class=\"number\">80</span>, <span class=\"number\">90</span>)  <span class=\"comment\"># 省略且不指定有預設值的參數</span></span><br><span class=\"line\">TypeError: total_score() takes <span class=\"number\">0</span> positional arguments but <span class=\"number\">2</span> were given</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>total_score(<span class=\"number\">80</span>, <span class=\"number\">90</span>, math_weight=<span class=\"number\">0.8</span>, eng_weight=<span class=\"number\">0.2</span>)  <span class=\"comment\"># 混用位置和關鍵字引數</span></span><br><span class=\"line\">TypeError: total_score() takes <span class=\"number\">0</span> positional arguments but <span class=\"number\">2</span> positional arguments (<span class=\"keyword\">and</span> <span class=\"number\">2</span> keyword-only arguments) were given</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>total_score(<span class=\"number\">80</span>, <span class=\"number\">90</span>, <span class=\"number\">0.2</span>, <span class=\"number\">0.8</span>)  <span class=\"comment\"># 單純使用位置引數</span></span><br><span class=\"line\">TypeError: total_score() takes <span class=\"number\">0</span> positional arguments but <span class=\"number\">4</span> were given</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.python.org/dev/peps/pep-3102/\">PEP 3102 – Keyword-Only Arguments</a></p>\n","categories":["Python"],"tags":["Python"]},{"title":"讓我們用collections中的Counter來計算數量","url":"/2018/05/26/%E8%AE%93%E6%88%91%E5%80%91%E7%94%A8Counter%E4%BE%86%E8%A8%88%E7%AE%97%E6%95%B8%E9%87%8F/","content":"<p>Python的collection模組裡面其實包含了許多非常實用的資料結構，比如之前介紹過的<br/><a href=\"/2017/03/02/%E4%BD%BF%E7%94%A8collections%E4%B8%AD%E7%9A%84namedtuple%E4%BE%86%E6%93%8D%E4%BD%9C%E7%B0%A1%E5%96%AE%E7%9A%84%E7%89%A9%E4%BB%B6%E7%B5%90%E6%A7%8B/\">namedtuple</a>。今天要談的是Counter，Counter是一個dict的子類別，用來對hashable的物件作計算。</p>\n<p>比如說我們今天要來幫公司裡面每個不同的team訂飲料好了，以下簡易一點不接受客製化調味，在建立Counter可以有以下幾種方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用mapping建立Counter，輸入一個dict</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>team1 = Counter(&#123;<span class=\"string\">&#x27;BlackTea&#x27;</span>: <span class=\"number\">3</span>, <span class=\"string\">&#x27;GreenTea&#x27;</span>: <span class=\"number\">2</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>: <span class=\"number\">1</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\"># 使用iterable建立Counter，輸入一個list</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>team2 = Counter([<span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>])</span><br><span class=\"line\"><span class=\"comment\"># 使用keyword參數建立Counter，輸入key-value組合</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>team3 = Counter(GreenTea=<span class=\"number\">3</span>, MilkTea=<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>team1[<span class=\"string\">&#x27;BlackTea&#x27;</span>]  <span class=\"comment\"># 可以直接當作dict存取</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>team2[<span class=\"string\">&#x27;GreanTea&#x27;</span>]  <span class=\"comment\"># 取出不存在的item即為0</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>可以看到透過Couter能透過三種不同的方法來建立，就看使用的情境比較適合哪一種。而Counter也可以直接就當作dict取出值，特別是如果取出不存有的item，其計數會為0，並不會出現dict的KeyError。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>team1 + team2  <span class=\"comment\"># 使用加法運算符</span></span><br><span class=\"line\">Counter(&#123;<span class=\"string\">&#x27;BlackTea&#x27;</span>: <span class=\"number\">6</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>: <span class=\"number\">4</span>, <span class=\"string\">&#x27;GreenTea&#x27;</span>: <span class=\"number\">2</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>team2 - team3  <span class=\"comment\"># 使用減法運算符</span></span><br><span class=\"line\">Counter(&#123;<span class=\"string\">&#x27;BlackTea&#x27;</span>: <span class=\"number\">3</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>team2 &amp;amp; team3  <span class=\"comment\"># 運算兩者的交集</span></span><br><span class=\"line\">Counter(&#123;<span class=\"string\">&#x27;MilkTea&#x27;</span>: <span class=\"number\">3</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>team2 - team3  <span class=\"comment\"># 運算兩者的聯集</span></span><br><span class=\"line\">Counter(&#123;<span class=\"string\">&#x27;MilkTea&#x27;</span>: <span class=\"number\">3</span>, <span class=\"string\">&#x27;GreenTea&#x27;</span>: <span class=\"number\">3</span>, <span class=\"string\">&#x27;BlackTea&#x27;</span>: <span class=\"number\">3</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>Counter也可以支援不同的運算符來對Counter物件進行操作，來達成對不同集合元件的運算。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>drink_order = team1 + team2 + team3</span><br><span class=\"line\">Counter(&#123;<span class=\"string\">&#x27;MilkTea&#x27;</span>: <span class=\"number\">7</span>, <span class=\"string\">&#x27;BlackTea&#x27;</span>: <span class=\"number\">6</span>, <span class=\"string\">&#x27;GreenTea&#x27;</span>: <span class=\"number\">5</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">list</span>(drink_order)  <span class=\"comment\"># 將Counter的items轉成list</span></span><br><span class=\"line\">[<span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"string\">&#x27;GreenTea&#x27;</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">set</span>(drink_order)  <span class=\"comment\"># 將Counter的items轉成set</span></span><br><span class=\"line\">[<span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"string\">&#x27;GreenTea&#x27;</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">dict</span>(drink_order)  <span class=\"comment\"># 將Counter的items轉成一般dict</span></span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;BlackTea&#x27;</span>: <span class=\"number\">6</span>, <span class=\"string\">&#x27;GreenTea&#x27;</span>: <span class=\"number\">5</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>: <span class=\"number\">7</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>drink_order.items()  <span class=\"comment\"># 取出item pairs</span></span><br><span class=\"line\">dict_items([(<span class=\"string\">&#x27;MilkTea&#x27;</span>, <span class=\"number\">7</span>), (<span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"number\">6</span>), (<span class=\"string\">&#x27;GreenTea&#x27;</span>, <span class=\"number\">5</span>)])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>drink_order.keys()  <span class=\"comment\"># 取出key值</span></span><br><span class=\"line\">dict_keys([<span class=\"string\">&#x27;MilkTea&#x27;</span>, <span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"string\">&#x27;GreenTea&#x27;</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>drink_order.values()  <span class=\"comment\"># 取出value值</span></span><br><span class=\"line\">dict_values([<span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sum</span>(drink_order.values())  <span class=\"comment\"># 取出value值並加總得到全部數量</span></span><br><span class=\"line\"><span class=\"number\">18</span></span><br></pre></td></tr></table></figure>\n<p>因為Counter是dict的一個字類別，所以基本上他可以辦到原本dict可以作到的資料轉型，包含透過items()來逐一取出每個pair，或是直接可以使用values()並加總來計算出Counter裡面總計有多少數量的東西。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">list</span>(drink_order.elements())</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>[<span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"string\">&#x27;GreenTea&#x27;</span>, <span class=\"string\">&#x27;GreenTea&#x27;</span>, <span class=\"string\">&#x27;GreenTea&#x27;</span>, <span class=\"string\">&#x27;GreenTea&#x27;</span>, <span class=\"string\">&#x27;GreenTea&#x27;</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>, <span class=\"string\">&#x27;MilkTea&#x27;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>drink_order.most_common(<span class=\"number\">3</span>)</span><br><span class=\"line\">[(<span class=\"string\">&#x27;MilkTea&#x27;</span>, <span class=\"number\">7</span>), (<span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"number\">6</span>), (<span class=\"string\">&#x27;GreenTea&#x27;</span>, <span class=\"number\">5</span>)]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>drink_order.most_common(<span class=\"number\">2</span>)</span><br><span class=\"line\">[(<span class=\"string\">&#x27;MilkTea&#x27;</span>, <span class=\"number\">7</span>), (<span class=\"string\">&#x27;BlackTea&#x27;</span>, <span class=\"number\">6</span>)]</span><br></pre></td></tr></table></figure>\n<p>Counter還支援兩個函式，elements可以幫你展開所有的items。而most_common則會使用數量作排序，並且可以指定要排出前幾名。</p>\n<p>Counter其實使用上非常方便，讓我們看一下Counter在實戰上可以拿來解什麼樣的問題，以下選兩個LeetCode的題目來看看Counter可以怎麼樣被使用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;389. Find the Difference</span></span><br><span class=\"line\"><span class=\"string\">Given two strings s and t which consist of only lowercase letters.</span></span><br><span class=\"line\"><span class=\"string\">String t is generated by random shuffling string s and then add one more letter </span></span><br><span class=\"line\"><span class=\"string\">at a random position. Find the letter that was added in t.</span></span><br><span class=\"line\"><span class=\"string\">Input:</span></span><br><span class=\"line\"><span class=\"string\">s = &quot;abcd&quot;</span></span><br><span class=\"line\"><span class=\"string\">t = &quot;abcde&quot;</span></span><br><span class=\"line\"><span class=\"string\">Output: e (&#x27;e&#x27; is the letter that was added.)</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findTheDifference</span>(<span class=\"params\">self, s, t</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    s_counter = Counter(s)</span><br><span class=\"line\">    t_counter = Counter(t)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>(t_counter - s_counter)[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<p>LeetCode-389是給定兩個字串s和t，其中要判斷t比s多了哪個字元。這時候就可以直接將s和t分別以iterable的方式建立兩個Counter，而我們知道t會比s多一個字元，於是再透過減法來找到t和s的差集後，輸出是哪個item即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;819. Most Common Word</span></span><br><span class=\"line\"><span class=\"string\">Given a paragraph and a list of banned words, return the most frequent word </span></span><br><span class=\"line\"><span class=\"string\">that is not in the list of banned words. It is guaranteed there is at least </span></span><br><span class=\"line\"><span class=\"string\">one word that isn&#x27;t banned, and that the answer is unique.</span></span><br><span class=\"line\"><span class=\"string\">Words in the list of banned words are given in lowercase, and free of punctuation.</span></span><br><span class=\"line\"><span class=\"string\">Words in the paragraph are not case sensitive.  The answer is in lowercase.</span></span><br><span class=\"line\"><span class=\"string\">Example:</span></span><br><span class=\"line\"><span class=\"string\">Input: </span></span><br><span class=\"line\"><span class=\"string\">paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;</span></span><br><span class=\"line\"><span class=\"string\">banned = [&quot;hit&quot;]</span></span><br><span class=\"line\"><span class=\"string\">Output: &quot;ball&quot;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mostCommonWord</span>(<span class=\"params\">self, paragraph, banned</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> re</span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    words = re.sub(<span class=\"string\">&quot;[!|?|&#x27;|,|;|.]&quot;</span>, <span class=\"string\">&#x27;&#x27;</span>, paragraph).lower().split(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Counter(word <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words <span class=\"keyword\">if</span> word <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> banned).most_common(<span class=\"number\">1</span>)[<span class=\"number\">0</span>][<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<p>LeetCode-819是給定一個段落，還有被禁掉的詞清單，接著輸出出現字詞次數最多次，而且沒有被禁掉的詞。這邊先將所有詞轉成小寫，接著再透過空白切分後，將特殊符號取代掉只留下字詞。再來就可以將不存在於禁用清單的詞拿來建立Counter，然後使用most_common取出次數最高的第一名，接著再輸出是哪個詞即可。</p>\n<p>Counter其實在計算次數的時候非常實用，特別是在項目很多的情況下，而且還需要作加減運算時，可以嘗試使用Counter來解問題，絕對可以幫助你省下很多的時間的！</p>\n<p>參考資料:<br/><a href=\"https://docs.python.org/2/library/collections.html#collections.Counter\">Python docs - Counter dict subclass for counting hashable objects</a></p>\n","categories":["Python"],"tags":["Python","Collections"]},{"title":"透過*和**來對群集資料Unpacking","url":"/2016/08/15/%E9%80%8F%E9%81%8Estar%E4%BE%86%E5%B0%8D%E7%BE%A4%E9%9B%86%E8%B3%87%E6%96%99Unpacking/","content":"<p>在處理python的序列資料(tuple, list)或是映射資料(dict)，並要把資料傳入function時，可使用*和**運算符來分別對兩種資料作unpacking並傳入函式</p>\n<p>針對序列(tuple, list)可以使用拆開序列運算符(sequence unpacking operator)，在變數前加上*前綴來達成</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product</span>(<span class=\"params\">a, b, c</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a * b * c</span><br><span class=\"line\">    </span><br><span class=\"line\">T = (<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">product(T[<span class=\"number\">0</span>], T[<span class=\"number\">1</span>], T[<span class=\"number\">2</span>])  <span class=\"comment\"># 用切片讀出tuple資料傳入函式</span></span><br><span class=\"line\">product(*T)  <span class=\"comment\"># 直接將tuple unpacking成3個資料項傳入函式</span></span><br><span class=\"line\">product(T[<span class=\"number\">0</span>], *T[<span class=\"number\">1</span>:])  <span class=\"comment\"># 先切出1個資料項，再拆開2個資料項</span></span><br><span class=\"line\"></span><br><span class=\"line\">L = [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">product(L[<span class=\"number\">0</span>], L[<span class=\"number\">1</span>], L[<span class=\"number\">2</span>])  <span class=\"comment\"># 用切片讀出list資料傳入函式</span></span><br><span class=\"line\">product(*L)  <span class=\"comment\"># 直接將list unpacking成3個資料項傳入函式</span></span><br><span class=\"line\">product(L[<span class=\"number\">0</span>], *L[<span class=\"number\">1</span>:])  <span class=\"comment\"># 先切出1個資料項，再拆開2個資料項</span></span><br></pre></td></tr></table></figure>\n<p>上面的範列product函式會接受3個引數，透過*來直接對序列作unpacking，就能將序列內的資料項直接傳入函式，而不用先讀出來或是對序列作切片(slice)</p>\n<p>針對映射資料(dict)則是使用拆開映射運算符(mapping unpacking operator)，在變數前加上**前綴</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">D = &#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">2</span>, <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"number\">5</span>, <span class=\"string\">&#x27;c&#x27;</span>: <span class=\"number\">10</span>&#125;</span><br><span class=\"line\">product(**D)</span><br></pre></td></tr></table></figure>\n<p>上面範例會將dic以key-value拆開，在傳入函式後會將每個key的value分配給與key相同名稱的參數(parameter)。要注意的是，如果字典裡面的key和函式參數對應不起來，則會引發TypeError。</p>\n<p>除非函式的參數有設定預設值(Default)，例如以下範例函式參數d有預計值20，若字典沒有d，d在函式中就會帶入預設值而不會引發TypeError</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product</span>(<span class=\"params\">a, b, c, d=<span class=\"number\">20</span></span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a * b * c * d</span><br><span class=\"line\">    </span><br><span class=\"line\">D = &#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">2</span>, <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"number\">5</span>, <span class=\"string\">&#x27;c&#x27;</span>: <span class=\"number\">10</span>&#125;</span><br><span class=\"line\">product(**D)</span><br></pre></td></tr></table></figure>\n<p>參考資料:<br/><a href=\"/2016/08/22/%E4%BD%8D%E7%BD%AE%E5%BC%95%E6%95%B8-Positional-Argument-%E8%88%87%E9%97%9C%E9%8D%B5%E5%AD%97%E5%BC%95%E6%95%B8-Keyword-Argument/\">函式參數預設值請參考: 位置引數(Positional Argument)與關鍵字引數(Keyword Argument)</a><br/><a href=\"https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists\">Python docs - unpacking argument lists</a></p>\n","categories":["Python"],"tags":["Python"]}]